<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面向对象 | 暮成雪的博客</title><meta name="keywords" content="面向对象"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Java如何通过反射创建对象？一、反射是什么 JAVA反射机制是在运行状态中，对于任意一个类，都能够获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性（先获得class对象）；这种动态获取类信息以及动态调用对象内容就称为java语言的反射机制。 反射机制可以于运行时加载、探知、使用编译期间完全未知的类。程序在运行状态时，可以动态加载一个只有名称的类，对于任意一个已">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/7/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="1. Java如何通过反射创建对象？一、反射是什么 JAVA反射机制是在运行状态中，对于任意一个类，都能够获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性（先获得class对象）；这种动态获取类信息以及动态调用对象内容就称为java语言的反射机制。 反射机制可以于运行时加载、探知、使用编译期间完全未知的类。程序在运行状态时，可以动态加载一个只有名称的类，对于任意一个已">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:25.612Z">
<meta property="article:modified_time" content="2020-03-12T13:17:10.000Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="面向对象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-03-12 13:17:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面向对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:25.612Z" title="发表于 2021-12-18 14:42:25">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-03-12T13:17:10.000Z" title="更新于 2020-03-12 13:17:10">2020-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE%E9%83%A8%E5%88%86/">JavaSE部分</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面向对象"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/7/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/7/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Java如何通过反射创建对象？"><a href="#1-Java如何通过反射创建对象？" class="headerlink" title="1. Java如何通过反射创建对象？"></a>1. Java如何通过反射创建对象？</h1><h2 id="一、反射是什么"><a href="#一、反射是什么" class="headerlink" title="一、反射是什么"></a>一、反射是什么</h2><p> JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够<strong>获取这个类的所有属性和方法</strong>；对于任意一个对象，都能够<strong>调用它的任意一个方法和属性（先获得class对象）</strong>；这种<strong>动态获取类信息以及动态调用对象内容</strong>就称为<strong>java语言的反射机制</strong>。</p>
<p>反射机制可以于运行时加载、探知、使用编译期间完全未知的类。程序在运行状态时，可以动态加载一个只有名称的类，对于任意一个已经加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。</p>
<p>Class类的对象包含了某个被加载类的结构，一个被加载的类对应一个 Class对象。当一个class被加载，或当加载器<strong>（class loader）的defineClass()被 JVM调用</strong>，JVM 便自动产生一个Class 对象。加载完类之后，在<strong>堆内存</strong>中，就产生了一个 <strong>Class 类型的对象（一个 类只有一个 Class 对象）</strong>，这个对象就包含了完整的<strong>类的结构信息</strong>。 我们可以通过这个对象看到类的结构。这个对象就像<strong>一面镜子</strong>，透过 这个镜子看到类的结构，所以，我们形象的称之为：反射。</p>
<p><strong>Class类是Reflection的根源</strong>。 针对任何您想动态加载、运行的类，唯有先获得相应的Class 对象</p>
<h2 id="二、反射的作用"><a href="#二、反射的作用" class="headerlink" title="二、反射的作用"></a>二、反射的作用</h2><ul>
<li>在运行时<strong>判断</strong>任意一个对象所属的类；</li>
<li>在运行时<strong>构造</strong>任意一个类的对象；</li>
<li>在运行时<strong>判断</strong>任意一个类所具有的成员变量和方法；</li>
<li>在运行时<strong>调用</strong>任意一个对象的方法；</li>
</ul>
<h2 id="三、反射的实现"><a href="#三、反射的实现" class="headerlink" title="三、反射的实现"></a>三、反射的实现</h2><p>我们知道，要使用一个类，就要先把它加载到虚拟机中，生成一个Class对象。这个class对象就保存了这个类的一切信息。 反射机制的实现，就是获取这个Class对象，通过Class对象去访问类、对象的元数据以及运行时的数据。</p>
<p>有三种方法获得类的Class对象：<strong>Class.forName(String className)、className.class、实例对象.getClass()；</strong></p>
<h2 id="四、反射涉及的API及其使用"><a href="#四、反射涉及的API及其使用" class="headerlink" title="四、反射涉及的API及其使用"></a>四、反射涉及的API及其使用</h2><p>  <strong>反射首先获取Class对象；然后获取Method类和Field类；最后通过Method和Field类进行具体的方法调用或属性访问。</strong></p>
<h3 id="1-在运行时获取对象所属类的类名等信息"><a href="#1-在运行时获取对象所属类的类名等信息" class="headerlink" title="1:在运行时获取对象所属类的类名等信息"></a>1:在运行时获取对象所属类的类名等信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.getClass().getName();</span><br></pre></td></tr></table></figure>

<h3 id="2-通过反射机制创建class对象（三种方法）"><a href="#2-通过反射机制创建class对象（三种方法）" class="headerlink" title="2:通过反射机制创建class对象（三种方法）"></a>2:通过反射机制创建class对象（<strong>三种方法</strong>）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class1 = Class.forName(className);</span><br><span class="line">class2 = 对象名.getClass();</span><br><span class="line">class3 = 对象名.class;</span><br></pre></td></tr></table></figure>

<h3 id="3：在运行时，通过创建class对象，获取自己的父类信息"><a href="#3：在运行时，通过创建class对象，获取自己的父类信息" class="headerlink" title="3：在运行时，通过创建class对象，获取自己的父类信息"></a>3：在运行时，通过创建class对象，获取自己的父类信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Class&lt;?&gt; clazz = Class.forName(当前类);</span><br><span class="line"> Class&lt;?&gt; parentClass = clazz.getSuperclass();</span><br><span class="line">parentClass.getName()；<span class="comment">//获得父类名</span></span><br></pre></td></tr></table></figure>

<h3 id="4：通过反射机制创建一个类的对象"><a href="#4：通过反射机制创建一个类的对象" class="headerlink" title="4：通过反射机制创建一个类的对象"></a>4：通过反射机制创建一个类的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">step1：反射创建<span class="class"><span class="keyword">class</span>对象（见上面）</span></span><br><span class="line"><span class="class"><span class="title">step2</span>：<span class="title">Classname</span> 对象</span>=classname.newInstance(参数);</span><br></pre></td></tr></table></figure>

<h3 id="5：获取类的全部方法，存于一个数组中"><a href="#5：获取类的全部方法，存于一个数组中" class="headerlink" title="5：获取类的全部方法，存于一个数组中"></a>5：获取类的全部方法，存于一个数组中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建class对象</span></span><br><span class="line">  Class&lt;?&gt; clazz = Class.forName(ClassName);</span><br><span class="line"><span class="comment">// 返回声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 </span></span><br><span class="line">  Method[] getDeclaredMethods()；</span><br><span class="line"><span class="comment">//返回可被访问的公共方法      </span></span><br><span class="line">  Method method[] = clazz.getMethods();</span><br></pre></td></tr></table></figure>

<h3 id="6：获取类的全部字段，存于一个数组中"><a href="#6：获取类的全部字段，存于一个数组中" class="headerlink" title="6：获取类的全部字段，存于一个数组中"></a>6：获取类的全部字段，存于一个数组中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(classname);</span><br><span class="line"><span class="comment">// 取得本类已声明的所有字段，包括私有的、保护的</span></span><br><span class="line">Field[] field = clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">// 取得本类中可访问的所有公共字段</span></span><br><span class="line">Field[] filed1 = clazz.getFields();</span><br></pre></td></tr></table></figure>

<h3 id="7：操作类-对象-的某个属性（包括私有）"><a href="#7：操作类-对象-的某个属性（包括私有）" class="headerlink" title="7：操作类/对象 的某个属性（包括私有）"></a>7：操作类/对象 的某个属性（包括私有）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(classname);</span><br><span class="line"><span class="comment">//返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 包括公共、私有、保护的字段。</span></span><br><span class="line">Field field = clazz.getDeclaredField(字段名);</span><br><span class="line"><span class="comment">//禁用Java权限修饰符的作用，无视方法权限限制进行访问</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。     field.set(该类的一个对象, 字段值);</span></span><br></pre></td></tr></table></figure>

<h3 id="8：调用类-对象-的某个方法（包括私有）"><a href="#8：调用类-对象-的某个方法（包括私有）" class="headerlink" title="8：调用类/对象 的某个方法（包括私有）"></a>8：调用类/对象 的某个方法（包括私有）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(classname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method getMethod(String name, Class&lt;?&gt;... parameterTypes) </span></span><br><span class="line"><span class="comment">//返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。//获取一个公有函数</span></span><br><span class="line">Method method = clazz.getMethod(方法名，参数类型);</span><br><span class="line"><span class="comment">//调用具体某个实例对象的这个公有方法</span></span><br><span class="line">method.invoke(实例对象，参数值);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) </span></span><br><span class="line"><span class="comment">//返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 包括私有、保护、公有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个私有函数</span></span><br><span class="line">Method private_method=class.getDeclaredMethod(函数名，参数类型）;</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁用Java权限限定符的作用，使私有函数可访问</span></span><br><span class="line">private_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用具体实例对象的这个方法</span></span><br><span class="line">private_method.invoke(实例对象,参数）;</span><br></pre></td></tr></table></figure>

<h2 id="五、代码示例"><a href="#五、代码示例" class="headerlink" title="五、代码示例"></a>五、代码示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test0212;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MuChengxue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/2/12 12:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: test0212</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了看清楚Java反射部分代码，所有异常我都最后抛出来给虚拟机处理！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo1.  通过Java反射机制得到类的包名和类名</span></span><br><span class="line">        Demo1();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo2.  验证所有的类都是Class类的实例对象</span></span><br><span class="line">        Demo2();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo3.  通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]，无参构造</span></span><br><span class="line">        Demo3();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo4:  通过Java反射机制得到一个类的构造函数，并实现构造带参实例对象</span></span><br><span class="line">        Demo4();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo5:  通过Java反射机制操作成员变量, set 和 get</span></span><br><span class="line">        Demo5();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等</span></span><br><span class="line">        Demo6();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo7: 通过Java反射机制调用类中方法</span></span><br><span class="line">        Demo7();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Demo8: 通过Java反射机制获得类加载器</span></span><br><span class="line">        Demo8();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo1: 通过Java反射机制得到类的包名和类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo1: package name: &quot;</span> + person.getClass().getPackage().getName() + <span class="string">&quot;，&quot;</span></span><br><span class="line">                + <span class="string">&quot;fullpath class name: &quot;</span> + person.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo2: 验证所有的类都是Class类的实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类</span></span><br><span class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; class2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写法1, 可能抛出 ClassNotFoundException [多用这个写法]</span></span><br><span class="line">        class1 = Class.forName(<span class="string">&quot;test0212.Person&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo2:(写法1) 包名: &quot;</span> + class1.getPackage().getName() + <span class="string">&quot;，&quot;</span></span><br><span class="line">                + <span class="string">&quot;完整类名: &quot;</span> + class1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写法2</span></span><br><span class="line">        class2 = Person.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo2:(写法2) 包名: &quot;</span> + class2.getPackage().getName() + <span class="string">&quot;，&quot;</span></span><br><span class="line">                + <span class="string">&quot;完整类名: &quot;</span> + class2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</span><br><span class="line">        class1 = Class.forName(<span class="string">&quot;test0212.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～</span></span><br><span class="line">        Person person = (Person) class1.newInstance();</span><br><span class="line">        person.setAge(<span class="number">20</span>);</span><br><span class="line">        person.setName(<span class="string">&quot;LeeFeng&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo3: &quot;</span> + person.getName() + <span class="string">&quot; : &quot;</span> + person.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</span><br><span class="line">        Person person1 = <span class="keyword">null</span>;</span><br><span class="line">        Person person2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        class1 = Class.forName(<span class="string">&quot;test0212.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//得到一系列构造函数集合</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = class1.getConstructors();</span><br><span class="line"></span><br><span class="line">        person1 = (Person) constructors[<span class="number">0</span>].newInstance();</span><br><span class="line">        person1.setAge(<span class="number">30</span>);</span><br><span class="line">        person1.setName(<span class="string">&quot;leeFeng&quot;</span>);</span><br><span class="line"></span><br><span class="line">        person2 = (Person) constructors[<span class="number">1</span>].newInstance(<span class="number">20</span>,<span class="string">&quot;leeFeng&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Demo4: &quot;</span> + person1.getName() + <span class="string">&quot; : &quot;</span> + person1.getAge()</span><br><span class="line">                + <span class="string">&quot;  ,   &quot;</span> + person2.getName() + <span class="string">&quot; : &quot;</span> + person2.getAge()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo5: 通过Java反射机制操作成员变量, set 和 get</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo5</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</span><br><span class="line">        class1 = Class.forName(<span class="string">&quot;test0212.Person&quot;</span>);</span><br><span class="line">        Object obj = class1.newInstance();</span><br><span class="line"></span><br><span class="line">        Field personNameField = class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        personNameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        personNameField.set(obj, <span class="string">&quot;胖虎先森&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Demo5: 修改属性之后得到属性变量的值：&quot;</span> + personNameField.get(obj));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo6</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</span><br><span class="line">        class1 = Class.forName(<span class="string">&quot;test0212.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得父类名称</span></span><br><span class="line">        Class&lt;?&gt;  superClass = class1.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo6:  SuperMan类的父类名: &quot;</span> + superClass.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Field[] fields = class1.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类中的成员: &quot;</span> + fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得类方法</span></span><br><span class="line">        Method[] methods = class1.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Demo6,取得SuperMan类的方法：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;函数名：&quot;</span> + methods[i].getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;函数返回类型：&quot;</span> + methods[i].getReturnType());</span><br><span class="line">            System.out.println(<span class="string">&quot;函数访问修饰符：&quot;</span> + Modifier.toString(methods[i].getModifiers()));</span><br><span class="line">            System.out.println(<span class="string">&quot;函数代码写法： &quot;</span> + methods[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈</span></span><br><span class="line">        Class&lt;?&gt; interfaces[] = class1.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;实现的接口类名: &quot;</span> + interfaces[i].getName() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo7: 通过Java反射机制调用类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo7</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</span><br><span class="line">        class1 = Class.forName(<span class="string">&quot;test0212.SuperMan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Demo7: \n调用无参方法fly()：&quot;</span>);</span><br><span class="line">        Method method = class1.getMethod(<span class="string">&quot;fly&quot;</span>);</span><br><span class="line">        method.invoke(class1.newInstance());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;调用有参方法walk(int m)：&quot;</span>);</span><br><span class="line">        Method method2 = class1.getMethod(<span class="string">&quot;walk&quot;</span>,<span class="keyword">int</span>.class);</span><br><span class="line">        method2.invoke(class1.newInstance(),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demo8: 通过Java反射机制得到类加载器信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在java中有三种类类加载器。[这段资料网上截取]</span></span><br><span class="line"><span class="comment">     1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。</span></span><br><span class="line"><span class="comment">     2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类</span></span><br><span class="line"><span class="comment">     3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo8</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</span><br><span class="line">        class1 = Class.forName(<span class="string">&quot;test0212.SuperMan&quot;</span>);</span><br><span class="line">        String nameString = class1.getClassLoader().getClass().getName();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Demo8: 类加载器类名: &quot;</span> + nameString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">ActionInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> BlueBriefs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;超人会飞耶～～&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlueBriefs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BlueBriefs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlueBriefs</span><span class="params">(<span class="keyword">boolean</span> blueBriefs)</span> </span>&#123;</span><br><span class="line">        BlueBriefs = blueBriefs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;超人会走耶～～走了&quot;</span> + m + <span class="string">&quot;米就走不动了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ActionInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-接口Interf-ace和抽象类abstract-class的区别"><a href="#2-接口Interf-ace和抽象类abstract-class的区别" class="headerlink" title="2. 接口Interf ace和抽象类abstract class的区别"></a>2. 接口Interf ace和抽象类abstract class的区别</h1><p>对于面向对象编程来说，抽象是它的一大特征之一。在 Java 中，可以通过两种形式来体现 OOP 的抽象：<strong>接口和抽象类</strong>。这两者有太多相似的地方，又有太多不同的地方。</p>
<h2 id="一、抽象类"><a href="#一、抽象类" class="headerlink" title="一、抽象类"></a>一、抽象类</h2><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，<strong>并不是所有的类都是用来描绘对象的，</strong>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<u>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样</u>。由于抽象类不能实例化对象，所以<strong>抽象类必须被继承，才能被使用</strong>。父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。在Java中抽象类表示的是一种继承关系，<strong>一个类只能继承一个抽象类，而一个类却可以实现多个接口</strong>。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在Java语言中使用abstract class来定义抽象类。如下实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : Employee.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, String address, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Constructing an Employee&quot;</span>);</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.address = address;</span><br><span class="line">      <span class="keyword">this</span>.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Inside Employee computePay&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mailing a check to &quot;</span> + <span class="keyword">this</span>.name</span><br><span class="line">       + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>.address);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + address + <span class="string">&quot; &quot;</span> + number;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> address;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String newAddress)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      address = newAddress;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> number;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : AbstractDemo.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">/* 以下是不允许的，会引发错误 */</span></span><br><span class="line">      Employee e = <span class="keyword">new</span> Employee(<span class="string">&quot;George W.&quot;</span>, <span class="string">&quot;Houston, TX&quot;</span>, <span class="number">43</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;\n Call mailCheck using Employee reference--&quot;</span>);</span><br><span class="line">      e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Employee.java:46: Employee is abstract; cannot be instantiated</span></span><br><span class="line"><span class="comment">      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);</span></span><br><span class="line"><span class="comment">                   ^</span></span><br><span class="line"><span class="comment">1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h3><p>我们能通过一般的方法继承Employee类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : Salary.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> salary; <span class="comment">//Annual salary</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(String name, String address, <span class="keyword">int</span> number, <span class="keyword">double</span></span></span></span><br><span class="line"><span class="params"><span class="function">      salary)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(name, address, number);</span><br><span class="line">       setSalary(salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Within mailCheck of Salary class &quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;Mailing check to &quot;</span> + getName()</span><br><span class="line">       + <span class="string">&quot; with salary &quot;</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> newSalary)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(newSalary &gt;= <span class="number">0.0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          salary = newSalary;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Computing salary pay for &quot;</span> + getName());</span><br><span class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li><strong>如果一个类包含抽象方法，那么该类必须是抽象类。</strong></li>
<li><strong>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</strong></li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : Salary.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> salary; <span class="comment">// Annual salary</span></span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Computing salary pay for &quot;</span> + getName());</span><br><span class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类总结规定"><a href="#抽象类总结规定" class="headerlink" title="抽象类总结规定"></a>抽象类总结规定</h3><ul>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li><strong>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</strong>。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li><strong>构造方法，<u>类方法（用 static 修饰</u>的方法）不能声明为抽象方法</strong>。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ul>
<h2 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是<strong>抽象方法的集合</strong>，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。<strong>类描述对象的属性和方法。接口则包含类要实现的方法。</strong><u>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法</u>。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul>
<li><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</p>
</li>
<li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p>
</li>
</ul>
<p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
<blockquote>
<p>在 JDK1.8，允许我们给接口添加两种非抽象的方法实现：</p>
<p>1、默认方法，添加 default 修饰即可；</p>
<p>2、静态方法，使用 static 修饰；示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="comment">//这个是默认方法</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> String <span class="title">get</span><span class="params">(String aa)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是jdk1.8默认实现方法...&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="comment">//这个是静态方法    </span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticmethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是静态方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>调用得话，静态方法只能通过接口名调用，不可以通过实现类的类名或者实现类的对象调用，default 方法只能通过接口实现类的对象来调用。</p>
</blockquote>
<h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><p>接口的声明语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[可见度] <span class="class"><span class="keyword">interface</span> 接口名称 [<span class="keyword">extends</span> 其他的接口名] </span>&#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameOfInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">//pubulic static final 字段</span></span><br><span class="line">   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : MammalInt.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      MammalInt m = <span class="keyword">new</span> MammalInt();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。下面的Sports接口被Hockey和Football接口继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名: Sports.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisitingTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 文件名: Football.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfQuarter</span><span class="params">(<span class="keyword">int</span> quarter)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 文件名: Hockey.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfPeriod</span><span class="params">(<span class="keyword">int</span> period)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overtimePeriod</span><span class="params">(<span class="keyword">int</span> ot)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hockey接口自己声明了<strong>四个方法</strong>，从Sports接口继承了<strong>两个方法</strong>，这样，实现Hockey接口的类需要实现<strong>六个方法。</strong>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p>
<h3 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h3><p>在Java中，类的多继承是不合法，但接口允许多继承。在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p>
<p><code>public interface Hockey extends Sports, Event</code></p>
<p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p>
<h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>最常用的继承接口是没有包含任何方法的接口。标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来<strong>测试</strong>允许做一些事情。</p>
<h3 id="接口的多继承-1"><a href="#接口的多继承-1" class="headerlink" title="接口的多继承"></a>接口的多继承</h3><p>在Java中，类的多继承是不合法，但接口允许多继承。</p>
<p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p>
<p>public interface Hockey extends Sports, Event</p>
<p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p>
<hr>
<h3 id="标记接口-1"><a href="#标记接口-1" class="headerlink" title="标记接口"></a>标记接口</h3><p>最常用的继承接口是没有包含任何方法的接口。标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来<strong>测试</strong>允许做一些事情。</p>
<p><strong>标记接口作用：</strong>简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<h2 id="三、抽象类和接口的区别"><a href="#三、抽象类和接口的区别" class="headerlink" title="三、抽象类和接口的区别"></a>三、抽象类和接口的区别</h2><h3 id="1、语法层面上的区别"><a href="#1、语法层面上的区别" class="headerlink" title="1、语法层面上的区别"></a>1、语法层面上的区别</h3><ul>
<li>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li>
<li>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li>
<li>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li>
<li>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<h3 id="2、设计层面上的区别"><a href="#2、设计层面上的区别" class="headerlink" title="2、设计层面上的区别"></a>2、设计层面上的区别</h3><p>1）<strong>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象</strong>。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 <strong>飞行</strong> 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>2）设计层面不同，<strong>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</strong>什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和 ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>
<p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有 <strong>open()</strong> 和 <strong>close()</strong> 两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在如果我们需要门具有报警 的功能，那么该如何实现？下面提供两种思路：</p>
<p>1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>
<p>2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的 open( ) 和 close( )，也许这个类根本就不具备 open( ) 和 close( ) 这两个功能，比如火灾报警器。</p>
<p>从这里可以看出， Door 的 open() 、close() 和 alarm() 根本就属于两个不同范畴内的行为，open() 和 close() 属于门本身固有的行为特性，而 alarm() 属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含 alarm() 行为，Door 设计为单独的一个抽象类，包含 open 和 close 两种行为。再设计一个报警门继承 Door 类和实现 Alarm 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、什么时候使用抽象类和接口"><a href="#3、什么时候使用抽象类和接口" class="headerlink" title="3、什么时候使用抽象类和接口"></a>3、什么时候使用抽象类和接口</h3><ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3811437.html">深入理解Java的接口和抽象类</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-interfaces.html">菜鸟教程</a></p>
<h1 id="3-Comparable和Comparator接口是干嘛的，区别？"><a href="#3-Comparable和Comparator接口是干嘛的，区别？" class="headerlink" title="3. Comparable和Comparator接口是干嘛的，区别？"></a>3. Comparable和Comparator接口是干嘛的，区别？</h1><h2 id="java-lang-Comparable全部源码"><a href="#java-lang-Comparable全部源码" class="headerlink" title="java.lang.Comparable全部源码"></a>java.lang.Comparable<T>全部源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object with the specified object for order.  Returns a</span></span><br><span class="line"><span class="comment">     * negative integer, zero, or a positive integer as this object is less</span></span><br><span class="line"><span class="comment">     * than, equal to, or greater than the specified object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The implementor must ensure &lt;tt&gt;sgn(x.compareTo(y)) ==</span></span><br><span class="line"><span class="comment">     * -sgn(y.compareTo(x))&lt;/tt&gt; for all &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt;.  (This</span></span><br><span class="line"><span class="comment">     * implies that &lt;tt&gt;x.compareTo(y)&lt;/tt&gt; must throw an exception iff</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;y.compareTo(x)&lt;/tt&gt; throws an exception.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The implementor must also ensure that the relation is transitive:</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(x.compareTo(y)&amp;gt;0 &amp;amp;&amp;amp; y.compareTo(z)&amp;gt;0)&lt;/tt&gt; implies</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;x.compareTo(z)&amp;gt;0&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Finally, the implementor must ensure that &lt;tt&gt;x.compareTo(y)==0&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * implies that &lt;tt&gt;sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/tt&gt;, for</span></span><br><span class="line"><span class="comment">     * all &lt;tt&gt;z&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;It is strongly recommended, but &lt;i&gt;not&lt;/i&gt; strictly required that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(x.compareTo(y)==0) == (x.equals(y))&lt;/tt&gt;.  Generally speaking, any</span></span><br><span class="line"><span class="comment">     * class that implements the &lt;tt&gt;Comparable&lt;/tt&gt; interface and violates</span></span><br><span class="line"><span class="comment">     * this condition should clearly indicate this fact.  The recommended</span></span><br><span class="line"><span class="comment">     * language is &quot;Note: this class has a natural ordering that is</span></span><br><span class="line"><span class="comment">     * inconsistent with equals.&quot;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In the foregoing description, the notation</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;sgn(&lt;/tt&gt;&lt;i&gt;expression&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; designates the mathematical</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;signum&lt;/i&gt; function, which is defined to return one of &lt;tt&gt;-1&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;0&lt;/tt&gt;, or &lt;tt&gt;1&lt;/tt&gt; according to whether the value of</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;expression&lt;/i&gt; is negative, zero or positive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o the object to be compared.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a negative integer, zero, or a positive integer as this object</span></span><br><span class="line"><span class="comment">     *          is less than, equal to, or greater than the specified object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified object is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the specified object&#x27;s type prevents it</span></span><br><span class="line"><span class="comment">     *         from being compared to this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Comparable使用"><a href="#Comparable使用" class="headerlink" title="Comparable使用"></a>Comparable使用</h2><p>Comparable是在集合内部定义的方法实现的排序，位于java.lang下。Comparable是一个对象本身就已经支持自比较所需要实现的接口，如String、Integer自己就实现了Comparable接口，可完成比较大小操作。自定义类要在加入list容器中后能够排序，也可以实现Comparable接口，在用Collections类的sort方法排序时若不指定Comparator，那就以自然顺序排序。所谓自然顺序就是实现Comparable接口设定的排序方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.test0212;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MuChengxue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/2/12 18:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: test.test0212</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> sorce;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">float</span> sorce)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sorce = sorce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getSorce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sorce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSorce</span><span class="params">(<span class="keyword">float</span> sorce)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sorce = sorce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">        Student stu=(Student)o;</span></span><br><span class="line"><span class="comment">        int m=(int)((((Student) o).sorce-sorce)*100);//成绩做降序排序</span></span><br><span class="line"><span class="comment">        m = m == 0 ? (age - ((Student) o).age) : m;//成绩一样，那在成绩排序的基础上按照年龄由小到大排序</span></span><br><span class="line"><span class="comment">        return m;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//排序的规则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person2 o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//引用类型（可以排序的类型）可以直接调用CompareTo方法</span></span><br><span class="line">        <span class="comment">//基本类型--使用   减</span></span><br><span class="line"><span class="comment">//        return this.age - o.age;//用this对象 - 参数中的对象，是按照该属性的升序进行的排列</span></span><br><span class="line"><span class="comment">//        return o.age - this.age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        return this.name.compareTo(o.name);</span></span><br><span class="line"><span class="comment">//        return o.name.compareTo(this.name);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age.compareTo(o.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而compareTo方法，实际上就是我们需要设置的排序的规则，到底按照什么样的方式进行排序。简单的记，使用this对象和参数比较，就是升序，反之就是降序。所以我们如果想要让Person集合中的对象按照年龄进行降序排列，就可以使用o.age -this.age；（基本类型可以使用减法替代compareTo）；这样，你再次使用Collections.sort就可以对Person的List进行排序了，排序的结果是按照年龄的降序。</p>
<p>总结一下，如果我们想要让一个List可以使用Collections.sort(list) 的方法进行排序，则必须要求集合中的元素类型，实现Comparable接口，也就是让他具备比较能力，这也是为什么Integer类型的数组可以排序，就是因为Integer已经实现了该接口，并且他是按照升序的规则实现的，这也就解释了为什么上边的第一个程序得到的结果是升序。好了那么既然Integer是按照升序的方式实现的排序，那么如果我想要得到一个降序的Integer集合该怎么办呢？难道就实现不了了么？我们接着来看下一个接口。</p>
<h2 id="java-util-Comparator使用"><a href="#java-util-Comparator使用" class="headerlink" title="java.util.Comparator使用"></a>java.util.Comparator<T>使用</h2><p>正如上文所说，对于已经实现了Comparable接口的集合，或者是我压根就不想实现Comparable接口的集合难道就排不了序了么，或者就无法更改排序的规则了么，实际上不是的，我们可以通过另一种方式来排序，就是利用Comparator接口。在集合的工具类中种还有这样的一个方法：</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> </p>
<p>我们可以通过这个方法实现上面的需求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o2 - o1;<span class="comment">//降序排列</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<p>比如这段代码，就实现了一个Integer集合的<strong>降序</strong>排列。这个接口中有一个方法叫做compare，里边包含两个参数：如果用第一个和第二个做比较得到的就是升序，反之得到的就是降序。同样的你也可以使用这种方式对我们自己定义的类记性排序。</p>
<h2 id="两种方法一起代码测试"><a href="#两种方法一起代码测试" class="headerlink" title="两种方法一起代码测试"></a>两种方法一起代码测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Comparable和Comparator两个接口的使用</span></span><br><span class="line"><span class="comment"> * 分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序</span></span><br><span class="line"><span class="comment"> * 如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 姓名（String）    年龄（int） 分数（float）</span></span><br><span class="line"><span class="comment"> * liusan             20         90.0F</span></span><br><span class="line"><span class="comment"> * lisi               22         90.0F</span></span><br><span class="line"><span class="comment"> * wangwu             20         99.0F</span></span><br><span class="line"><span class="comment"> * sunliu             22         100.0F</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 学生的信息是通过自定义的Student类的对象调用,初始化一下这四个学生的信息</span></span><br><span class="line">        ArrayList&lt;Person2&gt; stu=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Person2 stu1=<span class="keyword">new</span> Person2(<span class="string">&quot;liusan&quot;</span>,<span class="number">22</span>,<span class="number">90.0f</span>);</span><br><span class="line">        Person2 stu2=<span class="keyword">new</span> Person2(<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>,<span class="number">90.0f</span>);</span><br><span class="line">        Person2 stu3=<span class="keyword">new</span> Person2(<span class="string">&quot;wangwu&quot;</span>,<span class="number">20</span>,<span class="number">99.0f</span>);</span><br><span class="line">        Person2 stu4=<span class="keyword">new</span> Person2(<span class="string">&quot;sunliu&quot;</span>,<span class="number">22</span>,<span class="number">100.0f</span>);</span><br><span class="line">        stu.add(stu1);stu.add(stu2);stu.add(stu3);stu.add(stu4);</span><br><span class="line">        <span class="comment">//使用Comparable</span></span><br><span class="line">     <span class="comment">/*   Collections.sort(stu);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;name\t\tage\t\tscore&quot;);</span></span><br><span class="line"><span class="comment">        for (Student student : stu) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(student.getName()+&quot;\t\t&quot;+student.getAge()+&quot;\t\t&quot;+student.getSorce());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//使用Comparator</span></span><br><span class="line">        Collections.sort(stu, <span class="keyword">new</span> Comparator&lt;Person2&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person2 o1, Person2 o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> m=(<span class="keyword">int</span>) ((o2.getSorce()-o1.getSorce())*<span class="number">100</span>);<span class="comment">//成绩做降序排序</span></span><br><span class="line">                m=m==<span class="number">0</span>?(o1.getAge()-o2.getAge()):m;<span class="comment">//成绩一样，那在成绩排序的基础上按照年龄由小到大排序</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name\t\tage\t\tscore&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person2 person2 : stu) &#123;   															System.out.println(person2.getName()                                                            +<span class="string">&quot;\t\t&quot;</span>+person2.getAge()+<span class="string">&quot;\t\t&quot;</span>+person2.getSorce());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">name		age		score</span></span><br><span class="line"><span class="comment">sunliu		22		100.0</span></span><br><span class="line"><span class="comment">wangwu		20		99.0</span></span><br><span class="line"><span class="comment">lisi		20		90.0</span></span><br><span class="line"><span class="comment">liusan		22		90.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>两种方式，各有各的特点：使用Comparable方式比较时，我们将比较的规则写入了比较的类型中，其特点是高内聚。但如果哪天这个规则需要修改，那么我们必须修改这个类型的源代码。如果使用Comparator方式比较，那么我们不需要修改比较的类，其特点是易维护，但需要自定义一个比较器，后续比较规则的修改，仅仅是改这个比较器中的代码即可。</p>
<h2 id="Comparator和-Comparable的区别："><a href="#Comparator和-Comparable的区别：" class="headerlink" title="Comparator和 Comparable的区别："></a><strong>Comparator和 Comparable的区别：</strong></h2><p>(1)<strong>Comparable定义在Person的内部，特点是高内聚</strong>。但如果哪天这个规则需要修改，那么我们必须修改这个类型的源代码。public class Persion implements Comparable {..比较Person的大小..}，因为已经实现了比较器，那么Person现在是一个可以比较大小的对象了，它的比较功能和String完全一样，可以随时随地的拿来比较大小，因为Person现在自身就是有大小之分的。Collections.sort(personList)可以得到正确的结果。<br>(2)<strong>Comparator是定义在Person的外部的</strong>，使用Comparator方式比较，那么我们不需要修改比较的类，其特点是<strong>易维护</strong>，但需要自定义一个比较器，后续比较规则的修改，仅仅是改这个比较器中的代码即可。此时Person类的结构不需要有任何变化，如public class Person{ String name; int age }，然后另外定义一个比较器：public PersonComparator implements Comparator() {..比较Person的大小..}，在PersonComparator里面实现了怎么比较两个Person的大小。 所以用这种方法，要对一个 personList进行排序的时候除了要传递personList过去，还需要把PersonComparator传递过去，因为怎么比较Person的大小是在PersonComparator里面实现的，如Collections.sort( personList , new PersonComparator() )。</p>
<h1 id="4-final，finally和finalize的区别。"><a href="#4-final，finally和finalize的区别。" class="headerlink" title="4. final，finally和finalize的区别。"></a>4. final，finally和finalize的区别。</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h2><p>1 <strong>修饰符（关键字</strong>） 如果一个类被声明为final ，意味着它不能再派生新的子类， 不能作为父类被继承， 因此一个类不能及被声明为abstract 又被声明为final的。 </p>
<p>2 将变量或方法声明为final， 可以保证他们使用中不被改变。 被声明为final的变量必须在声明时给定初值， 而以后的引用中只能读取 ，不可修改 ，被声明为final的方法也同样只能使用 ，不能重载  。</p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>在异常处理时提供<strong>finally块</strong>来执行清楚操作， 如果抛出一个异常那么相匹配的catch语句就会执行， 然后控制就会进入finally块（ 如果有的话  ）。 </p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>是方法名， java技术允许使用<strong>finalize()方法</strong>在垃圾收集器将对象从内存中清除之前做必要的清理工作 。这个方法是在垃圾收集器在确定了 被清理对象没有被引用的情况下调用的 。 finalize是在Object类中定义的 ，因此 所有的类都继承了它 ，子类可以覆盖finalize()方法 来整理系统资源或者执行其他清理工作。</p>
<h1 id="5-static-nested-class-和inner-class的区别。"><a href="#5-static-nested-class-和inner-class的区别。" class="headerlink" title="5. static nested class 和inner class的区别。"></a>5. static nested class 和inner class的区别。</h1><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《java编程思想》第十章-内部类</p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/wangbaofeng/blog/865998">内部类Inner class和静态嵌套类Static nested class</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0fdea957792">内部类, 静态内部类, 局部类, 匿名内部类的解析和区别</a></p>
<h1 id="6-内部类可以引用包含类（外部类）的成员吗？"><a href="#6-内部类可以引用包含类（外部类）的成员吗？" class="headerlink" title="6. 内部类可以引用包含类（外部类）的成员吗？"></a>6. 内部类可以引用包含类（外部类）的成员吗？</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aademeng/articles/11084885.html">内部类可以引用它的包含类的成员吗？有没有什么限制？</a></p>
<p>静态内部类不可以。如果不是静态内部类，那没有什么限制！ 如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通 成员变 量，而只能访问外部类中的静态成员。</p>
<h1 id="7-java如何进行异常处理，throws，throw，try，catch，finally代表什么意义？在try中可以抛出异常吗？"><a href="#7-java如何进行异常处理，throws，throw，try，catch，finally代表什么意义？在try中可以抛出异常吗？" class="headerlink" title="7. java如何进行异常处理，throws，throw，try，catch，finally代表什么意义？在try中可以抛出异常吗？"></a>7. java如何进行异常处理，throws，throw，try，catch，finally代表什么意义？在try中可以抛出异常吗？</h1><h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。Error 用来指示运行时环境发生的错误。例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p>
<p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2017/09/690102-20160728164909622-1770558953.png" alt="img"></p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p>
<p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p>
<p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p>
<p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcepTest</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">         System.out.println(<span class="string">&quot;Access element three :&quot;</span> + a[<span class="number">3</span>]);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Exception thrown  :&quot;</span> + e);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Out of the block&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line"><span class="comment">Out of the block</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h2><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p>
<p>多重捕获块的语法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码段包含了 3 个 catch块。可以在 try 语句后面添加任意数量的 catch 块。如果保护代码中发生异常，异常被抛给第一个 catch 块。如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。如果不匹配，它会被传递给第二个 catch 块。如此，直到异常被捕获或者通过所有的 catch 块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    x = (<span class="keyword">byte</span>) file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException f) &#123; <span class="comment">// Not valid!</span></span><br><span class="line">    f.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">    i.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h2><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p>下面方法的声明抛出一个 RemoteException 异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException,</span></span><br><span class="line"><span class="function">                              InsufficientFundsException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// Method implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。</p>
<p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p>
<p>finally 代码块出现在 catch 代码块最后，语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcepTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Access element three :&quot;</span> + a[<span class="number">3</span>]);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Exception thrown  :&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">       a[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;First element value: &quot;</span> +a[<span class="number">0</span>]);</span><br><span class="line">       System.out.println(<span class="string">&quot;The finally statement is executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line"><span class="comment">First element value: 6</span></span><br><span class="line"><span class="comment">The finally statement is executed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="注意下面事项："><a href="#注意下面事项：" class="headerlink" title="注意下面事项："></a>注意下面事项：</h3><ul>
<li><strong>catch 不能独立于 try 存在。</strong></li>
<li>在 try/catch 后面添加 finally 块并非强制性要求的。</li>
<li>try 代码后不能既没 catch 块也没 finally 块。</li>
<li>try, catch, finally 块之间不能添加任何代码。</li>
</ul>
<h2 id="在try中可以抛出异常"><a href="#在try中可以抛出异常" class="headerlink" title="在try中可以抛出异常"></a>在try中可以抛出异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//finaly无论如何，总会执行，即使在try-catch中使用了“return”；但是，如果在catch和finaly中，都使用了“return”，那么最终是哪个return值时有意义的？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;try&quot;</span>);  </span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;try&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">try</span></span><br><span class="line"><span class="comment">catch</span></span><br><span class="line"><span class="comment">finally</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>“return”和“exception”都被认为是“方法中断”操作，最后发生者将会生效；当catch中再次抛出异常，原目的是将此异常抛给调用者，结果在finally中使用return(我们认为此处使用return是不当的)，那么异常将会被擦，“return”正常返回。为了避免这种问题，我们可以这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ex = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">try</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.RuntimeException: try</span></span><br><span class="line"><span class="comment">finally</span></span><br><span class="line"><span class="comment">	at test.test0212.ExceptionTest.test02(ExceptionTest.java:33)</span></span><br><span class="line"><span class="comment">	at test.test0212.ExceptionTest.main(ExceptionTest.java:40)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.RuntimeException: try</span></span><br><span class="line"><span class="comment">	at test.test0212.ExceptionTest.test02(ExceptionTest.java:27)</span></span><br><span class="line"><span class="comment">	... 1 more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jpfss/p/9454792.html">JAVA中try-catch异常逃逸</a></p>
<h1 id="8-面向对象的六原则一法则"><a href="#8-面向对象的六原则一法则" class="headerlink" title="8. 面向对象的六原则一法则"></a>8. 面向对象的六原则一法则</h1><p>1、职责单一原则：一个类只做它该做的事。</p>
<blockquote>
<p>单一职责原则想表达的就是”<strong>高内聚</strong>“，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标</p>
</blockquote>
<p>2、开闭原则：软件实体应当对扩展开放，对修改关闭。</p>
<blockquote>
<p>在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。</p>
<p>要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。</p>
</blockquote>
<p>3、依赖倒转原则：面向接口。声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不使用具体类型，因为抽象类型可以被其任意子类所替代。</p>
<p>4、里氏替换原则：任何时候都可以用子类型替换掉父类型。</p>
<blockquote>
<p>关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。</p>
</blockquote>
<p>5、接口隔离原则：接口应该小而专，不应该大而全。</p>
<blockquote>
<p>臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。</p>
</blockquote>
<p>6、合成聚合复用原则：应当多使用聚合或合成关系复用代码。</p>
<blockquote>
<p>通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。</p>
</blockquote>
<p>7、迪米特法则：最少知识原则，一个对象应当对其他对象尽可能少的了解。迪米特法则简单的说就是如何做到”低耦合”</p>
<p><strong>参考资料</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jyroy/p/11367770.html">关于面向对象中的“六原则一法则”</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_26342009/article/details/46419873">面向对象的特征与“六原则一法则”</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3919839.html">设计模式之六大原则（转载）</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/7/">http://muchengxue.github.io/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/fail-fast/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java中的fail-fast机制</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/6/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面向对象</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/6/" title="面向对象"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">面向对象</div></div></a></div><div><a href="/2021/12/18/Java/java%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%9FString/" title="面向对象"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">面向对象</div></div></a></div><div><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Object%E7%B1%BBwait-notify%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" title="Object类wait()底层原理"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">Object类wait()底层原理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Java%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. Java如何通过反射创建对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%8D%E5%B0%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">一、反射是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二、反射的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">三、反射的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%8D%E5%B0%84%E6%B6%89%E5%8F%8A%E7%9A%84API%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">四、反射涉及的API及其使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E6%89%80%E5%B1%9E%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%90%8D%E7%AD%89%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">1:在运行时获取对象所属类的类名等信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%88%9B%E5%BB%BAclass%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">2:通过反射机制创建class对象（三种方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%9A%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E9%80%9A%E8%BF%87%E5%88%9B%E5%BB%BAclass%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%87%AA%E5%B7%B1%E7%9A%84%E7%88%B6%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">3：在运行时，通过创建class对象，获取自己的父类信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%9A%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.4.</span> <span class="toc-text">4：通过反射机制创建一个类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AD%98%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD"><span class="toc-number">1.4.5.</span> <span class="toc-text">5：获取类的全部方法，存于一个数组中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%AD%98%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD"><span class="toc-number">1.4.6.</span> <span class="toc-text">6：获取类的全部字段，存于一个数组中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B1%BB-%E5%AF%B9%E8%B1%A1-%E7%9A%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%EF%BC%88%E5%8C%85%E6%8B%AC%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-number">1.4.7.</span> <span class="toc-text">7：操作类&#x2F;对象 的某个属性（包括私有）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%9A%E8%B0%83%E7%94%A8%E7%B1%BB-%E5%AF%B9%E8%B1%A1-%E7%9A%84%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88%E5%8C%85%E6%8B%AC%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-number">1.4.8.</span> <span class="toc-text">8：调用类&#x2F;对象 的某个方法（包括私有）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.</span> <span class="toc-text">五、代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3Interf-ace%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract-class%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">2. 接口Interf ace和抽象类abstract class的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">一、抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.1.2.</span> <span class="toc-text">继承抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%80%BB%E7%BB%93%E8%A7%84%E5%AE%9A"><span class="toc-number">2.1.4.</span> <span class="toc-text">抽象类总结规定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">二、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9B%B8%E4%BC%BC%E7%82%B9%EF%BC%9A"><span class="toc-number">2.2.2.</span> <span class="toc-text">接口与类相似点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.2.3.</span> <span class="toc-text">接口与类的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.4.</span> <span class="toc-text">接口特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.5.</span> <span class="toc-text">接口的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.6.</span> <span class="toc-text">接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.7.</span> <span class="toc-text">接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.8.</span> <span class="toc-text">接口的多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.9.</span> <span class="toc-text">标记接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF-1"><span class="toc-number">2.2.10.</span> <span class="toc-text">接口的多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">2.2.11.</span> <span class="toc-text">标记接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">三、抽象类和接口的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.1.</span> <span class="toc-text">1、语法层面上的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AE%BE%E8%AE%A1%E5%B1%82%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.2.</span> <span class="toc-text">2、设计层面上的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.3.</span> <span class="toc-text">3、什么时候使用抽象类和接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%82%E8%80%83"><span class="toc-number">2.4.</span> <span class="toc-text">四、参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Comparable%E5%92%8CComparator%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. Comparable和Comparator接口是干嘛的，区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-lang-Comparable%E5%85%A8%E9%83%A8%E6%BA%90%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">java.lang.Comparable全部源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparable%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">Comparable使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-util-Comparator%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">java.util.Comparator使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E4%B8%80%E8%B5%B7%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="toc-number">3.4.</span> <span class="toc-text">两种方法一起代码测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparator%E5%92%8C-Comparable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">3.5.</span> <span class="toc-text">Comparator和 Comparable的区别：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-final%EF%BC%8Cfinally%E5%92%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">4. final，finally和finalize的区别。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">4.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally"><span class="toc-number">4.2.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize"><span class="toc-number">4.3.</span> <span class="toc-text">finalize</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-static-nested-class-%E5%92%8Cinner-class%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">5. static nested class 和inner class的区别。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D"><span class="toc-number">5.1.</span> <span class="toc-text">参考书籍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%8C%85%E5%90%AB%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%EF%BC%89%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6. 内部类可以引用包含类（外部类）的成员吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-java%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%8Cthrows%EF%BC%8Cthrow%EF%BC%8Ctry%EF%BC%8Ccatch%EF%BC%8Cfinally%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F%E5%9C%A8try%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">7. java如何进行异常处理，throws，throw，try，catch，finally代表什么意义？在try中可以抛出异常吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception-%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">7.1.</span> <span class="toc-text">Exception 类的层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">7.2.</span> <span class="toc-text">捕获异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E6%8D%95%E8%8E%B7%E5%9D%97"><span class="toc-number">7.3.</span> <span class="toc-text">多重捕获块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throws-throw-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">7.4.</span> <span class="toc-text">throws&#x2F;throw 关键字：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.5.</span> <span class="toc-text">finally关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%B8%8B%E9%9D%A2%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">7.5.1.</span> <span class="toc-text">注意下面事项：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8try%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">7.6.</span> <span class="toc-text">在try中可以抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.7.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%8E%9F%E5%88%99%E4%B8%80%E6%B3%95%E5%88%99"><span class="toc-number">8.</span> <span class="toc-text">8. 面向对象的六原则一法则</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS的设计思路"/></a><div class="content"><a class="title" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路">AQS的设计思路</a><time datetime="2022-02-03T13:10:28.437Z" title="发表于 2022-02-03 13:10:28">2022-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="float的范围和精度"/></a><div class="content"><a class="title" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度">float的范围和精度</a><time datetime="2022-01-21T14:18:25.869Z" title="发表于 2022-01-21 14:18:25">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="随想1"/></a><div class="content"><a class="title" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1">随想1</a><time datetime="2021-12-18T16:15:22.363Z" title="发表于 2021-12-18 16:15:22">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 吊打面试官"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官">Redis 吊打面试官</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis中的事务"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务">Redis中的事务</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>