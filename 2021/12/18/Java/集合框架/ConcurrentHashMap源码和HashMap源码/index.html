<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>集合 | 暮成雪的博客</title><meta name="keywords" content="集合"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0. 集合类博客大神博客 一、读HashMap源码  初窥HashMapJava集合类的源码是深入学习Java非常好的素材，源码里很多优雅的写法和思路，会让人叹为观止。HashMap的源码尤为经典，是非常值得去深入研究的。HashMap是应用更广泛的哈希表HashTable实现，而且大部分情况下，都能在常数时间性能的情况下进行put和get操作。要掌握HashMap，主要从如下几点来把握：  jd">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%92%8CHashMap%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="0. 集合类博客大神博客 一、读HashMap源码  初窥HashMapJava集合类的源码是深入学习Java非常好的素材，源码里很多优雅的写法和思路，会让人叹为观止。HashMap的源码尤为经典，是非常值得去深入研究的。HashMap是应用更广泛的哈希表HashTable实现，而且大部分情况下，都能在常数时间性能的情况下进行put和get操作。要掌握HashMap，主要从如下几点来把握：  jd">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:43.640Z">
<meta property="article:modified_time" content="2020-03-18T15:33:04.000Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%92%8CHashMap%E6%BA%90%E7%A0%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '集合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-03-18 15:33:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-video"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-video"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-video"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-video"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:43.640Z" title="发表于 2021-12-18 14:42:43">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-03-18T15:33:04.000Z" title="更新于 2020-03-18 15:33:04">2020-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE%E9%83%A8%E5%88%86/">JavaSE部分</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>153分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="集合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%92%8CHashMap%E6%BA%90%E7%A0%81/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%92%8CHashMap%E6%BA%90%E7%A0%81/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-集合类博客"><a href="#0-集合类博客" class="headerlink" title="0. 集合类博客"></a>0. 集合类博客</h1><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011392897/article/details/60479937">大神博客</a></strong></p>
<h1 id="一、读HashMap源码"><a href="#一、读HashMap源码" class="headerlink" title="一、读HashMap源码"></a>一、读HashMap源码</h1><p><img src="C:\Users\Administrator\Desktop\面试题总结\集合框架\hashmap_1.png"></p>
<p><img src="https://img-blog.csdn.net/20170303220106829?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h2 id="初窥HashMap"><a href="#初窥HashMap" class="headerlink" title="初窥HashMap"></a>初窥HashMap</h2><p>Java集合类的源码是深入学习Java非常好的素材，<strong>源码里很多优雅的写法和思路</strong>，会让人<strong>叹为观止</strong>。HashMap的源码尤为<strong>经典</strong>，是非常值得去深入研究的。HashMap是应用更广泛的哈希表HashTable实现，而且大部分情况下，都能在<strong>常数时间性能的情况下进行put和get</strong>操作。要掌握HashMap，主要从如下几点来<u>把握</u>：</p>
<ul>
<li>jdk1.7中底层是由数组（也有叫做“位桶”的）+链表实现；<strong>jdk1.8中底层</strong>是由<strong>数组(位桶)+链表/红黑树</strong>实现</li>
<li>可以存储<strong>null键和null值，线程不安全</strong></li>
<li>初始size为<strong>16</strong>，扩容：<strong>newsize = oldsize*2</strong>，size一定为<strong>2的n次幂</strong></li>
<li><strong>扩容针对整个Map</strong>，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入</li>
<li>插入元素后才判断该不该扩容，有可能<strong>无效扩容</strong>（插入后如果扩容，如果没有再次插入，就会产生无效扩容）</li>
<li>当Map中元素总数超过Entry数组的**75%**，触发扩容操作，为了减少链表长度，元素分配更均匀</li>
<li>1.7中是<strong>先扩容后插入</strong>新值的，1.8中是<strong>先插值再扩容</strong></li>
</ul>
<p>为什么说HashMap是线程不安全的？在接近临界点时，若此时两个或者多个线程进行put操作，都会进行resize（扩容）和reHash（为key重新计算所在位置），而reHash在并发的情况下可能会形成<strong>链表环</strong>。总结来说就是在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。为什么在并发执行put操作会引起死循环？是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。jdk1.7的情况下，并发扩容时容易形成链表环，此情况在1.8时就好太多太多了。因为在1.8中当链表长度大于阈值（默认长度为8）时，链表会被改成树形（红黑树）结构。</p>
<h2 id="jdk1-8中HashMap的实现"><a href="#jdk1-8中HashMap的实现" class="headerlink" title="jdk1.8中HashMap的实现"></a>jdk1.8中HashMap的实现</h2><p>在jdk1.8中HashMap的内部结构可以看作是<strong>数组(Node&lt;K,V&gt;[] table)和链表/红黑树</strong>的复合结构，数组被分为一个个<strong>桶（bucket）</strong>，通过哈希值决定了<strong>键值</strong>对在这个数组中的<strong>寻址</strong>（<strong>哈希值相同的键值对，则以链表形式存储</strong>）。有一点需要注意，如果链表大小超过<strong>阈值（TREEIFY_THRESHOLD,8）</strong>，图中的链表就会被改造为树形（<strong>红黑树</strong>）结构。Entry的名字变成了Node，原因是和红黑树的实现TreeNode相关联。<strong>1.8与1.7最大的不同就是利用了红黑树，即由数组+链表（或红黑树）组成。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>如果说成百上千个节点在<strong>hash时发生碰撞</strong>，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费<strong>O(N)的查找时间</strong>，这将是多么大的性能损失。这个问题终于在JDK1.8中得到了解决，在最坏的情况下，<strong>链表查找的时间复杂度为O(n),而红黑树一直是O(logn)</strong>,这样会提高HashMap的效率。</p>
<p>jdk1.7中HashMap采用的是位桶+链表的方式，即我们常说的<strong>散列链表</strong>的方式，而jdk1.8中采用的是<strong>位桶+链表/红黑树</strong>的方式，也是<strong>非线程安全</strong>的。HashMap根据链地址法（<code>拉链法</code>）来解决冲突，<strong>在jdk1.8中，如果<code>链表长度大于8且节点数组长度大于64的时候</code>，就把链表下所有的节点转为红黑树</strong>。</p>
<h3 id="HashMap成员定义"><a href="#HashMap成员定义" class="headerlink" title="HashMap成员定义"></a>HashMap成员定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     0.75这个值成为负载因子，那么为什么负载因子为0.75呢？这是通过大量实验统计得出来的，如果过小，比如0.5，那么当存放的元素超过一半时就进行扩容，会造成资源的浪费；如果过大，比如1，那么当元素满的时候才进行扩容，会使get,put操作的碰撞几率增加。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tableSizeFor方法"><a href="#tableSizeFor方法" class="headerlink" title="tableSizeFor方法"></a>tableSizeFor方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> 返回大于等于cap的第一个为2的n次幂的整数，n&gt;=0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>h是hashcode。h &gt;&gt;&gt; 16是用来<strong>取出h的高16</strong>，(&gt;&gt;&gt;是无符号右移)  如下展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0100</span> <span class="number">1011</span> <span class="number">0011</span>  <span class="number">1101</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">0001</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">16</span> </span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0100</span> <span class="number">1011</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure>

<p>由于和（length-1）运算，length 绝大多数情况小于2的16次方（实际上static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30），所以始终是hashcode 的低16位（甚至更低）参与运算。因为有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。要是高16位也参与运算，会让hash更具有特异性，也会让得到的<strong>下标更加散列</strong>。所以才有hash(Object key)方法，让他的hashCode()和自己的高16位^运算。</p>
<p>**为什么用^而不用&amp;和|**：因为&amp;和|都会使得结果偏向0或者1 ,并不是均匀的概念,所以用^。这就是为什么有hash(Object key)的原因。</p>
<h4 id="为什么容量是2的n次幂"><a href="#为什么容量是2的n次幂" class="headerlink" title="为什么容量是2的n次幂"></a>为什么容量是2的n次幂</h4><p>讲到这里还要看一个方法indexFor，在**jdk1.7中有indexFor(int h, int length)<strong>方法。jdk1.8里没有，但原理没变，jdk1.8中用</strong>tab[(n - 1) &amp; hash]**代替但原理一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法返回值就是数组下标。HashMap的底层数组长度总是2的n次方，在resize函数中存在：<code>newCap = oldCap &lt;&lt; 1;</code>这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，<strong>h&amp;(length - 1)就相当于对length取模，而且速度比直接取模</strong>快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。</p>
<p>我们回到indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：<strong>均匀分布table数据和充分利用空间</strong>。这里我们假设length为16(2^n)和15，h为5、6、7。(这里的h表示的根据key算的hash值，这个indexFor方法是要在数组上给当前数据找个落脚点也就是数组下标，好存放当前数据。)</p>
<p><img src="http://images.cnitblog.com/blog/381060/201401/152128360645.jpg" alt="img"></p>
<p>当length=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是<strong>产生了碰撞</strong>，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201401/152128371892.jpg" alt="img"></p>
<p>从上面的图表中我们看到总共发生了8次碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。</p>
<p>总结来说，如果map长度为2的幂次，那长度-1的二进制一定为11111…这种形式，进行与运算就看元素的hashcode，但是如果map的长度不是2的幂次，比如为15，那长度-1就是14，二进制为1110，无论与谁相与最后一位一定是0，0001，0011，0101，1001，1011，0111，1101这几个位置就永远都不能存放元素了，空间浪费相当大。也增加了添加元素是发生碰撞的机会。减慢了查询效率。所以Hashmap的大小是2的幂次。</p>
<p><strong>所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。</strong></p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p><img src="https://img-blog.csdnimg.cn/20190213134627729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MDkzNDY1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>通过分析put方法的源码，可以让这种区别更直观：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; </span><br><span class="line">        <span class="keyword">int</span> n, i;<span class="comment">// n表示tab的size; i = (n - 1) &amp; hash表示即将把值Node(key,value)put到table[]的index处</span></span><br><span class="line">        <span class="comment">// 1 如果tab为空或者长度为0时,就初始化table(初始长度为16),并将长度值赋给n</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//2 要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上即可</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//  进入此else的代码块,则表示tab对应index必定已存在Node对象</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;<span class="comment">//3 如果index元素的key与要插入的一样，那么就把这个位置的引用保存，看onlyIfAbsent再做处理。</span></span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//4 如果当前节点是TreeNode类型的数据，执行putTreeVal方法。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//此方法内部会遍历红黑树,如果已存在则返回被覆盖的Node,否则返回null</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 5 当为链表时</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 循环遍历链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//6 当p.next为空时 说明到了链表末尾</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// 则newNode方法新建一个Node对象赋值给p.next</span></span><br><span class="line">                        <span class="comment">// 7 当链表达到一定长度(默认8)后,调用treeifyBin方法转换成红黑树的结构</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">// 当遍历到p.next为空时 到了链表末尾 则表示找到了可以放置put进来的key-value的地方,所以要结束链表遍历</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 8 当p.next不为空时,并且hash值和传入的hash值相等,key值也相等时,则记录找到的已存在的节点,结束循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key  //9 此处是真正执行覆盖操作的地方</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// onlyIfAbsent值为false的时候表示直接覆盖已存在的key的value值,</span></span><br><span class="line">                <span class="comment">//为true时oldValue为null则才会覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);<span class="comment">//afterNodeAccess此方法下面没有代码 所以无实际意义</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;<span class="comment">// 这个地方可以看出 当我们put重复的key-value时  会返回被覆盖的oldValue,虽然我们一般不关心put时候的返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;<span class="comment">//modCount是统计map被修改次数的</span></span><br><span class="line">        <span class="comment">//10 当tab的size大于阈值的时候则需要调用resize方法进行扩容。先插入再扩容坑你会出现无效扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);<span class="comment">//无意义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//当put的时候不存在覆盖值的时候则返回null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="treeifyBin方法"><a href="#treeifyBin方法" class="headerlink" title="treeifyBin方法"></a>treeifyBin方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">   * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   将链表节点转为红黑树节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">//1 树形化还有一个要求就是数组长度必须大于等于64，否则继续采用扩容策略</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<span class="comment">//64</span></span><br><span class="line">          resize();<span class="comment">//********bincount&gt;=7但是tab.length&lt;64时并不转为红黑树，而是扩容double</span></span><br><span class="line">       <span class="comment">// 2.根据hash值计算索引值，将该索引位置的节点赋值给e，从e开始遍历该索引位置的链表</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;<span class="comment">//hd指向首节点，tl指向尾节点</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);<span class="comment">//3 将链表节点转化为红黑树节点</span></span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)<span class="comment">// 4 如果尾节点为空，说明还没有首节点</span></span><br><span class="line">                  hd = p;<span class="comment">// 当前节点作为首节点</span></span><br><span class="line">              <span class="keyword">else</span> &#123; <span class="comment">//5.如果不是第一次遍历,尾节点不为空，构造一个双向链表结构，将当前节点追加到双向链表的末尾</span></span><br><span class="line">                  p.prev = tl;<span class="comment">// 当前树节点的前一个节点指向尾节点</span></span><br><span class="line">                  tl.next = p;<span class="comment">// 尾节点的后一个节点指向当前节点</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//6 将p节点赋值给tl，用于在下一次循环中作为上一个节点进行一些链表的关联操作（p.prev = tl 和 tl.next = p）</span></span><br><span class="line">              tl = p; <span class="comment">// 把当前节点设为尾节点</span></span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);<span class="comment">// 继续遍历单链表</span></span><br><span class="line">          <span class="comment">//7 将table该索引位置赋值为新转的TreeNode的头节点，如果该节点不为空，则以以头节点(hd)为根节点, 构建红黑树</span></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)<span class="comment">//将原本的单链表转化为一个节点类型为TreeNode的双向链表</span></span><br><span class="line">              hd.treeify(tab);<span class="comment">// 将当前双向链表树形化</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="treeify方法"><a href="#treeify方法" class="headerlink" title="treeify方法"></a>treeify方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">       将双向链表转化为红黑树的实现：</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">      TreeNode&lt;K,V&gt; left;</span><br><span class="line">      TreeNode&lt;K,V&gt; right;</span><br><span class="line">      TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">      <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>; <span class="comment">// 定义红黑树的根节点</span></span><br><span class="line">          <span class="comment">// 1 从TreeNode双向链表的头节点开始逐个遍历</span></span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">              next = (TreeNode&lt;K,V&gt;)x.next;<span class="comment">// 头节点的后继节点</span></span><br><span class="line">              x.left = x.right = <span class="keyword">null</span>; <span class="comment">// 将x的左右节点设置为空</span></span><br><span class="line">              <span class="comment">// 2.如果还没有根节点, 则将x设置为根节点</span></span><br><span class="line">              <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  x.parent = <span class="keyword">null</span>;</span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  root = x;<span class="comment">// 头节点作为红黑树的根，设置为黑色</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123; <span class="comment">// 3 红黑树存在根节点，遍历找到位置</span></span><br><span class="line">                  K k = x.key;</span><br><span class="line">                  <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                  Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;<span class="comment">// 从根开始遍历整个红黑树</span></span><br><span class="line">                      <span class="keyword">int</span> dir, ph;</span><br><span class="line">                      K pk = p.key;</span><br><span class="line">                      <span class="comment">// 4.如果x节点的hash值小于p节点的hash值，则将dir赋值为-1, 代表向p的左边查找</span></span><br><span class="line">                      <span class="keyword">if</span> ((ph = p.hash) &gt; h)<span class="comment">// 当前红黑树节点p的hash值大于双向链表节点x的哈希值</span></span><br><span class="line">                          dir = -<span class="number">1</span>;</span><br><span class="line">                      <span class="comment">// 5.如果x节点的hash值大于p节点的hash值，则将dir赋值为1, 代表向p的右边查找</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)<span class="comment">// 当前红黑树节点p的hash值小于双向链表节点x的哈希值</span></span><br><span class="line">                          dir = <span class="number">1</span>;</span><br><span class="line">                      <span class="comment">// 6 当前红黑树节点的hash值等于双向链表节点x的哈希值，则如果key值采用比较器一致则比较key值</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                               (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                          <span class="comment">// 6.1 如果key值也一致则比较className和identityHashCode 使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右查找</span></span><br><span class="line">                          dir = tieBreakOrder(k, pk);</span><br><span class="line">                      TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                       <span class="comment">// 7.dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置  如果当前红黑树节点p是叶子节点，那么双向链表节点x就找到了插入的位置</span></span><br><span class="line">                      <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          <span class="comment">// 8.x和xp节点的属性设置</span></span><br><span class="line">                          x.parent = xp;<span class="comment">// x的父节点即为最后一次遍历的p节点</span></span><br><span class="line">                          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)<span class="comment">//如果时dir &lt;= 0, 则代表x节点为父节点的左节点</span></span><br><span class="line">                              xp.left = x;</span><br><span class="line">                          <span class="keyword">else</span><span class="comment">// 如果时dir &gt; 0, 则代表x节点为父节点的右节点</span></span><br><span class="line">                              xp.right = x;</span><br><span class="line">                          <span class="comment">// // 9.进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求)</span></span><br><span class="line">                          root = balanceInsertion(root, x);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 10.如果root节点不在table索引位置的头节点, 则将其调整为头节点</span></span><br><span class="line">          <span class="comment">//将TreeNode双向链表转化为红黑树结构之后，由于红黑树是基于根节点进行查找，所以必须将红黑树的根节点作为数组当前位置的元素</span></span><br><span class="line">          moveRootToFront(tab, root);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Tree version of putVal.</span></span><br><span class="line"><span class="comment">       红黑树的put操作，红黑树插入会同时维护原来的链表属性, 即原来的next属性</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">          Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 1.查找根节点, 索引位置的头节点并不一定为红黑树的根节点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">          <span class="comment">// 2.将根节点赋值给p节点，开始进行查找</span></span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">              <span class="comment">// 3.如果传入的hash值小于p节点的hash值，将dir赋值为-1，代表向p的左边查找树</span></span><br><span class="line">              <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                  dir = -<span class="number">1</span>;</span><br><span class="line">              <span class="comment">// 4.如果传入的hash值大于p节点的hash值， 将dir赋值为1，代表向p的右边查找树</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                  dir = <span class="number">1</span>;</span><br><span class="line">              <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值, 则p节点即为目标节点, 返回p节</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                  <span class="keyword">return</span> p;</span><br><span class="line">               <span class="comment">// 6.如果k所属的类没有实现Comparable接口 或者 k和p节点的key相等</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                       (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 6.1 第一次符合条件, 从p节点的左节点和右节点分别调用find方法进行查找, 如果查找到目标节点则返回</span></span><br><span class="line">                  <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                      searched = <span class="keyword">true</span>;</span><br><span class="line">                      <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                           (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                          ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                           (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                          <span class="keyword">return</span> q;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 6.2 否则使用定义的一套规则来比较k和p节点的key的大小, 用来决定向左还是向右查找</span></span><br><span class="line">                  dir = tieBreakOrder(k, pk);<span class="comment">// dir&lt;0则代表k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              TreeNode&lt;K,V&gt; xp = p;<span class="comment">// xp赋值为x的父节点,中间变量,用于下面给x的父节点赋值</span></span><br><span class="line">     			<span class="comment">// 7.dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">              <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 走进来代表已经找到x的位置，只需将x放到该位置即可</span></span><br><span class="line">                  Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                  <span class="comment">// 8.创建新的节点, 其中x的next节点为xpn, 即将x节点插入xp与xpn之间</span></span><br><span class="line">                  TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                  <span class="comment">// 9.调整x、xp、xpn之间的属性关系</span></span><br><span class="line">                  <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                      xp.left = x;<span class="comment">// 如果时dir &lt;= 0, 则代表x节点为xp的左节点</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="comment">// 如果时dir&gt; 0, 则代表x节点为xp的右节点</span></span><br><span class="line">                      xp.right = x;</span><br><span class="line">                  xp.next = x;<span class="comment">// 将xp的next节点设置为x</span></span><br><span class="line">                  x.parent = x.prev = xp; <span class="comment">// 将x的parent和prev节点设置为xp</span></span><br><span class="line">                  <span class="comment">// 如果xpn不为空,则将xpn的prev节点设置为x节点,与上文的x节点的next节点对应</span></span><br><span class="line">                  <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                  <span class="comment">// 10.进行红黑树的插入平衡调整</span></span><br><span class="line">                  moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment">       * hashCodes and non-comparable. We don&#x27;t require a total</span></span><br><span class="line"><span class="comment">       * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment">       * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment">       * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment">       用于不可比较或者hashCode相同时进行比较的方法, 只是一个一致的插入规则，用来维护重定位的等价性。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> d;</span><br><span class="line">          <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">              (d = a.getClass().getName().</span><br><span class="line">               compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">              d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                   -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> d;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="untreeify"><a href="#untreeify" class="headerlink" title="untreeify"></a>untreeify</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 将红黑树节点转为链表节点, 当节点&lt;=6个时会被触发 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;    </span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">// hd指向头节点, tl指向尾节点    </span></span><br><span class="line">    <span class="comment">// 1.从调用该方法的节点, 即链表的头节点开始遍历, 将所有节点全转为链表节点    </span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;        </span><br><span class="line">        <span class="comment">// 2.调用replacementNode方法构建链表节点        </span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);        </span><br><span class="line">        <span class="comment">// 3.如果tl为null, 则代表当前节点为第一个节点, 将hd赋值为该节点        </span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)            </span><br><span class="line">            hd = p;        </span><br><span class="line">        <span class="comment">// 4.否则, 将尾节点的next属性设置为当前节点p        </span></span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            tl.next = p;        </span><br><span class="line">        tl = p; </span><br><span class="line">        <span class="comment">// 5.每次都将tl节点指向当前节点, 即尾节点    </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 6.返回转换后的链表的头节点    </span></span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="moveRootToFront"><a href="#moveRootToFront" class="headerlink" title="moveRootToFront"></a>moveRootToFront</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将root放到头节点的位置</span></span><br><span class="line"><span class="comment"> * 如果当前索引位置的头节点不是root节点, 则将root的上一个节点和下一个节点进行关联,</span></span><br><span class="line"><span class="comment"> * 将root放到头节点的位置, 原头节点放在root的next节点上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 1.校验root是否为空、table是否为空、table的length是否大于0</span></span><br><span class="line">     <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash; <span class="comment">//2 找到红黑树根节点在数组中的位置</span></span><br><span class="line">         TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; <span class="comment">//获取当前数组中该位置的元素</span></span><br><span class="line">         <span class="comment">// 3.如果该索引位置的头节点不是root节点，则该索引位置的头节点替换为root节点</span></span><br><span class="line">         <span class="keyword">if</span> (root != first) &#123; </span><br><span class="line">             Node&lt;K,V&gt; rn;</span><br><span class="line">             <span class="comment">// 3.1 将该索引位置的头节点赋值为root节点</span></span><br><span class="line">             tab[index] = root;</span><br><span class="line">             TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">             <span class="comment">// 3.2 和 3.3 两个操作是移除root节点的过程</span></span><br><span class="line">            <span class="comment">// 3.2 如果root节点的next节点不为空，则将root节点的next节点的prev属性设置为root节点的prev节点</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) <span class="comment">//将红黑树根节点前后节点相连</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="comment">// 3.3 如果root节点的prev节点不为空，则将root节点的prev节点的next属性设置为root节点的next节点</span></span><br><span class="line">             <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">             <span class="comment">// 3.4 和 3.5 两个操作将first节点接到root节点后面</span></span><br><span class="line">            <span class="comment">// 3.4 如果原头节点不为空, 则将原头节点的prev属性设置为root节点</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">//将数组当前位置的元素，作为红黑树根节点的后继节点</span></span><br><span class="line">                first.prev = root;</span><br><span class="line">             <span class="comment">// 3.5 将root节点的next属性设置为原头节点</span></span><br><span class="line">            root.next = first;</span><br><span class="line">             <span class="comment">// 3.6 root此时已经被放到该位置的头节点位置，因此将prev属性设为空</span></span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.检查树是否正常</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果Node&lt;K,V&gt;[] table是null，resize方法会负责初始化，即如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></li>
<li><p>resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。<br>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure>

<ul>
<li>具体键值对在哈希表中的位置（数组index）取决于下面的位运算：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>





<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;<span class="comment">// 1 当tab不为空并且长度不为0的情况下</span></span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//    并且通过hash值和长度-1的位运算计算出的table[index]不为空</span></span><br><span class="line">             <span class="comment">// 2 check匹配上的index处的节点,比较key值是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;<span class="comment">//相等则直接返回节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;<span class="comment">//3 当第一个节点匹配不上则就说明是链表或者红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//4 当节点元素为红黑树的时候</span></span><br><span class="line">                    <span class="comment">//红黑树TreeNode内部匹配结果</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e; <span class="comment">//5 当为链表的时候则使用next指针遍历整个链表直到匹配上或者遍历完</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);<span class="comment">//当下一个节点不为空时,继续比较key值是否匹配(执行do&#123;&#125;代码块)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.找不到符合的返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 1.首先找到红黑树的根节点；2.使用根节点调用find方法    </span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 从调用此方法的节点开始查找, 通过hash值和key找到对应的节点 </span></span><br><span class="line"><span class="comment">* 此方法是红黑树节点的查找, 红黑树是特殊的自平衡二叉查找树 </span></span><br><span class="line"><span class="comment">* 平衡二叉查找树的特点：左节点&lt;根节点&lt;右节点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 1.将p节点赋值为调用此方法的节点，即为红黑树根节点    </span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;    </span><br><span class="line">    <span class="comment">// 2.从p节点开始向下遍历    </span></span><br><span class="line">    <span class="keyword">do</span> &#123;        </span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;        </span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;        </span><br><span class="line">        <span class="comment">// 3.如果传入的hash值小于p节点的hash值，则往p节点的左边遍历        </span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)            </span><br><span class="line">            p = pl;        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) </span><br><span class="line">            <span class="comment">// 4.如果传入的hash值大于p节点的hash值，则往p节点的右边遍历            </span></span><br><span class="line">            p = pr;        </span><br><span class="line">        <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值,则p节点为目标节点,返回p节点        </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))            </span><br><span class="line">            <span class="keyword">return</span> p;        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)    </span><br><span class="line">            <span class="comment">// 6.p节点的左节点为空则将向右遍历            </span></span><br><span class="line">            p = pr;        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)    </span><br><span class="line">            <span class="comment">// 7.p节点的右节点为空则向左遍历            </span></span><br><span class="line">            p = pl;        </span><br><span class="line">        <span class="comment">// 8.将p节点与k进行比较        </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> || (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;                </span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) </span><br><span class="line">            <span class="comment">// 8.1 kc不为空代表k实现了Comparable </span></span><br><span class="line">            <span class="comment">// 8.2 k&lt;pk则dir&lt;0, k&gt;pk则dir&gt;0            </span></span><br><span class="line">            <span class="comment">// 8.3 k&lt;pk则向左遍历(p赋值为p的左节点), 否则向右遍历            </span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;        </span><br><span class="line">        <span class="comment">// 9.代码走到此处, 代表key所属类没有实现Comparable, 直接指定向p的右边遍历        </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)             </span><br><span class="line">            <span class="keyword">return</span> q;        </span><br><span class="line">        <span class="comment">// 10.代码走到此处代表“pr.find(h, k, kc)”为空, 因此直接向左遍历        </span></span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            p = pl;    </span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将 p 节点与 k 进行比较。如果传入的 key（即代码中的参数 k）所属的类实现了 Comparable 接口（kc 不为空，comparableClassFor 方法见代码块3详解），则将 k 跟 p 节点的 key 进行比较（kc 实现了 Comparable 接口，因此通过 kc 的比较方法进行比较），并将比较结果赋值给 dir，如果 dir&lt;0 则代表 k&lt;pk，则向 p 节点的左边遍历（pl）；否则，向 p 节点的右边遍历（pr）。//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;    </span><br><span class="line">    <span class="comment">// 1.判断x是否实现了Comparable接口    </span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;        </span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;        </span><br><span class="line">        <span class="comment">// 2.校验x是否为String类型        </span></span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks            </span></span><br><span class="line">            <span class="keyword">return</span> c;        </span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="comment">// 3.遍历x实现的所有接口            </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;                </span><br><span class="line">                <span class="comment">// 4.如果x实现了Comparable接口，则返回x的Class                </span></span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp; as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c </span></span><br><span class="line">                    <span class="keyword">return</span> c;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">     <span class="comment">// 1.如果table不为空并且根据hash值计算出来的索引位置不为空, 将该位置的节点赋值给p</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 2.如果p的hash值和key都与入参的相同, 则p即为目标节点, 赋值给node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 3.否则将p.next赋值给e，向下遍历节点</span></span><br><span class="line">            <span class="comment">// 3.1 如果p是TreeNode则调用红黑树的方法查找节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 3.2 否则，进行普通链表节点的查找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;<span class="comment">// 当节点的hash值和key与传入的相同,则该节点即为目标节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;<span class="comment">// 赋值给node, 并跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">// p节点赋值为本次结束的e，在下一次循环中，e为p的next节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.如果node不为空(即根据传入key和hash值查找到目标节点)，则进行移除操作</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 4.1 如果是TreeNode则调用红黑树的移除方法</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 4.2 如果node是该索引位置的头节点则直接将该索引位置的值赋值为node的next节点，</span></span><br><span class="line">            <span class="comment">// “node == p”只会出现在node是头节点的时候，如果node不是头节点，则node为p的next节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">// 4.3 否则将node的上一个节点的next属性设置为node的next节点, 即将node节点移除, 将node的上下节点进行关联(链表的移除)</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">// 5.返回被移除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment">     * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment">     * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment">     * successor that is pinned by &quot;next&quot; pointers that are accessible</span></span><br><span class="line"><span class="comment">     * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment">     * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment">     * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment">     * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --- 链表的处理start ---</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 1.table为空或者length为0直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;<span class="comment">// 2.根据hash计算出索引的位置</span></span><br><span class="line">        <span class="comment">// 3.将索引位置的头节点赋值给first和root</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">        <span class="comment">// 4.该方法被将要被移除的node(TreeNode)调用, 因此此方法的this为要被移除node节点,</span></span><br><span class="line">        <span class="comment">// 将node的next节点赋值给succ节点，prev节点赋值给pred节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">        <span class="comment">// 5.如果pred节点为空，则代表要被移除的node节点为头节点，</span></span><br><span class="line">		<span class="comment">// 则将table索引位置的值和first节点的值赋值为succ节点(node的next节点)即可</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            tab[index] = first = succ;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 6.否则将pred节点的next属性设置为succ节点(node的next节点)</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">        <span class="comment">// 7.如果succ节点不为空，则将succ的prev节点设置为pred, 与前面对应</span></span><br><span class="line">        <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        <span class="comment">// 8.如果进行到此first节点为空，则代表该索引位置已经没有节点则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) <span class="comment">// 只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 9.如果root的父节点不为空, 则将root赋值为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">            root = root.root();</span><br><span class="line">        <span class="comment">// 10.通过root节点来判断此红黑树是否太小, 如果是则调用untreeify方法转为链表节点并返回</span></span><br><span class="line"> 		<span class="comment">// (转链表后就无需再进行下面的红黑树处理)</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">            || (movable</span><br><span class="line">                &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                    || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                    || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">            tab[index] = first.untreeify(map);  <span class="comment">// too small节点数目太少，恢复为普通的链表，因为已经在双向链表中删除了节点，所以不必再操作了，可以直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// --- 链表的处理end ---</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// --- 以下代码为红黑树的处理 ---</span></span><br><span class="line">        <span class="comment">// 11.将p赋值为要被移除的node节点，pl赋值为p的左节点，pr赋值为p 的右节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">        <span class="comment">// replacement表示以节点为中心进行红黑树再调整，当p不是叶子节点是这也是p的实际继任节点        			// 下面的代码跟普通的二叉搜索树删除操作类似        </span></span><br><span class="line">        <span class="comment">// 普通二叉搜索树删除节点有三种情况，画了个图，在后面        </span></span><br><span class="line">        <span class="comment">// 1、p没有子树，直接删除就行        </span></span><br><span class="line">        <span class="comment">// 2、p只有左子树或者右子树，用p的左子树或者右子树“替换”（p.parent.left/right = p.left/right）它。        </span></span><br><span class="line">        <span class="comment">// 3、p 有非空的左右子树，把 p和s进行“内容替换”（互相交换各自的所有属性，然后引用交换），然后退化为情况1或者情况2再处理一次。这跟指针处理是一样的。        </span></span><br><span class="line">        <span class="comment">// 先保证二叉搜索树的性质，在进行红黑树平衡调整保证是正确的红黑树</span></span><br><span class="line">        <span class="comment">// 12.如果p的左节点和右节点都不为空时</span></span><br><span class="line">        <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;<span class="comment">// 情况3</span></span><br><span class="line">            <span class="comment">// 12.1 将s节点赋值为p的右节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">            <span class="comment">// 12.2 向左一直查找，跳出循环时,s为没有左节点的节点</span></span><br><span class="line">            <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor根据二叉搜索树的性质在右子树中寻找最“左”边的一个，也是不小于要删除的节点的最小节点，当做当前节点的实际继任节点</span></span><br><span class="line">                s = sl;</span><br><span class="line">             <span class="comment">// 12.3 交换p节点和s节点的颜色</span></span><br><span class="line">            <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors 交换颜色，保证其他部分是正确红黑树，不用调整</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sr = s.right;<span class="comment">// s的右节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">             <span class="comment">// --- 第一次调整和第二次调整：将p节点和s节点进行了位置调换 ---</span></span><br><span class="line">    		<span class="comment">// 12.4 第一次调整</span></span><br><span class="line">    		<span class="comment">// 如果p节点的右节点即为s节点，则将p的父节点赋值为s，将s的右节点赋值为p</span></span><br><span class="line">            <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果s节点为sp的左节点，则将sp的左节点赋值为p节点</span></span><br><span class="line">                    <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                        sp.left = p;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">// 否则s节点为sp的右节点，则将sp的右节点赋值为p节点</span></span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// s的右节点赋值为p节点的右节点</span></span><br><span class="line">                <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                    pr.parent = s;<span class="comment">// 如果pr不为空，则将pr的父节点赋值为s</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 12.5 第二次调整</span></span><br><span class="line">            <span class="comment">// 将p的左节点赋值为空，pl已经保存了该节点</span></span><br><span class="line">            p.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 将p节点的右节点赋值为sr，如果sr不为空，则将sr的父节点赋值为p节点</span></span><br><span class="line">            <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                sr.parent = p;</span><br><span class="line">             <span class="comment">// 将s节点的左节点赋值为pl，如果pl不为空，则将pl的父节点赋值为s节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                pl.parent = s;</span><br><span class="line">             <span class="comment">// 将s的父节点赋值为p的父节点pp</span></span><br><span class="line">    		<span class="comment">// 如果pp为空，则p节点为root节点, 交换后s成为新的root节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                root = s;</span><br><span class="line">            <span class="comment">// 如果p不为root节点, 并且p是pp的左节点，则将pp的左节点赋值为s节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = s;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">// 如果p不为root节点, 并且p是pp的右节点，则将pp的右节点赋值为s节点</span></span><br><span class="line">                pp.right = s;</span><br><span class="line">            <span class="comment">// 12.6 寻找replacement节点，用来替换掉p节点</span></span><br><span class="line">    		<span class="comment">// 12.6.1 如果sr不为空，则replacement节点为sr，因为s没有左节点，所以使用s的右节点来替换p的位置</span></span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = sr;<span class="comment">// p和s换位置后，p.left为空，如果这时候的p.right != null，就退化为情况2</span></span><br><span class="line">            <span class="comment">// 12.6.1 如果sr为空，则s为叶子节点，replacement为p本身，只需要将p节点直接去除即可</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;<span class="comment">// p和s换位置后，p.left为空，如果这时候的p.right == null，就退化为情况1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 13.承接12点的判断，如果p的左节点不为空，右节点为空，replacement节点为p的左节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>) <span class="comment">// 情况2，p.right为null，可以直接用p.left替换p</span></span><br><span class="line">            replacement = pl;</span><br><span class="line">        <span class="comment">// 14.如果p的右节点不为空,左节点为空，replacement节点为p的右节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)<span class="comment">// 情况2，p.left为null，可以直接用p.right替换p</span></span><br><span class="line">            replacement = pr;</span><br><span class="line">        <span class="comment">// 15.如果p的左右节点都为空, 即p为叶子节点, replacement节点为p节点本身</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 情况1，p的左右都为null，后面直接删除p就行</span></span><br><span class="line">            replacement = p;</span><br><span class="line">        <span class="comment">// 16.第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">        <span class="keyword">if</span> (replacement != p) &#123;<span class="comment">// 情况2 或者 情况3退化为情况2时，删除节点p的操作</span></span><br><span class="line">            <span class="comment">// 16.1 将p节点的父节点赋值给replacement节点的父节点, 同时赋值给pp节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            <span class="comment">// 16.2 如果p没有父节点, 即p为root节点，则将root节点赋值为replacement节点即可</span></span><br><span class="line">            <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="comment">// 16.3 如果p不是root节点, 并且p为pp的左节点，则将pp的左节点赋值为替换节点replacement</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            <span class="comment">// 16.4 如果p不是root节点, 并且p为pp的右节点，则将pp的右节点赋值为替换节点replacement</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            <span class="comment">// 16.5 p节点的位置已经被完整的替换为replacement, 将p节点清空, 以便垃圾收集器回收</span></span><br><span class="line">            p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 17.如果p节点不为红色则进行红黑树删除平衡调整(如果删除的节点是红色则不会破坏红黑树的平衡无需调整)</span></span><br><span class="line">        TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line">        <span class="comment">// 18.如果p节点为叶子节点, 则简单的将p节点去除即可</span></span><br><span class="line">        <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach 情况1 或者 情况3退化为情况1时，删除节点p的操作</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;<span class="comment">// 18.1 将p的parent属性设置为空</span></span><br><span class="line">            <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 18.2 如果p节点为父节点的左节点，则将父节点的左节点赋值为空</span></span><br><span class="line">                <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 18.3 如果p节点为父节点的右节点， 则将父节点的右节点赋值为空</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                    pp.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (movable)</span><br><span class="line">            moveRootToFront(tab, r);<span class="comment">// 19.将root节点移到索引位置的头节点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>remove要复杂些，分三种情况考虑。为了帮助理解removeTreeNode，画了几张图，理解如何在二叉搜索树中删除一个节点（红左；蓝右；黑代表父节点，不用管左右）。</p>
<p>a、二叉搜索树删除节点中最简单的情况，直接删除，或者说使用 null（NIL节点）替换它 也行。</p>
<p><img src="https://img-blog.csdn.net/20170303223454270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>b、二叉搜索树删除节点中次简单的情况，直接使用非空子树替换它。</p>
<p><img src="https://img-blog.csdn.net/20170303223637489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>c、二叉搜索树删除节点中的一般情况：p和s进行“内容交换”后，退化为上面两种情况，再处理一次。<br>这种一般用指针描述比较直观，上面的代码中使用“内容交换”的方式反而绕一些，这样主要是为了让人知道，后续该围绕哪个节点来进行红黑树平衡化。一开始还没看懂，不过两者的确是等效的。<br><img src="https://img-blog.csdn.net/20170303223851366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<hr>
<p>另外，第一次调整和第二次调整的是本人根据代码而设定的，将第一次调整和第二次调整合起来看会更容易理解，如下：</p>
<p>第一次调整 + 第二次调整：将 p 节点和 s 节点进行了位置调换，选出要替换掉 p 节点的 replacement<br>第三次调整：将 replacement 节点覆盖掉 p 节点<br><img src="https://img-blog.csdn.net/20180203174538825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdjEyMzQxMTczOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    * 两个功能：初始化和扩容double</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span>	</span><br><span class="line"><span class="comment">// 扩容兼初始化</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">	Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">	<span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">// 数组长度</span></span><br><span class="line">	<span class="keyword">int</span> oldThr = threshold;<span class="comment">// 扩容临界值 The next size value at which to resize (capacity * load factor)</span></span><br><span class="line">	<span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 1.老表的容量不为0，即老表不为空</span></span><br><span class="line">	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 1.1 判断老表的容量是否超过最大容量值：如果超过则将阈值设置为Integer.MAX_VALUE，并直接返回老表,此时oldCap * 2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大</span></span><br><span class="line">		<span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			<span class="comment">// 原数组长度大于最大容量1&lt;&lt;30(1073741824) 则将threshold设为Integer.MAX_VALUE=2147483647(1&lt;&lt;31-1)</span></span><br><span class="line">			<span class="comment">// 接近MAXIMUM_CAPACITY的两倍</span></span><br><span class="line">			threshold = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">return</span> oldTab;<span class="comment">//不扩容了，最大容量了，自己碰撞吧</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 1.2 将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap&gt;=16, 则将新阈值设置为原来的两倍</span></span><br><span class="line">			newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 2.如果老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果原来的thredshold大于0则将容量设为原来的thredshold</span></span><br><span class="line">		<span class="comment">// 在第一次带参数初始化时候会有这种情况</span></span><br><span class="line">		newCap = oldThr;</span><br><span class="line">       <span class="comment">// 3.老表的容量为0, 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值  </span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 在默认无参数初始化会有这种情况</span></span><br><span class="line">		newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">// 16</span></span><br><span class="line">		newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">// 0.75*16=12</span></span><br><span class="line">	&#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 4.如果新表的阈值为空, 则通过新的容量*负载因子获得阈值</span></span><br><span class="line">	<span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果新 的容量 ==0</span></span><br><span class="line">		<span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;<span class="comment">// loadFactor 哈希加载因子 默认0.75,可在初始化时传入,16*0.75=12 可以放12个键值对</span></span><br><span class="line">		newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ? (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 5.将当前阈值设置为刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。</span></span><br><span class="line">	threshold = newThr;<span class="comment">// 将临界值设置为新临界值</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line">	<span class="comment">// 扩容正式开始</span></span><br><span class="line">	Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line">	table = newTab;</span><br><span class="line">	<span class="comment">// 6 如果原来的table有数据，则将数据复制到新的table中</span></span><br><span class="line">	<span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 根据容量进行循环整个数组，将非空元素进行复制</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">			Node&lt;K, V&gt; e;</span><br><span class="line">			<span class="comment">// 获取数组的第j个元素e,也可能是链表/红黑树头，如果不为空继续考虑下拉链表</span></span><br><span class="line">			<span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				oldTab[j] = <span class="keyword">null</span>;<span class="comment">// 将老表的节点设置为空, 以便垃圾收集器回收空间</span></span><br><span class="line">				<span class="comment">//7 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">				<span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">					<span class="comment">// e.hash &amp; (newCap - 1) 确定元素存放位置</span></span><br><span class="line">					newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">				<span class="comment">// 8.如果是红黑树节点，则进行红黑树的重hash分布(跟链表的hash分布基本相同)</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">				<span class="keyword">else</span> &#123;<span class="comment">// 9.如果是普通的链表节点，则进行普通的重hash分布</span></span><br><span class="line">					<span class="comment">// 进行链表复制</span></span><br><span class="line">					<span class="comment">// 方法比较特殊： 它并没有重新计算元素在数组中的位置</span></span><br><span class="line">					<span class="comment">// 而是采用了原始位置加原数组长度的方法计算得到位置</span></span><br><span class="line">					Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">// lo = low，表示低位0</span></span><br><span class="line">					Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">// hi = high，表示高位1</span></span><br><span class="line"></span><br><span class="line">					Node&lt;K, V&gt; next;</span><br><span class="line">                       <span class="comment">// 这个do-while中先把要迁移的节点根据它们迁移后的位置，按照原来在一条链表上的相对顺序，分为两队，然后一次性把一队整个放在新的hash桶中，这样就能保留节点之间的相对顺序</span></span><br><span class="line">					<span class="keyword">do</span> &#123;<span class="comment">// 注: e本身就是一个链表的节点，它有 自身的值和next(链表的值)，但是因为next值对节点扩容没有帮助， 所有在下面讨论中，我近似认为 e是一个只有自身值，而没有next值的元素。</span></span><br><span class="line">						next = e.next;</span><br><span class="line">						<span class="comment">// 注意：不是(e.hash &amp; (oldCap-1));而是(e.hash &amp; oldCap)</span></span><br><span class="line">						<span class="comment">// (e.hash &amp; oldCap)得到的是元素的在数组中的位置是否需要移动,示例如下</span></span><br><span class="line">						<span class="comment">// 示例1：</span></span><br><span class="line">						<span class="comment">// e.hash=10 0000 1010</span></span><br><span class="line">						<span class="comment">// oldCap=16 0001 0000</span></span><br><span class="line">						<span class="comment">//	 &amp;   =0	 0000 0000       比较高位的第一位 0</span></span><br><span class="line">						<span class="comment">//结论：元素位置在扩容后数组中的位置没有发生改变</span></span><br><span class="line">						<span class="comment">// 示例2：</span></span><br><span class="line">						<span class="comment">// e.hash=17 0001 0001</span></span><br><span class="line">						<span class="comment">// oldCap=16 0001 0000</span></span><br><span class="line">						<span class="comment">//	 &amp;   =1	 0001 0000      比较高位的第一位   1</span></span><br><span class="line">						<span class="comment">//结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是原下标位置+原数组长度</span></span><br><span class="line">						<span class="comment">// (e.hash &amp; (oldCap-1)) 得到的是下标位置,示例如下</span></span><br><span class="line">						<span class="comment">//   e.hash=10 0000 1010</span></span><br><span class="line">						<span class="comment">// oldCap-1=15 0000 1111</span></span><br><span class="line">						<span class="comment">//      &amp;  =10 0000 1010</span></span><br><span class="line">							</span><br><span class="line">						<span class="comment">//   e.hash=17 0001 0001</span></span><br><span class="line">						<span class="comment">// oldCap-1=15 0000 1111</span></span><br><span class="line">						<span class="comment">//      &amp;  =1  0000 0001</span></span><br><span class="line">						</span><br><span class="line">						<span class="comment">//新下标位置</span></span><br><span class="line">						<span class="comment">//   e.hash=17 0001 0001</span></span><br><span class="line">						<span class="comment">// newCap-1=31 0001 1111    newCap=32</span></span><br><span class="line">						<span class="comment">//      &amp;  =17 0001 0001    1+oldCap = 1+16</span></span><br><span class="line">						</span><br><span class="line">						<span class="comment">//元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</span></span><br><span class="line">						<span class="comment">//参考博文：[Java8的HashMap详解](https://blog.csdn.net/login_sonata/article/details/76598675)  </span></span><br><span class="line">						<span class="comment">// 0000 0001-&gt;0001 0001</span></span><br><span class="line">                           <span class="comment">// 9.1 如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">						<span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">							<span class="comment">// 如果原元素位置没有发生变化</span></span><br><span class="line">							<span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">								loHead = e;<span class="comment">// 确定首元素</span></span><br><span class="line">							<span class="comment">// 第一次进入时	  e-&gt; aa  ; loHead-&gt; aa</span></span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								loTail.next = e;<span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">							<span class="comment">//第二次进入时		loTail-&gt; aa  ;    e  -&gt; bb ;  loTail.next -&gt; bb;而loHead和loTail是指向同一块内存的，所以loHead.next 地址为 bb  </span></span><br><span class="line">							<span class="comment">//第三次进入时		loTail-&gt; bb  ;    e  -&gt; cc ;  loTail.next 地址为 cc;loHead.next.next = cc</span></span><br><span class="line">							loTail = e;</span><br><span class="line">							<span class="comment">// 第一次进入时   	  e   -&gt; aa  ; loTail-&gt; aa loTail指向了和  loHead相同的内存空间</span></span><br><span class="line">							<span class="comment">// 第二次进入时               e   -&gt; bb  ; loTail-&gt; bb loTail指向了和  loTail.next（loHead.next）相同的内存空间   loTail=loTail.next</span></span><br><span class="line">							<span class="comment">// 第三次进入时               e   -&gt; cc  ; loTail-&gt; cc loTail指向了和  loTail.next(loHead.next.next)相同的内存</span></span><br><span class="line">						<span class="comment">// 9.2 如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:老表的索引位置＋oldCap     </span></span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">//与上面同理</span></span><br><span class="line">							</span><br><span class="line">							<span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">								hiHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								hiTail.next = e;</span><br><span class="line">							hiTail = e;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//do while 结束之后，lotail指向lo链表的最后一个元素，lohead还是第一个head，通过二者的合作使链表连接了起来，很巧妙</span></span><br><span class="line">                       <span class="comment">//这一块就是 旧链表迁移新链表，总结：</span></span><br><span class="line">                       <span class="comment">//1.8中 旧链表迁移新链表：链表元素相对位置没有变化; 实际是对对象的内存地址进行操作 </span></span><br><span class="line">					<span class="comment">//在1.7中  旧链表迁移新链表：如果在新表的数组索引位置相同，则链表元素会倒置</span></span><br><span class="line">					<span class="comment">// 10.如果loTail不为空（说明老表的数据有分布到新表上“原索引位置”的节点），则将最后一个节点的next设为空，并将新表上索引位置为“原索引位置”的节点设置为对应的头节点</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">						loTail.next = <span class="keyword">null</span>;<span class="comment">// 将链表的尾节点 的next 设置为空</span></span><br><span class="line">						newTab[j] = loHead;</span><br><span class="line">					&#125;</span><br><span class="line">                       <span class="comment">// 11.如果hiTail不为空（说明老表的数据有分布到新表上“原索引+oldCap位置”的节点），则将最后一个节点的next设为空，并将新表上索引位置为“原索引+oldCap”的节点设置为对应的头节点   </span></span><br><span class="line">					<span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">						hiTail.next = <span class="keyword">null</span>;<span class="comment">// 将链表的尾节点 的next 设置为空</span></span><br><span class="line">						newTab[j + oldCap] = hiHead;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newTab;  <span class="comment">// 12.返回新表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 用于实现resize，跟链表的resize一样，也是使用高低位算法拆分成两个部分</span></span><br><span class="line">	<span class="comment">// 拆分后的部分如果长度小，就存储为普通的链表，长度满足就转化为新的红黑树存储</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">        * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">        * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">           <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">           TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">           TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 1.以调用此方法的节点开始，遍历整个红黑树节点</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;<span class="comment">// 从b=this节点开始遍历</span></span><br><span class="line">               next = (TreeNode&lt;K,V&gt;)e.next;<span class="comment">// next赋值为e的下个节点</span></span><br><span class="line">               e.next = <span class="keyword">null</span>;<span class="comment">// 同时将老表的节点设置为空，以便垃圾收集器回收</span></span><br><span class="line">                <span class="comment">// 2.如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">               <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)<span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                       loHead = e;<span class="comment">// 则将loHead赋值为第一个节点</span></span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       loTail.next = e; <span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">                   loTail = e;<span class="comment">// 并将loTail赋值为新增的节点</span></span><br><span class="line">                   ++lc;<span class="comment">// 统计原索引位置的节点个数</span></span><br><span class="line">               &#125;</span><br><span class="line">              <span class="comment">// 3.如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:老表的索引位置＋oldCap</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                       hiHead = e;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       hiTail.next = e;</span><br><span class="line">                   hiTail = e;</span><br><span class="line">                   ++hc;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">// 4.如果原索引位置的节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;<span class="comment">// 原索引位置的节点不为空</span></span><br><span class="line">       		<span class="comment">// 4.1 如果节点个数&lt;=6个则将红黑树转为链表结构</span></span><br><span class="line">               <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                   tab[index] = loHead.untreeify(map);</span><br><span class="line">               <span class="keyword">else</span> &#123;<span class="comment">// 4.2 将原索引位置的节点设置为对应的头节点</span></span><br><span class="line">                   tab[index] = loHead;</span><br><span class="line">                   <span class="comment">// 4.3 如果hiHead不为空，则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">           		<span class="comment">// 已经被改变, 需要重新构建新的红黑树</span></span><br><span class="line">                   <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                       loHead.treeify(tab); <span class="comment">// 4.4 以loHead为根节点, 构建新的红黑树</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 5.如果索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;<span class="comment">// 索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">               <span class="comment">// 5.1 如果节点个数&lt;=6个则将红黑树转为链表结构</span></span><br><span class="line">               <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                   tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 5.2 将索引位置为原索引+oldCap的节点设置为对应的头节点</span></span><br><span class="line">                   tab[index + bit] = hiHead;</span><br><span class="line">                   <span class="comment">// 5.3 loHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置</span></span><br><span class="line">           		<span class="comment">// 已经被改变, 需要重新构建新的红黑树</span></span><br><span class="line">                   <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                       hiHead.treeify(tab);<span class="comment">// 5.4 以hiHead为根节点, 构建新的红黑树</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩容中在新数组中存放元素的流程图解：</strong><br>注: e本身就是一个链表的节点，它有 自身的值和next(链表的值)，但是因为next值对节点扩容没有帮助，所有在下面讨论中，我近似认为 e是一个只有自身值，而没有next值的元素。在每次扩容前，e的next值有专门的next变量接收(next = e.next)<img src="https://img-blog.csdn.net/20180816150406629?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0OTQ3NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="jdk1-8为什么不用重新计算hash就能得出索引"><a href="#jdk1-8为什么不用重新计算hash就能得出索引" class="headerlink" title="jdk1.8为什么不用重新计算hash就能得出索引"></a>jdk1.8为什么不用重新计算hash就能得出索引</h4><p><img src="https://img-blog.csdn.net/20170303220648352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，<strong>JDK1.8不会倒置</strong></p>
<h4 id="扩容机制更多参考资料"><a href="#扩容机制更多参考资料" class="headerlink" title="扩容机制更多参考资料"></a>扩容机制更多参考资料</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq32933432/article/details/86668385">jdk8之HashMap resize方法详解（深入讲解为什么1.8中扩容后的元素新位置为原位置+原数组长度）</a></p>
<h2 id="HashMap为什么要树化？"><a href="#HashMap为什么要树化？" class="headerlink" title="HashMap为什么要树化？"></a>HashMap为什么要树化？</h2><p>本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p>
<blockquote>
<p>用哈希碰撞发起拒绝服务攻击(DOS，Denial-Of-Service attack),常见的场景是攻击者可以事先构造大量相同哈希值的数据，然后以JSON数据的形式发送给服务器，服务器端在将其构建成为Java对象过程中，通常以Hashtable或HashMap等形式存储，哈希碰撞将导致哈希表发生严重退化，算法复杂度可能上升一个数据级，进而耗费大量CPU资源。</p>
</blockquote>
<h2 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/developer_chan/p/10450908.html">HashMap线程不安全的体现</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27093465/article/details/52207135#">Java 8系列之重新认识HashMap</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/9606.html">疫苗：JAVA HASHMAP的死循环</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>HashMap 的底层是个 Node 数组（Node&lt;K,V&gt;[] table），在数组的具体索引位置，如果存在多个节点，则可能是以链表或红黑树的形式存在。<br>增加、删除、查找键值对时，定位到哈希桶数组的位置是很关键的一步，源码中是通过下面3个操作来完成这一步：1）拿到 key 的 hashCode 值；2）将 hashCode 的高位参与运算，重新计算 hash 值；3）将计算出来的 hash 值与 “table.length - 1” 进行 &amp; 运算。<br>HashMap 的默认初始容量（capacity）是 16，capacity 必须为 2 的幂次方；默认负载因子（load factor）是 0.75；实际能存放的节点个数（threshold，即触发扩容的阈值）= capacity * load factor。<br>HashMap 在触发扩容后，阈值会变为原来的 2 倍，并且会对所有节点进行重 hash 分布，重 hash 分布后节点的新分布位置只可能有两个：“原索引位置” 或 “原索引+oldCap位置”。例如 capacity 为16，索引位置 5 的节点扩容后，只可能分布在新表 “索引位置5” 和 “索引位置21（5+16）”。<br>导致 HashMap 扩容后，同一个索引位置的节点重 hash 最多分布在两个位置的根本原因是：1）table的长度始终为 2 的 n 次方；2）索引位置的计算方法为 “(table.length - 1) &amp; hash”。HashMap 扩容是一个比较耗时的操作，定义 HashMap 时尽量给个接近的初始容量值。<br>HashMap 有 threshold 属性和 loadFactor 属性，但是没有 capacity 属性。初始化时，如果传了初始化容量值，该值是存在 threshold 变量，并且 Node 数组是在第一次 put 时才会进行初始化，初始化时会将此时的 threshold 值作为新表的 capacity 值，然后用 capacity 和 loadFactor 计算新表的真正 threshold 值。<br>当同一个索引位置的节点在增加后达到 9 个时，并且此时数组的长度大于等于 64，则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。链表节点转红黑树节点的具体方法为源码中的 treeifyBin 方法。而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容。<br>当同一个索引位置的节点在移除后达到 6 个时，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点。红黑树节点转链表节点的具体方法为源码中的 untreeify 方法。<br>HashMap 在 JDK 1.8 之后不再有死循环的问题，JDK 1.8 之前存在死循环的根本原因是在扩容后同一索引位置的节点顺序会反掉。<br>HashMap 是非线程安全的，在并发场景下使用 ConcurrentHashMap 来代替。</p>
</blockquote>
<h2 id="HashMap详解其它参考"><a href="#HashMap详解其它参考" class="headerlink" title="HashMap详解其它参考"></a>HashMap详解其它参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011392897/article/details/60151323">Java集合类框架学习 4.3 —— HashMap(JDK1.8)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/78996181">Java集合：HashMap详解（JDK 1.8）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/login_sonata/article/details/76598675">Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27093465/article/details/52207135#">Java 8系列之重新认识HashMap</a></p>
<h1 id="二、ConcurrentHashMap源码"><a href="#二、ConcurrentHashMap源码" class="headerlink" title="二、ConcurrentHashMap源码"></a>二、ConcurrentHashMap源码</h1><h2 id="主要改动"><a href="#主要改动" class="headerlink" title="主要改动"></a>主要改动</h2><p>参照对象为jdk1.7的ConcurrentHashMap，当然，熟悉jdk1.8的HashMap能够更好地理解一些改动，<strong>HashMap和ConcurrentHashMap本来就有很多共通的东西</strong>。<br>1、jdk1.8的ConcurrentHashMap不再使用Segment代理Map操作这种设计，整体结构变为HashMap这种结构，但是依旧保留分段锁的思想。之前版本是每个Segment都持有一把锁，<strong>1.8版本改为锁住恰好装在一个hash桶本身位置上的节点，也就是hash桶的第一个节点 tabAt(table, i)<strong>，后面直接叫第一个节点。</strong>它可能是Node链表的头结点、保留节点ReservationNode、或者是TreeBin节点</strong>（TreeBin节点持有红黑树的根节点）。还有，1.8的节点变成了4种，这个后面细说，是个重要的知识。</p>
<p>2、可以多线程并发来完成扩容这个耗时耗力的操作。在之前的版本中如果Segment正在进行扩容操作，其他写线程都会被<strong>阻塞</strong>，<strong>jdk1.8改为一个写线程触发了扩容操作，其他写线程进行写入操作时，可以帮助它来完成扩容这个耗时的操作</strong>。多线程并发扩容这部分后面细说。</p>
<p>3、因为多线程并发扩容的存在，导致的其他操作的实现上会有比较大的改动，常见的get/put/remove/replace/clear，以及迭代操作，都要考虑并发扩容的影响。</p>
<p>4、<strong>使用新的计数方法</strong>。不使用Segment时，如果直接使用一个volatile类变量计数，因为每次读写volatile变量的开销很大，高并发时效率不如之前版本的使用Segment时的计数方式。jdk1.8新增了一个用与高并发情况的计数工具类java.util.concurrent.atomic.<strong>LongAdder</strong>，此类是基本思想和1.7及以前的ConcurrentHashMap一样，使用了一层中间类，叫做Cell（类似Segment这个类）的计数单元，来实现分段计数，最后合并统计一次。因为不同的计数单元可以承担不同的线程的计数要求，减少了线程之间的竞争，在1.8的ConcurrentHashMap基本结果改变时，继续保持和分段计数一样的并发计数效率。关于这个LongAdder，专门写了一篇。</p>
<p>5、同1.8版本的HashMap，<strong>当一个hash桶中的hash冲突节点太多时，把链表变为红黑树，提高冲突时的查找效率</strong>。</p>
<p>6、一些小的改进，具体见后面的源码上我写的注释。</p>
<p>7、函数式编程、Stream api相关的新功能，占据了1.8的大概40%的代码，这部分这里就先不说了。<br>8、因为不再使用中间层的Segment，<strong>整体设计结构基本上和1.8版本的HashMap一样</strong>，和普通的HashMap很像了，图就不画了。</p>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="1、常量"><a href="#1、常量" class="headerlink" title="1、常量"></a>1、常量</h3><p>只对相对1.7的有改动的常量，或者新增的常量作注释。特别注意下，concurrencyLevel和loadFactor都不再是原来的作用了，保留很大程度只是为了兼容之前的版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面3个，在1.8的HashMap中也有相同的常量</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个hash桶中hash冲突的数目大于此值时，把链表转化为红黑树，加快hash冲突时的查找速度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个hash桶中hash冲突的数目小于等于此值时，把红黑树转化为链表，当数目比较少时，链表的实际查找速度更快，也是为了查找效率</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当table数组的长度小于此值时，不会把链表转化为红黑树。所以转化为红黑树有两个条件，还有一个是 TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 虚拟机限制的最大数组长度，在ArrayList中有说过，jdk1.8新引入的，ConcurrentHashMap的主体代码中是不使用这个的，主要用在Collection.toArray两个方法中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 默认并行级别，主体代码中未使用此常量，为了兼容性，保留了之前的定义，主要是配合同样是为了兼容性的Segment使用，另外在构造方法中有一些作用</span></span><br><span class="line"><span class="comment">// 千万注意，1.8的并发级别有了大的改动，具体并发级别可以认为是hash桶是数量，也就是容量，会随扩容而改变，不再是固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加载因子，为了兼容性，保留了这个常量（名字变了），配合同样是为了兼容性的Segment使用</span></span><br><span class="line"><span class="comment">// 1.8的ConcurrentHashMap的加载因子固定为 0.75，构造方法中指定的参数是不会被用作loadFactor的，为了计算方便，统一使用 n - (n &gt;&gt; 2) 代替浮点乘法 *0.75</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 扩容操作中，transfer这个步骤是允许多线程的，这个常量表示一个线程执行transfer时，最少要对连续的16个hash桶进行transfer</span></span><br><span class="line"><span class="comment">//     （不足16就按16算，多控制下正负号就行）</span></span><br><span class="line"><span class="comment">// 也就是单线程执行transfer时的最小任务量，单位为一个hash桶，这就是线程的transfer的步进（stride）</span></span><br><span class="line"><span class="comment">// 最小值是DEFAULT_CAPACITY，不使用太小的值，避免太小的值引起transfer时线程竞争过多，如果计算出来的值小于此值，就使用此值</span></span><br><span class="line"><span class="comment">// 正常步骤中会根据CPU核心数目来算出实际的，一个核心允许8个线程并发执行扩容操作的transfer步骤，这个8是个经验值，不能调整的</span></span><br><span class="line"><span class="comment">// 因为transfer操作不是IO操作，也不是死循环那种100%的CPU计算，CPU计算率中等，1核心允许8个线程并发完成扩容，理想情况下也算是比较合理的值</span></span><br><span class="line"><span class="comment">// 一段代码的IO操作越多，1核心对应的线程就要相应设置多点，CPU计算越多，1核心对应的线程就要相应设置少一些</span></span><br><span class="line"><span class="comment">// 表明：默认的容量是16，也就是默认构造的实例，第一次扩容实际上是单线程执行的，看上去是可以多线程并发（方法允许多个线程进入），</span></span><br><span class="line"><span class="comment">//     但是实际上其余的线程都会被一些if判断拦截掉，不会真正去执行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于生成每次扩容都唯一的生成戳的数，最小是6。很奇怪，这个值不是常量，但是也不提供修改方法。</span></span><br><span class="line"><span class="comment">/** The number of bits used for generation stamp in sizeCtl. Must be at least 6 for 32bit arrays. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 最大的扩容线程的数量，如果上面的 RESIZE_STAMP_BITS = 32，那么此值为 0，这一点也很奇怪。</span></span><br><span class="line"><span class="comment">/** The maximum number of threads that can help resize. Must fit in 32 - RESIZE_STAMP_BITS bits. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移位量，把生成戳移位后保存在sizeCtl中当做扩容线程计数的基数，相反方向移位后能够反解出生成戳</span></span><br><span class="line"><span class="comment">/** The bit shift for recording size stamp in sizeCtl. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面几个是特殊的节点的hash值，正常节点的hash值在hash函数中都处理过了，不会出现负数的情况，特殊节点在各自的实现类中有特殊的遍历方法</span></span><br><span class="line"><span class="comment">// ForwardingNode的hash值，ForwardingNode是一种临时节点，在扩进行中才会出现，并且它不存储实际的数据</span></span><br><span class="line"><span class="comment">// 如果旧数组的一个hash桶中全部的节点都迁移到新数组中，旧数组就在这个hash桶中放置一个ForwardingNode</span></span><br><span class="line"><span class="comment">// 读操作或者迭代读时碰到ForwardingNode时，将操作转发到扩容后的新的table数组上去执行，写操作碰见它时，则尝试帮助扩容</span></span><br><span class="line"><span class="comment">/** Encodings for Node hash fields. See above for explanation. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// TreeBin的hash值，TreeBin是ConcurrentHashMap中用于代理操作TreeNode的特殊节点，持有存储实际数据的红黑树的根节点</span></span><br><span class="line"><span class="comment">// 因为红黑树进行写入操作，整个树的结构可能会有很大的变化，这个对读线程有很大的影响，</span></span><br><span class="line"><span class="comment">//     所以TreeBin还要维护一个简单读写锁，这是相对HashMap，这个类新引入这种特殊节点的重要原因</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ReservationNode的hash值，ReservationNode是一个保留节点，就是个占位符，不会保存实际的数据，正常情况是不会出现的，</span></span><br><span class="line"><span class="comment">// 在jdk1.8新的函数式有关的两个方法computeIfAbsent和compute中才会出现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于和负数hash值进行 &amp; 运算，将其转化为正数（绝对值不相等），Hashtable中定位hash桶也有使用这种方式来进行负数转正数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// CPU的核心数，用于在扩容时计算一个线程一次要干多少活</span></span><br><span class="line"><span class="comment">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在序列化时使用，这是为了兼容以前的版本</span></span><br><span class="line"><span class="comment">/** For serialization compatibility. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h3><p>只对相对1.7的有改动的或者新增的变量作注释。变量是理解1.8的新的改动的关键，在前面说了几点关键的改动，<strong>nextTable、sizeCtl、transferIndex与多线程扩容有关，baseCount、cellsBusy、counterCells与新的高效的并发计数方式有关。</strong><br>另外说明下：本人认为sizeCtl的英文注释是有误的，所以各位请务必仔细看下sizeCtl的，结合扩容相关的一起看。网上有不少直接按照sizeCtl的英文注释来理解代码，这样是不对的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 扩容后的新的table数组，只有在扩容时才有用</span></span><br><span class="line"><span class="comment">// nextTable != null，说明扩容方法还没有真正退出，一般可以认为是此时还有线程正在进行扩容，</span></span><br><span class="line"><span class="comment">//     极端情况需要考虑此时扩容操作只差最后给几个变量赋值（包括nextTable = null）的这个大的步骤，</span></span><br><span class="line"><span class="comment">//     这个大步骤执行时，通过sizeCtl经过一些计算得出来的扩容线程的数量是0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 非常重要的一个属性，源码中的英文翻译，直译过来是下面的四行文字的意思</span></span><br><span class="line"><span class="comment">//     sizeCtl = -1，表示有线程正在进行真正的初始化操作</span></span><br><span class="line"><span class="comment">//     sizeCtl = -(1 + nThreads)，表示有nThreads个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment">//     sizeCtl &gt; 0，表示接下来的真正的初始化操作中使用的容量，或者初始化/扩容完成后的threshold</span></span><br><span class="line"><span class="comment">//     sizeCtl = 0，默认值，此时在真正的初始化操作中使用默认容量</span></span><br><span class="line"><span class="comment">// 但是，通过我对源码的理解，这段注释实际上是有问题的，</span></span><br><span class="line"><span class="comment">//     有问题的是第二句，sizeCtl = -(1 + nThreads)这个，网上好多都是用第二句的直接翻译去解释代码，这样理解是错误的</span></span><br><span class="line"><span class="comment">// 默认构造的16个大小的ConcurrentHashMap，只有一个线程执行扩容时，sizeCtl = -2145714174，</span></span><br><span class="line"><span class="comment">//     但是照这段英文注释的意思，sizeCtl的值应该是 -(1 + 1) = -2</span></span><br><span class="line"><span class="comment">// sizeCtl在小于0时的确有记录有多少个线程正在执行扩容任务的功能，但是不是这段英文注释说的那样直接用 -(1 + nThreads)</span></span><br><span class="line"><span class="comment">// 实际中使用了一种生成戳，根据生成戳算出一个基数，不同轮次的扩容操作的生成戳都是唯一的，来保证多次扩容之间不会交叉重叠，</span></span><br><span class="line"><span class="comment">//     当有n个线程正在执行扩容时，sizeCtl在值变为 (基数 + n)</span></span><br><span class="line"><span class="comment">// 1.8.0_111的源码的383-384行写了个说明：A generation stamp in field sizeCtl ensures that resizings do not overlap.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table initialization and resizing control.</span></span><br><span class="line"><span class="comment"> * When negative, the table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment"> * else -(1 + the number of active resizing threads).</span></span><br><span class="line"><span class="comment"> * Otherwise, when table is null, holds the initial table size to use upon creation,</span></span><br><span class="line"><span class="comment"> * or 0 for default.</span></span><br><span class="line"><span class="comment"> * After initialization, holds the next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下一个transfer任务的起始下标index 加上1 之后的值，transfer时下标index从length - 1开始往0走</span></span><br><span class="line"><span class="comment">// transfer时方向是倒过来的，迭代时是下标从小往大，二者方向相反，尽量减少扩容时transefer和迭代两者同时处理一个hash桶的情况，</span></span><br><span class="line"><span class="comment">// 顺序相反时，二者相遇过后，迭代没处理的都是已经transfer的hash桶，transfer没处理的，都是已经迭代的hash桶，冲突会变少</span></span><br><span class="line"><span class="comment">// 下标在[nextIndex - 实际的stride （下界要 &gt;= 0）, nextIndex - 1]内的hash桶，就是每个transfer的任务区间</span></span><br><span class="line"><span class="comment">// 每次接受一个transfer任务，都要CAS执行 transferIndex = transferIndex - 实际的stride，</span></span><br><span class="line"><span class="comment">//     保证一个transfer任务不会被几个线程同时获取（相当于任务队列的size减1）</span></span><br><span class="line"><span class="comment">// 当没有线程正在执行transfer任务时，一定有transferIndex &lt;= 0，这是判断是否需要帮助扩容的重要条件（相当于任务队列为空）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面三个主要与统计数目有关，可以参考jdk1.8新引入的java.util.concurrent.atomic.LongAdder的源码，帮助理解</span></span><br><span class="line"><span class="comment">// 计数器基本值，主要在没有碰到多线程竞争时使用，需要通过CAS进行更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CAS自旋锁标志位，用于初始化，或者counterCells扩容时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于高并发的计数单元，如果初始化了这些计数单元，那么跟table数组一样，长度必须是2^n的形式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="基本类"><a href="#基本类" class="headerlink" title="基本类"></a>基本类</h2><h3 id="1、Node：基本节点-普通节点"><a href="#1、Node：基本节点-普通节点" class="headerlink" title="1、Node：基本节点/普通节点"></a>1、Node：基本节点/普通节点</h3><p>此节点就是一个很普通的Entry，在链表形式保存才使用这种节点，它存储实际的数据，基本结构类似于1.8的HashMap.Node，和1.7的Concurrent.HashEntry。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此类不会在ConcurrentHashMap以外被修改，只读迭代可以利用这个类，迭代时的写操作需要由另一个内部类MapEntry代理执行写操作</span></span><br><span class="line"><span class="comment">// 此类的子类具有负数hash值，并且不存储实际的数据，如果不使用子类直接使用这个类，那么key和val永远不会为null</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"> </span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + val; &#125;</span><br><span class="line">    <span class="comment">// 不支持来自ConcurrentHashMap外部的修改，跟1.7的一样，迭代操作需要通过另外一个内部类MapEntry来代理，迭代写会重新执行一次put操作</span></span><br><span class="line">    <span class="comment">// 迭代中可以改变value，是一种写操作，此时需要保证这个节点还在map中，</span></span><br><span class="line">    <span class="comment">//     因此就重新put一次：节点不存在了，可以重新让它存在；节点还存在，相当于replace一次</span></span><br><span class="line">    <span class="comment">// 设计成这样主要是因为ConcurrentHashMap并非为了迭代操作而设计，它的迭代操作和其他写操作不好并发，</span></span><br><span class="line">    <span class="comment">//     迭代时的读写都是弱一致性的，碰见并发修改时尽量维护迭代的一致性</span></span><br><span class="line">    <span class="comment">// 返回值V也可能是个过时的值，保证V是最新的值会比较困难，而且得不偿失</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;  (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;  (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;  (v == (u = val) || v.equals(u))); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从此节点开始查找k对应的节点</span></span><br><span class="line">    <span class="comment">// 这里的实现是专为链表实现的，一般作用于头结点，各种特殊的子类有自己独特的实现</span></span><br><span class="line">    <span class="comment">// 不过主体代码中进行链表查找时，因为要特殊判断下第一个节点，所以很少直接用下面这个方法，</span></span><br><span class="line">    <span class="comment">//     而是直接写循环遍历链表，子类的查找则是用子类中重写的find方法</span></span><br><span class="line">    <span class="comment">/**  Virtualized support for map.get(); overridden in subclasses. */</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;  ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek)))) </span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、TreeNode：红黑树节点"><a href="#2、TreeNode：红黑树节点" class="headerlink" title="2、TreeNode：红黑树节点"></a>2、TreeNode：红黑树节点</h3><p>在红黑树形式保存时才存在，它也存储有实际的数据，结构和1.8的HashMap的TreeNode一样，一些方法的实现代码也基本一样。不过，ConcurrentHashMap对此节点的操作，都会由TreeBin来代理执行。也可以把这里的TreeNode看出是有一半功能的HashMap.TreeNode，另一半功能在ConcurrentHashMap.TreeBin中。红黑树节点本身保存有普通链表节点Node的所有属性，因此可以使用两种方式进行读操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树节点TreeNode实际上还保存有链表的指针，因此也可以用链表的方式进行遍历读取操作</span></span><br><span class="line"><span class="comment">// 继承LinkedHashMap.Entry主要是为了子类的方便，减少子类的改动</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 新添加的prev指针是为了删除方便，删除链表的非头节点的节点，都需要知道它的前一个节点才能进行删除，所以直接提供一个prev指针</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"> </span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next, TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以当前节点 this 为根节点开始遍历查找，跟HashMap.TreeNode.find实现一样</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> || (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp; (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) <span class="comment">// </span></span><br><span class="line">                    对右子树进行递归查找</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl; <span class="comment">// 前面递归查找了右边子树，这里循环时只用一直往左边找</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、ForwardingNode：转发节点"><a href="#3、ForwardingNode：转发节点" class="headerlink" title="3、ForwardingNode：转发节点"></a>3、ForwardingNode：转发节点</h3><p>ForwardingNode是一种临时节点，在扩容进行中才会出现，hash值固定为-1，并且它不存储实际的数据数据。如果旧数组的一个hash桶中全部的节点都迁移到新数组中，旧数组就在这个hash桶中放置一个ForwardingNode。<strong>读操作或者迭代读时碰到ForwardingNode时，将操作转发到扩容后的新的table数组上去执行，写操作碰见它时，则尝试帮助扩容。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ForwardingNode的查找操作，直接在新数组nextTable上去进行查找</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes 使用循环，避免多次碰到ForwardingNode导致递归过深</span></span><br><span class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||  (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> eh; K ek;</span><br><span class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;  ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek)))) <span class="comment">// 第一个节点就是要找的节点，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123; <span class="comment">// 继续碰见ForwardingNode的情况，这里相当于是递归调用一次本方法</span></span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> e.find(h, k); <span class="comment">// 碰见特殊节点，调用其find方法进行查找</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) <span class="comment">// 普通节点直接循环遍历链表</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、TreeBin：代理操作TreeNode的节点"><a href="#4、TreeBin：代理操作TreeNode的节点" class="headerlink" title="4、TreeBin：代理操作TreeNode的节点"></a>4、TreeBin：代理操作TreeNode的节点</h3><p>TreeBin的hash值固定为-2，它是ConcurrentHashMap中用于代理操作TreeNode的特殊节点，持有存储实际数据的红黑树的根节点。因为红黑树进行写入操作，整个树的结构可能会有很大的变化，这个对读线程有很大的影响，所以TreeBin还要维护一个简单读写锁，这是相对HashMap，这个类新引入这种特殊节点的重要原因。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树节点TreeNode实际上还保存有链表的指针，因此也可以用链表的方式进行遍历读取操作</span></span><br><span class="line"><span class="comment">// 自身维护一个简单的读写锁，不用考虑写-写竞争的情况</span></span><br><span class="line"><span class="comment">// 不是全部的写操作都要加写锁，只有部分的put/remove需要加写锁</span></span><br><span class="line"><span class="comment">// 很多方法的实现和jdk1.8的ConcurrentHashMap.TreeNode里面的方法基本一样，可以互相参考</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root; <span class="comment">// 红黑树结构的跟节点</span></span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first; <span class="comment">// 链表结构的头节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter; <span class="comment">// 最近的一个设置 WAITER 标识位的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState; <span class="comment">// 整体的锁状态标识位</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="comment">// 二进制001，红黑树的 写锁状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="comment">// 二进制010，红黑树的 等待获取写锁的状态，中文名字太长，后面用 WAITER 代替</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="comment">// 二进制100，红黑树的 读锁状态，读锁可以叠加，也就是红黑树方式可以并发读，每有一个这样的读线程，lockState都加上一个READER的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重要的一点，红黑树的 读锁状态 和 写锁状态 是互斥的，但是从ConcurrentHashMap角度来说，读写操作实际上可以是不互斥的</span></span><br><span class="line">    <span class="comment">// 红黑树的 读、写锁状态 是互斥的，指的是以红黑树方式进行的读操作和写操作（只有部分的put/remove需要加写锁）是互斥的</span></span><br><span class="line">    <span class="comment">// 但是当有线程持有红黑树的 写锁 时，读线程不会以红黑树方式进行读取操作，而是使用简单的链表方式进行读取，此时读操作和写操作可以并发执行</span></span><br><span class="line">    <span class="comment">// 当有线程持有红黑树的 读锁 时，写线程可能会阻塞，不过因为红黑树的查找很快，写线程阻塞的时间很短</span></span><br><span class="line">    <span class="comment">// 另外一点，ConcurrentHashMap的put/remove/replace方法本身就会锁住TreeBin节点，这里不会出现写-写竞争的情况，因此这里的读写锁可以实现得很简单</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在hashCode相等并且不是Comparable类时才使用此方法进行判断大小</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> || (d = a.getClass().getName().compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用以b为头结点的链表创建一棵红黑树</span></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="keyword">null</span>;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) || (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = r;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires write lock for tree restructuring.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对根节点加 写锁，红黑树重构时需要加上 写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lockRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, <span class="number">0</span>, WRITER)) <span class="comment">// 先尝试获取一次 写锁</span></span><br><span class="line">            contendedLock(); <span class="comment">// offload to separate method 单独抽象出一个方法，直到获取到 写锁 这个调用才会返回</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释放 写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unlockRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lockState = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 可能会阻塞写线程，当写线程获取到写锁时，才会返回</span></span><br><span class="line">    <span class="comment">// ConcurrentHashMap的put/remove/replace方法本身就会锁住TreeBin节点，这里不会出现写-写竞争的情况</span></span><br><span class="line">    <span class="comment">// 本身这个方法就是给写线程用的，因此只用考虑 读锁 阻碍线程获取 写锁，不用考虑 写锁 阻碍线程获取 写锁，</span></span><br><span class="line">    <span class="comment">//     这个读写锁本身实现得很简单，处理不了写-写竞争的情况</span></span><br><span class="line">    <span class="comment">// waiter要么是null，要么是当前线程本身</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">contendedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> waiting = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s;;) &#123;</span><br><span class="line">            <span class="comment">// ~WAITER是对WAITER进行二进制取反，当此时没有线程持有 读锁（不会有线程持有 写锁）时，这个if为真</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; ~WAITER) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, WRITER)) &#123;</span><br><span class="line">                    <span class="comment">// 在 读锁、写锁 都没有被别的线程持有时，尝试为自己这个写线程获取 写锁，同时清空 WAITER 状态的标识位</span></span><br><span class="line">                    <span class="keyword">if</span> (waiting) <span class="comment">// 获取到写锁时，如果自己曾经注册过 WAITER 状态，将其清除</span></span><br><span class="line">                        waiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s &amp; WAITER) == <span class="number">0</span>) &#123; <span class="comment">// 有线程持有 读锁（不会有线程持有 写锁），并且当前线程不是 WAITER 状态时，这个else if为真</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, s | WAITER)) &#123; <span class="comment">// 尝试占据 WAITER 状态标识位</span></span><br><span class="line">                    waiting = <span class="keyword">true</span>; <span class="comment">// 表明自己正处于 WAITER 状态，并且让下一个被用于进入下一个 else if</span></span><br><span class="line">                    waiter = Thread.currentThread();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (waiting) <span class="comment">// 有线程持有 读锁（不会有线程持有 写锁），并且当前线程处于 WAITER 状态时，这个else if为真</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 阻塞自己</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从根节点开始遍历查找，找到“相等”的节点就返回它，没找到就返回null</span></span><br><span class="line">    <span class="comment">// 当有写线程加上 写锁 时，使用链表方式进行查找</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> s; K ek;</span><br><span class="line">                <span class="comment">// 两种特殊情况下以链表的方式进行查找</span></span><br><span class="line">                <span class="comment">// 1、有线程正持有 写锁，这样做能够不阻塞读线程</span></span><br><span class="line">                <span class="comment">// 2、WAITER时，不再继续加 读锁，能够让已经被阻塞的写线程尽快恢复运行，或者刚好让某个写线程不被阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                    e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, s + READER)) &#123; <span class="comment">// 读线程数量加1，读状态进行累加</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> : r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        Thread w;</span><br><span class="line">                        <span class="comment">// 如果这是最后一个读线程，并且有写线程因为 读锁 而阻塞，那么要通知它，告诉它可以尝试获取写锁了</span></span><br><span class="line">                        <span class="comment">// U.getAndAddInt(this, LOCKSTATE, -READER)这个操作是在更新之后返回lockstate的旧值，</span></span><br><span class="line">                        <span class="comment">//     不是返回新值，相当于先判断==，再执行减法</span></span><br><span class="line">                        <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) == (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                            LockSupport.unpark(w); <span class="comment">// 让被阻塞的写线程运行起来，重新去尝试获取 写锁</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用于实现ConcurrentHashMap.putVal</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                dir = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) || (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                    searched = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp; (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp; (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                dir = tieBreakOrder(k, pk);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">            <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">                first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                    f.prev = x;</span><br><span class="line">                <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                    xp.left = x;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    xp.right = x;</span><br><span class="line">                <span class="comment">// 下面是有关put加 写锁 部分</span></span><br><span class="line">                <span class="comment">// 二叉搜索树新添加的节点，都是取代原来某个的NIL节点（空节点，null节点）的位置</span></span><br><span class="line">                <span class="keyword">if</span> (!xp.red) <span class="comment">// xp是新添加的节点的父节点，如果它是黑色的，新添加一个红色节点就能够保证x这部分的一部分路径关系不变，</span></span><br><span class="line">                             <span class="comment">//     这是insert重新染色的最最简单的情况</span></span><br><span class="line">                    x.red = <span class="keyword">true</span>; <span class="comment">// 因为这种情况就是在树的某个末端添加节点，不会改变树的整体结构，对读线程使用红黑树搜索的搜索路径没影响</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 其他情况下会有树的旋转的情况出现，当读线程使用红黑树方式进行查找时，可能会因为树的旋转，导致多遍历、少遍历节点，影响find的结果</span></span><br><span class="line">                    lockRoot(); <span class="comment">// 除了那种最最简单的情况，其余的都要加 写锁，让读线程用链表方式进行遍历读取</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        root = balanceInsertion(root, x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        unlockRoot();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 基本是同jdk1.8的HashMap.TreeNode.removeTreeNode，仍然是从链表以及红黑树上都删除节点</span></span><br><span class="line">    <span class="comment">// 两点区别：1、返回值，红黑树的规模太小时，返回true，调用者再去进行树-&gt;链表的转化；2、红黑树规模足够，不用变换成链表时，进行红黑树上的删除要加 写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">removeTreeNode</span><span class="params">(TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; next = (TreeNode&lt;K,V&gt;)p.next;</span><br><span class="line">        TreeNode&lt;K,V&gt; pred = p.prev;  <span class="comment">// unlink traversal pointers</span></span><br><span class="line">        TreeNode&lt;K,V&gt; r, rl;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = next;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>)</span><br><span class="line">            next.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = root) == <span class="keyword">null</span> || r.right == <span class="keyword">null</span> || (rl = r.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) <span class="comment">// too small</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        lockRoot();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; replacement;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left;</span><br><span class="line">            TreeNode&lt;K,V&gt; pr = p.right;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    r = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    r = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            root = (p.red) ? r : balanceDeletion(r, replacement);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (p == replacement) &#123;  <span class="comment">// detach pointers</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp;</span><br><span class="line">                <span class="keyword">if</span> ((pp = p.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                    p.parent = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlockRoot();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 下面四个是经典的红黑树方法，改编自《算法导论》</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span></span>;</span><br><span class="line">    <span class="comment">// 递归检查一些关系，确保构造的是正确无误的红黑树</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span></span>;</span><br><span class="line">    <span class="comment">// Unsafe相关的初始化工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LOCKSTATE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = TreeBin.class;</span><br><span class="line">            LOCKSTATE = U.objectFieldOffset(k.getDeclaredField(<span class="string">&quot;lockState&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、ReservationNode：保留节点"><a href="#5、ReservationNode：保留节点" class="headerlink" title="5、ReservationNode：保留节点"></a>5、ReservationNode：保留节点</h3><p>或者叫空节点，computeIfAbsent和compute这两个函数式api中才会使用。它的hash值固定为-3，就是个占位符，不会保存实际的数据，正常情况是不会出现的，在jdk1.8新的函数式有关的两个方法computeIfAbsent和compute中才会出现。<br>为什么需要这个节点，因为正常的写操作，都会想对hash桶的第一个节点进行加锁，但是null是不能加锁，所以就要new一个占位符出来，放在这个空hash桶中成为第一个节点，把占位符当锁的对象，这样就能对整个hash桶加锁了。put/remove不使用ReservationNode是因为它们都特殊处理了下，并且这种特殊情况实际上还更简单，put直接使用cas操作，remove直接不操作，都不用加锁。但是computeIfAbsent和compute这个两个方法在碰见这种特殊情况时稍微复杂些，代码多一些，不加锁不好处理，所以需要ReservationNode来帮助完成对hash桶的加锁操作。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ReservationNode() &#123;</span><br><span class="line">        <span class="keyword">super</span>(RESERVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 空节点代表这个hash桶当前为null，所以肯定找不到“相等”的节点</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法与初始化"><a href="#构造方法与初始化" class="headerlink" title="构造方法与初始化"></a>构造方法与初始化</h2><p>下面是构造方法，不执行真正的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真的是什么也不做</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>)); <span class="comment">// 求 2^n</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;  <span class="comment">// 用这个重要的变量保存hash桶的接下来的初始化使用的容量</span></span><br><span class="line">    <span class="comment">// 不进行任何数组（hash桶）的初始化工作，构造方法进行懒初始化lazyInitialization</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// concurrencyLevel只是为了此方法能够兼容之前的版本，它并不是实际的并发级别，loadFactor也不是实际的加载因子了  sc = threshold，n - (n &gt;&gt;&gt; 2) = n - n/4 = 0.75n，前面说了loadFactor没用了，这里看出，统一用0.75f了</span></span><br><span class="line"><span class="comment">// 这两个都失去了原有的意义，仅仅对初始容量有一定的控制作用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>) <span class="comment">// 检查参数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)</span><br><span class="line">        initialCapacity = concurrencyLevel;</span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size); <span class="comment">// tableSizeFor，求不小于size的 2^n的算法，jdk1.8的HashMap中说过</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap; <span class="comment">// 用这个重要的变量保存hash桶的接下来的初始化使用的容量</span></span><br><span class="line">    <span class="comment">// 不进行任何数组（hash桶）的初始化工作，构造方法进行懒初始化lazyInitialization</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的初始化在iniTable()方法中，在put方法中有调用此方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真正的初始化方法，使用保存在sizeCtl中的数据作为初始化容量</span></span><br><span class="line"><span class="comment">// Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; <span class="comment">// Thread.yeild() 和 CAS 都不是100%和预期一致的方法，所以用循环，其他代码中也有很多这样的场景</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) <span class="comment">// 看前面sizeCtl这个重要变量的注释</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">                            <span class="comment">// 真正的初始化是要禁止并发的，保证tables数组只被初始化一次，但是又不能切换线程，所以用yeild()暂时让出CPU</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; <span class="comment">// CAS更新sizeCtl标识为 &quot;初始化&quot; 状态</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; <span class="comment">// 检查table数组是否已经被初始化，没初始化就真正初始化</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// sc = threshold，n - (n &gt;&gt;&gt; 2) = n - n/4 = 0.75n，前面说了loadFactor没用了，这里看出，统一用0.75f了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc; <span class="comment">// 设置threshold</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些基本的方法"><a href="#一些基本的方法" class="headerlink" title="一些基本的方法"></a>一些基本的方法</h2><p>下面这些方法逻辑都比较简单，是最基础的方法，很多地方都要用的下面这些方法，基本还是和1.8的HashMap，以及1.7的ConcurrentHashMap中的那些对应的基本方法差不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hash扰动函数，跟1.8的HashMap的基本一样，&amp; HASH_BITS用于把hash值转化为正数，负数hash是有特别的作用的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于求2^n，用来作为table数组的容量，同1.8的HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.8的HashMap中讲解红黑树相关的时候说过，用于获取Comparable接口中的泛型类</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 同1.8的HashMap，当类型相同且实现Comparable时，调用compareTo比较大小</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :  ((Comparable)k).compareTo(x)); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面几个用于读写table数组，使用Unsafe提供的更强的功能（数组元素的volatile读写，CAS 更新）代替普通的读写，调用者预先进行参数控制</span></span><br><span class="line"><span class="comment">// 方法功能，以及Unsafe的用法都基本同1.7</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// volatile读取table[i]</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CAS更新table[i]，也就是Node链表的头节点，或者TreeBin节点（它持有红黑树的根节点）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// volatile写入table[i]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 满足变换为红黑树的两个条件时（链表长度这个条件调用者保证，这里只验证Map容量这个条件），将链表变为红黑树，否则只是进行一次扩容操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// Map的容量不够时，只是进行一次扩容</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 规模不足时6把红黑树转化为链表，此方法由调用者进行synchronized加锁，所以这里不加锁</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(Node&lt;K,V&gt; b)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = b; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = <span class="keyword">new</span> Node&lt;K,V&gt;(q.hash, q.key, q.val, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="计数操作"><a href="#计数操作" class="headerlink" title="计数操作"></a>计数操作</h2><p>1.7及以前的ConcurrentHashMap中使用了Segment，Segment能够分担所有的针对单个K-V的写操作，包括put/replace。并且Segment自带一些数据，比如Segment.count，用于处理Map的计数要求，这样就可以像put/repalce一样，分担整个Map的并发计数压力。<br>但是1.8中没有再使用Segment来完成put/replace，虽然还是利用了锁分段的思想，但是使用的是自带的synchronized锁住hash桶中的第一个节点，没有新增别的数据。因此计数操作，被落下来了，它无法享受synchronized实现的变种分段锁带来的高效率，单独使用一个Map.size来计数，线程竞争可能会很大，比使用Segment是效率低很多。<br>为了处理这个问题，jdk1.8中使用了一个仿造LongAdder实现的计数器，让计数操作额外使用别的基于分段并发思想的实现的类。ConcurrentHashMap中不直接使用LongAdder，而是自己拷贝代码实现一个内部的，主要为了方便。LongAdder的实现本身代码不是特别多，ConcurrentHashMap中的实现，基本和LongAdder一样，可以直接看做是LongAdder。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>1.8的扩容可以多线程一起完成，因此扩容变得复杂了，但是效率提升了。这部分的内容比较多，分几点说下。</p>
<h3 id="1、一个transfer任务"><a href="#1、一个transfer任务" class="headerlink" title="1、一个transfer任务"></a>1、一个transfer任务</h3><p>对于一个大任务拆分成多个小任务供多线程执行，一般都要求这些小任务具有相似性，流程一致，并且很重要的一点，任务之间的相互影响尽量少。那么在扩容之中，是怎么划分这个任务的呢？<br>一般我们说的扩容，都包含两个步骤。第一，新建一个2倍大小的数组，这个过程要求单线程完成（多线程创建几个数组没有意义，容易出错），这个步骤每个HashMap、ConcurrentHashMap基本是都是同一套，前面我说过很多了，到这里没什么好说的了。第二步，执行节点迁移，说白了就是rehash，相当于把旧数组中所有的节点重新“put”到新数组中。在1.8的HashMap中，用了一个技巧，避免了重新根据hash值定位<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011392897/article/details/60151323">（可以看我写的这篇）</a>。根据这个，我们可以知道，进行 n -&gt; 2n 的扩容时，扩容前节点所在的hash桶的索引为index，这个节点迁移到新数组中只会有两种情况：要么在还是在新数组的索引为index处，要么迁移到新数组的索引为 index + n 的地方。所以旧的table数组上各个hash桶中的节点的迁移是不会互相影响的，这一点对多线程扩容非常有利。根据这一点，可以知道，每个hash桶的迁移都可以作为一个线程在扩容时的一个transfer任务。<br>另外，每个线程要任务都不应该规模太小，因为扩容并不是IO型操作，节点迁移的执行速度本身很快，太多的线程来执行节点迁移，线程调度开销占比变大，反而降低了吞吐量。ConcurrentHashMap这里，会根据CPU的核心数目，来算出一个transfer任务包含的hash桶的数量。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的代码用于计算每个transfer中要迁移多少个hash桶，一个transfer任务完成后，可以再次申请</span></span><br><span class="line"><span class="comment">//一个CPU有八个核心就可以创建8个线程 所以(n &gt;&gt;&gt; 3) / NCPU就代表每条线程的任务  n为2的n次幂</span></span><br><span class="line"><span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line"><span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">    stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br></pre></td></tr></table></figure>

<p>为了好说明，下面统一使用最小值MIN_TRANSFER_STRIDE，16，也就是1个线程的一次transfer任务要负责迁移16个hash桶。</p>
<h3 id="2、transfer任务的申请"><a href="#2、transfer任务的申请" class="headerlink" title="2、transfer任务的申请"></a>2、transfer任务的申请</h3><p>这个就是讲解transferIndex这个属性的作用。在经典的生成者消费者模式中，会有一个任务队列。消费者向任务队列申请任务，申请到任务时，队列中元素数量减1，当任务队列中元素数量为0时，不能再申请任务。ConcurrentHashMap这里并没有使用额外的任务队列，因为table数组本身就可以当作是一个队列。第一点中说了，一个transfer任务中要负责迁移stride个hash桶，最简单的设计当然是16个hash桶都是连续的。为了记录还有多少个任务，使用了一个类变量<strong>transferIndex</strong>，可以把这个看成是任务队列的size，每一次申请任务，这个size减1。<br>另外，迭代操作的下标是从小往大，也就是正向，为了减少扩容时的transfer和迭代的冲突，transfer使用反向，也就是下标从大到小。顺序相反时，二者相遇过后，迭代没处理的都是已经transfer的hash桶，transfer没处理的，都是已经迭代的hash桶，<strong>冲突会变少</strong>。<br>所以，任务队列的size减1，翻译过来就是，在table数组中的索引减stride。这个索引就是 transferIndex，用于标记整体的transfer进行到了哪里。因为transfer个数，从1开始，因此transferIndex也是从1开始，下标在**[transferIndex - 实际的stride（下界要 &gt;= 0）, transferIndex - 1]<strong>内的hash桶，就是每个transfer的任务区间。transferIndex &lt;= 0 时，代表没有任务可以申请，此时无法帮助扩容。注意，NCPU不一定是2^n，因此</strong>最后一个任务中的hash桶的数量可能不足stride个，此时只执行余下的数量。<strong>为了保证</strong>每个任务只被领取一次<strong>，</strong>transferIndex递减是用CAS**操作完成的。</p>
<p>特殊情况下，会出现<strong>多线程扩容重叠</strong>，此时某个transfer任务虽然被领取了，但是却不能被执行，会被作废。这是根据transfer方法的代码理解得带的，因为transfer方法的代码中有考虑任务作废的情况。但是根据下面第3点的分析，扩容重叠这种特殊情况是有一个机制来避免的。根据本人目前对代码的理解， 简而言之就是：代码中有处理扩容作废，但是实际不会发生。<br>下面简单画了个示意图。</p>
<p><img src="https://img-blog.csdn.net/20170305232906639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h3 id="3、resizeStamp以及扩容重叠相关"><a href="#3、resizeStamp以及扩容重叠相关" class="headerlink" title="3、resizeStamp以及扩容重叠相关"></a>3、resizeStamp以及扩容重叠相关</h3><p>为了好看，我把跟resizeStamp（以下简称rs）有关的代码片段都贴在一起，实际的代码就在下面的第4点中，可以对照看下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于生成每次扩容都唯一的生成戳的数，最小是6。很奇怪，这个值不是常量，但是也不提供修改方法。</span></span><br><span class="line"><span class="comment">/** The number of bits used for generation stamp in sizeCtl. Must be at least 6 for 32bit arrays. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 最大的扩容线程的数量，如果上面的 RESIZE_STAMP_BITS = 32，那么此值为 0，这一点也很奇怪。</span></span><br><span class="line"><span class="comment">/** The maximum number of threads that can help resize. Must fit in 32 - RESIZE_STAMP_BITS bits. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移位量，把生成戳移位后保存在sizeCtl中当做扩容线程计数的基数，相反方向移位后能够反解出生成戳</span></span><br><span class="line"><span class="comment">/** The bit shift for recording size stamp in sizeCtl. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 非常重要的一个属性，源码中的英文翻译，直译过来是下面的四行文字的意思</span></span><br><span class="line"><span class="comment">//     sizeCtl = -1，表示有线程正在进行真正的初始化操作</span></span><br><span class="line"><span class="comment">//     sizeCtl = -(1 + nThreads)，表示有nThreads个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment">//     sizeCtl &gt; 0，表示接下来的真正的初始化操作中使用的容量，或者初始化/扩容完成后的threshold</span></span><br><span class="line"><span class="comment">//     sizeCtl = 0，默认值，此时在真正的初始化操作中使用默认容量</span></span><br><span class="line"><span class="comment">// 但是，通过我对源码的理解，这段注释实际上是有问题的，</span></span><br><span class="line"><span class="comment">//     有问题的是第二句，sizeCtl = -(1 + nThreads)这个，网上好多都是用第二句的直接翻译去解释代码，这样理解是错误的</span></span><br><span class="line"><span class="comment">//********************************************************************</span></span><br><span class="line"><span class="comment">//********************************************************************</span></span><br><span class="line"><span class="comment">// 默认构造的16个大小的ConcurrentHashMap，只有一个线程执行扩容时，sizeCtl = -2145714174，</span></span><br><span class="line"><span class="comment">//     但是照这段英文注释的意思，sizeCtl的值应该是 -(1 + 1) = -2</span></span><br><span class="line"><span class="comment">//#################################你好，对于sizeCtl的那里，为什么是-2145714174而不是-2，我研究了一下。上面你在解释 RESIZE_STAMP_SHIFT 的时候，意思是把生成戳保存在sizeCtl的高16位作为扩容线程的基数，那么sizeCtl的低16位才是(1+nThreads)。//2145714174转化成2进制是111111111100100 1111111111111110，低16位刚好是-2的补码################确实是####################</span></span><br><span class="line"><span class="comment">//***************************************************************************</span></span><br><span class="line"><span class="comment">// sizeCtl在小于0时的确有记录有多少个线程正在执行扩容任务的功能，但是不是这段英文注释说的那样直接用 -(1 + nThreads)</span></span><br><span class="line"><span class="comment">// 实际中使用了一种生成戳，根据生成戳算出一个基数，不同轮次的扩容操作的生成戳都是唯一的，来保证多次扩容之间不会交叉重叠，</span></span><br><span class="line"><span class="comment">//     当有n个线程正在执行扩容时，sizeCtl在值变为 (基数 + n)</span></span><br><span class="line"><span class="comment">// 1.8.0_111的源码的383-384行写了个说明：A generation stamp in field sizeCtl ensures that resizings do not overlap.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table initialization and resizing control.</span></span><br><span class="line"><span class="comment"> * When negative, the table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment"> * else -(1 + the number of active resizing threads).</span></span><br><span class="line"><span class="comment"> * Otherwise, when table is null, holds the initial table size to use upon creation,</span></span><br><span class="line"><span class="comment"> * or 0 for default.</span></span><br><span class="line"><span class="comment"> * After initialization, holds the next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the stamp bits for resizing a table of size n.</span></span><br><span class="line"><span class="comment"> * Must be negative when shifted left by RESIZE_STAMP_SHIFT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 返回与扩容有关的一个生成戳rs，每次新的扩容，都有一个不同的n，这个生成戳就是根据n来计算出来的一个数字，n不同，这个数字也不同</span></span><br><span class="line"><span class="comment">// 另外还得保证 rs &lt;&lt; RESIZE_STAMP_SHIFT 必须是负数</span></span><br><span class="line"><span class="comment">// 这个方法的返回值，当且仅当 RESIZE_STAMP_SIZE = 32时为负数</span></span><br><span class="line"><span class="comment">// 但是b = 32时MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1 = 0，这一点很奇怪</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个if在addCount、helpTransfer、tryPresize中都有（可能会少一个条件，因为那个条件上文判断了），是理解这一点的重要的代码</span></span><br><span class="line"><span class="comment">// 实际看下代码，可以知道执行到这里时，sc（sc = sizeCtl）是一定小于0的</span></span><br><span class="line"><span class="comment">// 为真时会直接退出外层循环，然后退出方法</span></span><br><span class="line"><span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个在addCount、tryPresize中都有。实际看下代码，可以知道执行到这里时，sc 一定大于 0（等于0是初始化情况，可以不考虑）</span></span><br><span class="line"><span class="comment">// 为真时会进入transfer方法去执行扩容操作</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个在transfer方法中，条件为真时会 return 退出方法</span></span><br><span class="line"><span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看下resizeStamp方法。Integer.numberOfLeadingZeros(n)，是返回二进制表示中，前面有多少个连续的0。这里n是2的幂，假设n = 2^x，那么有 <strong>Integer.numberOfLeadingZeros(n) = 31 - x &lt; 32</strong>，二进制最高的27位都是0（n最小16）。并且它只跟n有关，n不同，这个运算的结果也不同。1 &lt;&lt; (RESIZE_STAMP_BITS - 1)，因为RESIZE_STAMP_BITS 最小是6，因此这个运算，在不考虑变成负数的情况下，最下是 1&lt;&lt; 5 = 32，二进制最低的5位都是0,。进行 | 运算后，可以知道<strong>二者的二进制不重叠，可以确定，n不同时，每个rs也不同</strong>。</p>
<p>接着看下这个 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))，这个是sizeCtl有关的。如果按照sizeCtl本身的注释，这里应该是把sc更新为sc - 1才对，这一点就说明它本身的注释是不准确的。为了防止扩容重叠，这里使用<strong>扩容生成戳</strong>进行了处理，尽量避免<strong>扩容重叠</strong>。扩容重叠改如何理解？为什么上面的这种对sizeCtl进行的处理（下面叫做resizeStamp机制）能避免扩容重叠？</p>
<hr>
<p>如果直接使用注释所说的，sizeCtl = -(1 + nThreads)，表示有nThreads个线程正在进行扩容操作，其他有关rs的代码也都不要，剩余的条件不变，那么会出现什么呢？代码变成了这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自addCount方法中触发扩容的代码</span></span><br><span class="line"><span class="comment">// 直接使用 -(1 + nThreads) 表示正在扩容的线程数时，去掉rs相关的代码，就变成了下面这样</span></span><br><span class="line"><span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">    <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc - <span class="number">1</span>))</span><br><span class="line">            transfer(tab, nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不清楚这些代码的预期执行顺序的，可以看下字节码，我截取了addCount方法的字节码的一部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">114</span> aload_0</span><br><span class="line"><span class="number">115</span> invokevirtual #<span class="number">30</span> &lt;java/util/concurrent/ConcurrentHashMap.sumCount&gt;</span><br><span class="line"><span class="number">118</span> lstore <span class="number">7</span></span><br><span class="line"><span class="number">120</span> iload_3</span><br><span class="line"><span class="number">121</span> iflt <span class="number">291</span> (+<span class="number">170</span>)</span><br><span class="line"><span class="number">124</span> lload <span class="number">7</span></span><br><span class="line"><span class="number">126</span> aload_0</span><br><span class="line"><span class="number">127</span> getfield #<span class="number">25</span> &lt;java/util/concurrent/ConcurrentHashMap.sizeCtl&gt;</span><br><span class="line"><span class="number">130</span> dup</span><br><span class="line"><span class="number">131</span> istore <span class="number">12</span></span><br><span class="line"><span class="number">133</span> i2l</span><br><span class="line"><span class="number">134</span> lcmp</span><br><span class="line"><span class="number">135</span> iflt <span class="number">291</span> (+<span class="number">156</span>)</span><br><span class="line"><span class="number">138</span> aload_0</span><br><span class="line"><span class="number">139</span> getfield #<span class="number">35</span> &lt;java/util/concurrent/ConcurrentHashMap.table&gt;</span><br><span class="line"><span class="number">142</span> dup</span><br><span class="line"><span class="number">143</span> astore <span class="number">9</span></span><br><span class="line"><span class="number">145</span> ifnull <span class="number">291</span> (+<span class="number">146</span>)</span><br><span class="line"><span class="number">148</span> aload <span class="number">9</span></span><br><span class="line"><span class="number">150</span> arraylength</span><br><span class="line"><span class="number">151</span> dup</span><br><span class="line"><span class="number">152</span> istore <span class="number">11</span></span><br><span class="line"><span class="number">154</span> ldc #<span class="number">4</span> &lt;<span class="number">1073741824</span>&gt;</span><br><span class="line"><span class="number">156</span> if_icmpge <span class="number">291</span> (+<span class="number">135</span>)</span><br><span class="line"><span class="number">159</span> iload <span class="number">11</span></span><br><span class="line"><span class="number">161</span> invokestatic #<span class="number">142</span> &lt;java/util/concurrent/ConcurrentHashMap.resizeStamp&gt;</span><br><span class="line"><span class="number">164</span> istore <span class="number">13</span></span><br><span class="line"><span class="number">166</span> iload <span class="number">12</span></span><br><span class="line"><span class="number">168</span> ifge <span class="number">252</span> (+<span class="number">84</span>)</span><br><span class="line"><span class="number">171</span> iload <span class="number">12</span></span><br><span class="line"><span class="number">173</span> getstatic #<span class="number">143</span> &lt;java/util/concurrent/ConcurrentHashMap.RESIZE_STAMP_SHIFT&gt;</span><br><span class="line"><span class="number">176</span> iushr</span><br><span class="line"><span class="number">177</span> iload <span class="number">13</span></span><br><span class="line"><span class="number">179</span> if_icmpne <span class="number">291</span> (+<span class="number">112</span>)</span><br><span class="line"><span class="number">182</span> iload <span class="number">12</span></span><br><span class="line"><span class="number">184</span> iload <span class="number">13</span></span><br><span class="line"><span class="number">186</span> iconst_1</span><br><span class="line"><span class="number">187</span> iadd</span><br><span class="line"><span class="number">188</span> if_icmpeq <span class="number">291</span> (+<span class="number">103</span>)</span><br><span class="line"><span class="number">191</span> iload <span class="number">12</span></span><br><span class="line"><span class="number">193</span> iload <span class="number">13</span></span><br><span class="line"><span class="number">195</span> getstatic #<span class="number">144</span> &lt;java/util/concurrent/ConcurrentHashMap.MAX_RESIZERS&gt;</span><br><span class="line"><span class="number">198</span> iadd</span><br><span class="line"><span class="number">199</span> if_icmpeq <span class="number">291</span> (+<span class="number">92</span>)</span><br><span class="line"><span class="number">202</span> aload_0</span><br><span class="line"><span class="number">203</span> getfield #<span class="number">145</span> &lt;java/util/concurrent/ConcurrentHashMap.nextTable&gt;</span><br><span class="line"><span class="number">206</span> dup</span><br><span class="line"><span class="number">207</span> astore <span class="number">10</span></span><br><span class="line"><span class="number">209</span> ifnull <span class="number">291</span> (+<span class="number">82</span>)</span><br><span class="line"><span class="number">212</span> aload_0</span><br><span class="line"><span class="number">213</span> getfield #<span class="number">146</span> &lt;java/util/concurrent/ConcurrentHashMap.transferIndex&gt;</span><br><span class="line"><span class="number">216</span> ifgt <span class="number">222</span> (+<span class="number">6</span>)</span><br><span class="line"><span class="number">219</span> goto <span class="number">291</span> (+<span class="number">72</span>)</span><br><span class="line"><span class="number">222</span> getstatic #<span class="number">13</span> &lt;java/util/concurrent/ConcurrentHashMap.U&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据字节码，Java中给这sc tab nt几个变量排列的执行顺序是，先执行sc = sizeCtl，判断 s&gt;=sc，再执行tab = table，判断tab != null，再执行nt = nextTable，判断nt == null。</p>
<p>假设有一个线程正在执行n -&gt; 2n 的扩容，那么sizeCtl = -2，此时一个线程，叫做线程A，来尝试帮助执行扩容（对照源码看，addCount方法的while循环，里面会先后读取sizeCtl、table、nextTable来给局部变量赋值，这中间可能会插入其他操作，导致局部变量的值是旧值）。</p>
<blockquote>
<p>A先执行sc= sizeCtl，此时得到sc = -2，这样判断sc &lt; 0会为真。再执行 tab = table，此时 n -&gt; 2n 的扩容还没完成，tab赋值为长度为n的数组。然后线程A一段时间不执行了，等它再次执行下一句，也就是赋值操作 nt = nextTable 时，n -&gt; 2n的扩容早就已经完成了，并且现在又有一个的线程正在执行 2n -&gt; 4n的扩容，此时sizeCtl仍然是-2，但是nt被赋值为长度为4n的数组。如果还有可以申请transfer任务，最后线程A就会进入transfer方法，此时它的tab长度为n，nt长度为4n。<br>如果transfer方法中碰到了这种情况（两个数组长度不满足2倍关系），它可能会让线程A申请到的任务直接作废，就算不是直接作废，因为线程A的tab中所有hash桶都已经被迁移完成了，这个任务实际也算是作废了。作废的任务会让最后一个退出扩容的线程来检查出来并处理掉，这是一个预防机制。<br>但是还有很重要的一点，按照上面的假设保证不了，那就是线程A一定不能成为最后一个退出扩容的线程，有两个原因：<br>1、A的tab的长度是n，实际扩容完成后，使用n重设下一次扩容阈值sizeCtl时，会让sizeCtl变成一个错误的值（正确值的一半，这个影响不太大，下次扩容就恢复了）；<br>2、A作为最后一个线程，它需要重新检查一次所有hash桶，这个是针对长度为n的tab来进行的。实际上tab中所有hash桶都被迁移完成了，检测tab没有意义。真正需要检查是的当下的table数组，它的长度为2n，因为线程A申请到的扩容任务作废了，当前的table数组中有一部分hash桶没有迁移，此时线程A最后检查一遍时，发现不了这个问题，也处理不了，导致扩容完成时有部分hash桶没有被迁移，发生了扩容错误。<br>所以必须不能让这个扩容重叠、参数错误的线程，成为最后一个退出扩容的线程。</p>
</blockquote>
<p>在使用 -(1 + nThreads) 表示有nThreads个线程正在进行扩容操作时，会出现上面描述的<strong>扩容重叠</strong>，导致发生错误，很大程度上还是因为CAS操作，因为<strong>CAS操作无法处理ABA问题</strong>。<u>直接使用-(1 + nThreads)表示正在执行扩容的线程数时，sizeCtl会经常是一些常见的数，不同的扩容中很容易出现相同的，这样会频繁发生ABA问题</u>。<br>因此不能直接像sizeCtl注释所说的，直接使用 -(1 + nThreads) 来表示正在执行扩容的线程数目。为了避免ABA问题导致的扩容重叠，应该让sizeCtl跟table数组的长度n绑定，并且sizeCtl能够反解出它对应的n，这样就能够保证这一轮的扩容跟另外一轮扩容，它们的执行过程中不可能出现相同的sizeCtl。</p>
<p>简单画了个图，可以看下。<br> <img src="https://img-blog.csdn.net/20170305233405098?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<hr>
<h4 id="Point-1"><a href="#Point-1" class="headerlink" title="Point 1"></a>Point 1</h4><p>前面说了，rs是跟n绑定的，不同的n有不同的rs，并且rs能够反解出唯一的n，这里不能直接使用rs，因为 sizeCtl 大于0时表示的是扩容阈值，因此需要把rs处理成负数，并且还要保证不同扩容之间不会出现相同的sizeCtl。这两个是依靠移位操作 rs &lt;&lt; RESIZE_STAMP_SHIFT 来完成的。</p>
<p>下面是一段不严格的数学证明，证明rs的有效性，能够避免 sizeCtl 出现 ABA 问题可能导致的扩容错误，这段证明只是为了解释源码中一些代码的有效性，不讨论为什么不用别的设计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（以下情况中都不考虑 b = <span class="number">32</span>的情况，b实际可以认为是常量）</span><br><span class="line">假设正在执行扩容的线程数量为nThreads，令b = RESIZE_STAMP_BITS，table.length = <span class="number">1</span> &lt;&lt; x，其中<span class="number">6</span> &lt;= b &lt;=<span class="number">32</span>，<span class="number">1</span> &lt;= x &lt;= <span class="number">30</span> ，那么有：</span><br><span class="line">RESIZE_STAMP_SHIFT = <span class="number">32</span> - b，rs = (<span class="number">31</span> - x) | (<span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>))，</span><br><span class="line">sizeCtl = sc = (rs &lt;&lt; (<span class="number">32</span> - b)) + <span class="number">1</span> + nThreads（后面都用sc，看下面的addCount的代码，sc &gt; <span class="number">0</span>时，尝试成为第一个扩容的线程的代码，+<span class="number">2</span>表示有一个，+<span class="number">1</span>表示有<span class="number">0</span>个），</span><br><span class="line">MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - b)) - <span class="number">1</span> &gt;= nThreads；</span><br><span class="line"> </span><br><span class="line">b &gt;= <span class="number">6</span>，那么(<span class="number">1</span> &lt;&lt; (b-<span class="number">1</span>)) &gt;= <span class="number">32</span>，并且它的二进制中只有一位是<span class="number">1</span>，(<span class="number">32</span> - b) + (b - <span class="number">1</span>) = <span class="number">31</span> &lt; <span class="number">32</span>，这样 rs = (<span class="number">31</span> - x) | (<span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>)) 中的 或运算 可以转化为加法（因为不会进位），rs的移位运算可以转化为两部分移位的和 ，所以移位运算</span><br><span class="line">(rs &lt;&lt; (<span class="number">32</span> - b)) = ((<span class="number">31</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)；</span><br><span class="line"> </span><br><span class="line">又因为<span class="number">31</span> - x &lt; <span class="number">32</span> = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)，<span class="number">32</span> - b &lt;= <span class="number">26</span>，所以((<span class="number">31</span> - x) &lt;&lt; (<span class="number">32</span> - b)) &lt; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)，(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) = Integer.MIN_VALUE， 所以(rs &lt;&lt; (<span class="number">32</span> - b))是负数，满足resizeStamp的设计；</span><br><span class="line"> </span><br><span class="line">好了，那么sc = (rs &lt;&lt; (<span class="number">32</span> - b)) + <span class="number">1</span> + nThreads = ((<span class="number">31</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + <span class="number">1</span> + nThreads，</span><br><span class="line">因为<span class="number">32</span> - x &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)，<span class="number">32</span> - b &lt;=<span class="number">26</span>，所以 ((<span class="number">32</span> - x) &lt;&lt; (<span class="number">32</span> - b)) 是正数，并且绝对值小于 (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)， sc 不可能出现负数溢出变正数的情况，此时sc &lt; <span class="number">0</span>；</span><br><span class="line">nThreads取最小值<span class="number">0</span>时，很明显也不可出现负数溢出，因此sc &lt; <span class="number">0</span>；</span><br><span class="line"> </span><br><span class="line">小结下，扩容完成前，使用rs时，sc总是负数，保证了基本的有效性；</span><br><span class="line"> </span><br><span class="line">sc反解出rs，通过反向移位就行</span><br><span class="line">sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT = sc &gt;&gt;&gt; (<span class="number">32</span> - b)，这种右移位是把操作数当做无符号数进行普通的右移位，负数移位会变成正数，本身就有sc &lt; <span class="number">0</span>，</span><br><span class="line">在加法不产生进位时，把和的移位当做移位的和，那么有：</span><br><span class="line">nThreads = <span class="number">0</span>时，(sc &gt;&gt;&gt; (<span class="number">32</span> - b)) = (rs &lt;&lt; (<span class="number">32</span> - b)) + <span class="number">1</span>) &gt;&gt; (<span class="number">32</span> - b) = rs，正常情况（不发生扩容重叠）一定有 (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) &gt;= rs；</span><br><span class="line">nThreads = MAX_RESIZERS时，(sc &gt;&gt;&gt; (<span class="number">32</span> - b)) = (((<span class="number">31</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + <span class="number">1</span> + (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - b)) - <span class="number">1</span>) &gt;&gt;&gt; (<span class="number">32</span> - b) = rs + <span class="number">1</span>，因此正常情况（不发生扩容重叠）下一定有(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) &lt;= rs + <span class="number">1</span>，当且仅当扩容线程为最大数时取等号；</span><br><span class="line"> </span><br><span class="line">再分析下 sc 的在每轮不同的扩容中的唯一性（这里没证明单调性）</span><br><span class="line">sc 的值域为 [ ((<span class="number">31</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + <span class="number">1</span>, ((<span class="number">31</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - b)) ]；</span><br><span class="line">另 x = x + <span class="number">1</span>，也就是进行下一轮扩容，那么 sc 的值域变为 [ ((<span class="number">30</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + <span class="number">1</span>, ((<span class="number">30</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - b)) ]；</span><br><span class="line">加法不进位时把移位的和当作和的移位，上界进行移位合并，那么x + <span class="number">1</span>时的值域为 [ ((<span class="number">30</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + <span class="number">1</span>, ((<span class="number">31</span> - x) &lt;&lt; (<span class="number">32</span> - b)) + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) ]；</span><br><span class="line">很明显，x+<span class="number">1</span>时上界，比x时的下界小<span class="number">1</span>，所以两个值域中sc不可能相等；</span><br><span class="line">这也就是说，n -&gt; 2n扩容中的sc的任何可能取值，总是大于 2n -&gt; 4n时sc的任何可能取值，</span><br><span class="line">因此sizeCtl具有扩容唯一性，每轮扩容的sizeCtl，都不可能和别的轮次的扩容的sizeCtl相同</span><br><span class="line"> </span><br><span class="line">那么 sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT 呢，这个就有点特殊了</span><br><span class="line">x时，移位后的值域为 [ (<span class="number">31</span> - x) + (<span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>)), (<span class="number">32</span> - x) + (<span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>))]；</span><br><span class="line">x+<span class="number">1</span>时，移位后的值域为 [ (<span class="number">30</span> - x) + (<span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>)), (<span class="number">31</span> - x) + (<span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>))];</span><br><span class="line">两者有一个重叠点。</span><br><span class="line">这时可能会绕过(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs这个条件的检验，但是此时sc是不一样的，后面CAS更新时，依然不能使用旧的sc的值。</span><br><span class="line"> </span><br><span class="line">综合上面所说的，resizeStamp这个机制，能够避免sc = sizeCtl在不同轮次的扩容中出现ABA问题，进而避免 扩容重叠 问题出现。</span><br><span class="line">特别的一点，b = <span class="number">32</span>这种极端情况下，resizeStamp机制会受到影响，并且MAX_RESIZERS = <span class="number">0</span>。那么这个b = <span class="number">32</span>应该是不会发生的，但是<span class="number">5</span>个条件的<span class="keyword">if</span>中又有处理b = <span class="number">32</span>的情况，又是一处代码跟实际不太对的上的情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Point-2"><a href="#Point-2" class="headerlink" title="Point 2"></a>Point 2</h4><p>下面再谈谈那5个条件的if，也就是这句 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0)  （<strong>这个if在addCount、helpTransfer、tryPresize中都有，可能会少一个条件，因为那个条件上文判断了</strong>）<br>从简单的开始分析：</p>
<blockquote>
<p>A、(nt = nextTable) == null：表示整个扩容过程已经结束，或者扩容过程处于一个单线程的阶段（transfer方法中创建nextTable是由单线程完成的），此时不能帮助扩容。<br>B、transferIndex &lt;= 0：表示所有的transfer任务都被领取光了，没有剩余的hash桶给自己这个线程来transfer，此时线程不能再帮助扩容了。<br>C、(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs：上面的那个证明中，有两个结论，<br>“正常情况（不发生扩容重叠）下一定有(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) &lt;= rs + 1，当且仅当扩容线程为最大数时取等号”，<br>“正常情况（不发生扩容重叠）下一定有 (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) &gt;= rs ”<br>rs + 1时是个特殊情况，此时扩容线程为最大值，是一定不能帮助扩容的。其他情况下等价于“正常情况（不发生扩容重叠）下一定有(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs ”<br>所以它可以看成是一个<strong>恒等式</strong>，正常情况下if中的这个判断条件一定为false。为true则表明sc 和 tab.length 对不上，不能互相反解，<strong>继续下去有可能发生扩容重叠</strong>。因此为true时也不能帮助扩容，这个条件放在第一位置也是有道理的，它最先避免了扩容重叠的发生。<br>D、sc == rs + 1：这一个条件很奇怪，根据上下文，sc在这里一定是负数，rs只有当RESIZE_STAMP_BITS = 32时才是负数，此时MAX_RESIZERS = 0。<br>RESIZE_STAMP_BITS是static变量，但不是常量，也不提供任何更改它的途径。当取最大值32时，RESIZE_STAMP_SHIFT = 0，那么rs &lt;&lt; RESIZE_STAMP_SHIFT = rs，这样这个条件就好理解了。<br>第一次分配transfer任务时，把正在扩容线程数加1的操作是U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)， +2代表有1个，+1代表有0个。再根据上下文，可以认为是此时此刻transfer任务都被执行完成了，本轮扩容操作实际上已经结束了。<br>E、有和D一样的疑问，那就是，sc在这里一定是负数，rs只有当RESIZE_STAMP_BITS = 32时才是负数，rs + MAX_RESIZERS也只有当RESIZE_STAMP_BITS = 32时才是负数，此时MAX_RESIZERS = 0。<br>而且逻辑上感觉用 sc == rs + MAX_RESIZERS + 1 才是对的啊。</p>
<p>############</p>
<p><a target="_blank" rel="noopener" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427">JDK-8214427 : probable bug in logic of ConcurrentHashMap.addCount()</a>  The correct condition should be (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + 1 ||  (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS,  which can be used to dedect if resizing process finished or resizing threads reaches maxmium limitation </p>
<p><strong>太牛逼了</strong></p>
</blockquote>
<p>所以，目前ABC都有了合理解释，DE在目前的情况下，不能给出太合理的解释，只能认为它们两个是为了处理极端的 RESIZE_STAMP_BITS = 32的情况。在实际情况中，没有提供途径去修改 RESIZE_STAMP_BITS 的值，这样D和E一定是false。在这个层面上，可以认为它们两个没啥用。</p>
<hr>
<p>根据上面的分析，使用resizeStamp这个机制，可以检查sc是否和tab.length匹配，并且可以避免sizeCtl 的ABA问题，进而可以避免 扩容重叠 的发生。<br>现在还有一个疑问，既然使用这个机制能避免 扩容重叠 的发生，那么transfer方法（第4点中讲）中为什么还要自己处理下一部分扩容重叠的情况？<br>这一点我暂时还没看明白。可能只是为了保险，可能transfer方法最后那个检查本身就不针对扩容重叠只是单纯的检查，也可能是我第3点第4点的分析漏了什么。</p>
<hr>
<h3 id="4、扩容代码"><a href="#4、扩容代码" class="headerlink" title="4、扩容代码"></a>4、扩容代码</h3><p>这部分有了前面3点的基础，代码就基本上看得懂了，要说的都写在注释中了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更改计数值，这部分相关是仿造LongAdder实现的，已经说过了</span></span><br><span class="line"><span class="comment">// 检查是否触发了扩容，是否正在扩容，是否可以帮助扩容</span></span><br><span class="line"><span class="comment">// 并且还要检查是否会触发下一次扩容，因为更改计数值的操作是不在加锁区域内的，扩容过程中可能还有别的线程添加了很多K-V</span></span><br><span class="line"><span class="comment">// 参数check，用于指示计数操作是否会触发扩容，check &lt; 0 代表一定不会触发，比如remove的时候</span></span><br><span class="line"><span class="comment">//     check &lt;= 1时，只在没有计数时线程竞争才会触发扩容，check &gt; 0 时，也表示的是hash桶中节点的数目</span></span><br><span class="line"><span class="comment">// 普通的put可能会触发，Map拷贝构造中的putAll，因为事先扩容了，所以这个putAll不会触发扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先按照LongAdder实现，把计数器的值变更，已经说过了</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> || !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>) <span class="comment">// 执行到这里，说明线程更新计数值时没有遇到线程竞争（cells != null已经被初始化），</span></span><br><span class="line">                        <span class="comment">//     check == 1时表示hash桶中原本只有一个节点，规模比较小，这次添加先不扩容</span></span><br><span class="line">            <span class="keyword">return</span>;     <span class="comment">// 暂时觉得是这样，因为put和1.7的HashMap一样，走实用路线了，添加的是hash桶第一个节点时，</span></span><br><span class="line">                        <span class="comment">//     一定不扩容（后面将put时说）。当然这个解释感觉还是比较牵强。</span></span><br><span class="line">                        <span class="comment">// 如果觉得这一点有疑问，麻烦大神指出来，谢谢了！</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123; <span class="comment">// 检测是否扩容</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 这里在第3点中详细说了，三个连续的赋值中间可能会插入其他线程的代码，改变了某些值，造成三个局部变量最后不匹配，出现扩容重叠</span></span><br><span class="line">        <span class="comment">// 使用resizeStamp机制避免了这种扩容重叠</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; <span class="comment">// 扩容的基础条件</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n); <span class="comment">// 计算本次扩容生成戳</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123; <span class="comment">// sc &lt; 0 表明此时有别的线程正在进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>) <span class="comment">// 根据前面第3点分析的，这5个条件中主要有一个为true，就说明当前线程不能帮助此次扩容</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 不能帮助，直接结束</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) <span class="comment">// 不满足前面5个条件时，尝试参与此次扩容，把正在执行transfer任务的线程数加1</span></span><br><span class="line">                    transfer(tab, nt); <span class="comment">// 去帮助执行transfer任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 试着让自己成为第一个执行transfer任务的线程，这个位运算前面分析了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>); <span class="comment">// 去执行transfer任务</span></span><br><span class="line">            s = sumCount(); <span class="comment">// 重新计数，判断是否需要开启下一轮扩容</span></span><br><span class="line">            <span class="comment">// 上面两个进入transfer方法的地方，都是把sizeCtl自增，这一点足够说明sizeCtl的英文注释表达的意思有误</span></span><br><span class="line">            <span class="comment">// 如果是 -(1 + nThreads) 表示，那么应该用减1，实际情况用的是加1</span></span><br><span class="line">            <span class="comment">// 代码中的加2，是因为逻辑中是用(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1代表现在有0个线程</span></span><br><span class="line">            <span class="comment">// 下面的transfer方法中退出方法前的操作，也足够说明“sizeCtl注释错误”这一点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**Helps transfer if a resize is in progress. */</span></span><br><span class="line"><span class="comment">// 如果正在进行扩容，则尝试去帮助执行transfer任务，此方法都是在循环中被调用，因此本身不用处理接连两次扩容的情况，这种情况在外部调用中处理</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 判断此时是否仍然在执行扩容（这几个变量改变了，说明此次扩容结束了)</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length); <span class="comment">// 计数本次扩容的生成戳</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123; <span class="comment">// 在判断一次是否正在执行扩容（这几个变量的值改变了，说明此次扩容结束了）</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>) <span class="comment">// 判断下是否能真正帮助此次扩容（这4个条件前面说了，少了的那一个不用前面判断了）</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 不能帮助，直接结束</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123; <span class="comment">// 不满足前面4个条件时，尝试参与此次扩容，把正在执行transfer任务的线程数加1</span></span><br><span class="line">                transfer(tab, nextTab); <span class="comment">// 去帮助执行transfer任务</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab; <span class="comment">// 返回新数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table; <span class="comment">// 返回新数组（执行这句说明一开始判断，就发现变量变化了，表明扩容已经结束了，table会被别的线程赋值为新数组）</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Tries to presize table to accommodate the given number of elements. */</span></span><br><span class="line"><span class="comment">// 预先扩容，就是一个包含了初始化逻辑的扩容</span></span><br><span class="line"><span class="comment">// 用于putAll，此时是需要考虑初始化；链表转化为红黑树中，不满足table容量条件时，进行一次扩容，此时就是普通的扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123; <span class="comment">// 这个if用于处理初始化，跟initTable方法基本一样</span></span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) <span class="comment">// c &lt;= sc，说明已经被扩容过了；n &gt;= MAXIMUM_CAPACITY说明table数组已经到了最大长度</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123; <span class="comment">// 可以扩容</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n); <span class="comment">// 计算本次扩容的生成戳</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123; <span class="comment">// sc &lt; 0 表明此时有别的线程正在进行扩容</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>) <span class="comment">// 这5个条件前面说了，用于判断是否能真正去帮助执行transfer任务</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 不能帮助，直接结束</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) <span class="comment">// 尝试参与此次扩容，把正在执行transfer任务的线程数加1</span></span><br><span class="line">                    transfer(tab, nt); <span class="comment">// 去帮助执行transfer任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 试着让自己成为第一个执行transfer任务的线程，这个位运算前面分析了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>); <span class="comment">// 去执行transfer任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行节点迁移，准确地说是迁移内容，因为很多节点都需要进行复制，复制能够保证读操作尽量不受影响</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 计算每个transfer任务中要负责迁移多少个hash桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating 创建新数组</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123; <span class="comment">// try to cope with OOME 处理内存不足导致的OOM，以及table数组超过最大长度，这两种情况都实际上无法再进行扩容了</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n; <span class="comment">// 表明此时执行扩容的线程可以开始申请transfer任务了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 转发节点，在旧数组的一个hash桶中所有节点都被迁移完后，放置在这个hash桶中，表明已经迁移完，对它的读操作会转发到新数组</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 扩容中收尾的线程把做个值设置为true，进行本轮扩容的收尾工作（两件事，重新检查一次所有hash桶，给属性赋新值）</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// while中的代码可以看成是预处理</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing) <span class="comment">// 一次transfer任务还没有执行完毕</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123; <span class="comment">// transfer任务已经没有了，表明可以准备退出扩容了</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123; <span class="comment">// 尝试申请一个transfer任务</span></span><br><span class="line">                <span class="comment">// 申请到任务后标记自己的任务区间</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个分支中有处理 扩容重叠，但是前面第3点分析了，到这里应该是不会出现扩容重叠的</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">// i &lt; 0 表明本次的transfer任务已经执行完毕了，此时需要准备退出这个方法，这个好理解</span></span><br><span class="line">            <span class="comment">// i &gt;= n 表明扩容轮次跟预想的不一样（比如这个线程预想的是进行n -&gt; 2n的扩容，实际nextTab是4n数组），此时不能进行节点迁移（第3点分析了一部分）</span></span><br><span class="line">            <span class="comment">//     虽然申请到了任务，但是也不能执行，应该准备退出方法，此次任务作废，别的线程也不能领取了，只能让此轮扩容中最后一个线程在重新检查时处理掉</span></span><br><span class="line">            <span class="comment">// i + n &gt;= nextn，这个我不知道怎么理解，此时前面两个条件为false，那么就有 0 &lt; i &lt; n，也就是 n &lt; i + n &lt; 2n，这个是一定成立的</span></span><br><span class="line">            <span class="comment">//     因为nextn最小也是2n，i + n 怎么也比2n小，所以我觉得奇怪，不知道这个条件判断的是什么情况</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 执行本轮扩容的收尾工作</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123; <span class="comment">// 尝试把正在执行扩容的线程数减1，表明自己要退出扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) <span class="comment">// 判断下自己是不是本轮扩容中的最后一个线程，如果不是，则直接退出。</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 如果自己是本轮扩容中的最后一个线程，那么要准备执行收尾工作了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit 最后一个扩容的线程要重新检查一次旧数组的所有hash桶，看是否是都被正确迁移到新数组了。</span></span><br><span class="line">                       <span class="comment">// 正常情况下，重新检查时，旧数组所有hash桶都应该是转发节点，此时这个重新检查的工作很快就会执行完。</span></span><br><span class="line">                       <span class="comment">// 特殊情况，比如扩容重叠，那么会有线程申请到了transfer任务，但是参数错误（旧数组和新数组对不上，不是2倍长度的关系），</span></span><br><span class="line">                       <span class="comment">// 此时这个线程领取的任务会作废，那么最后检查时，还要处理因为作废二没有被迁移的hash桶，把它们正确迁移到新数组中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>) <span class="comment">// hash桶本身为null，不用迁移，直接尝试安放一个转发节点</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 正常情况下，重新检查时，总是执行这个分支。</span></span><br><span class="line">                                         <span class="comment">// 出现扩容重叠，有transfer任务被作废的情况下，会执行其他分支，处理因为作废而没有被迁移的hash桶</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 给f加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 判断下加锁的节点仍然是hash桶中的第一个节点，加锁的是第一个节点才算加锁成功</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这段代码，使用高低位，跟1.6/1.7的使用 &amp; 的效果基本一样</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">// 尽量重用Node链表尾部的一部分（起码能重用一个，实际情况下能重用比较多的节点，这时候就提高了效率）</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123; <span class="comment">// 重用的是“低位”</span></span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 重用的是“高位”</span></span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln); <span class="comment">// 放在新table的hash桶中</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn); <span class="comment">// 放在新table的hash桶中</span></span><br><span class="line">                        setTabAt(tab, i, fwd); <span class="comment">// 把旧table的hash桶中放置转发节点，表明此hash桶已经被处理</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的情况，先使用链表的方式遍历，复制所有节点，根据高低位（1.8的HashMap中的做法)，</span></span><br><span class="line">                        <span class="comment">//     组装成两个链表，然后看下是否需要进行红黑树变换，最后放在新数组对应的hash桶中</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123; <span class="comment">// 低位</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123; <span class="comment">// 高位</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只读遍历器Traverser"><a href="#只读遍历器Traverser" class="headerlink" title="只读遍历器Traverser"></a>只读遍历器Traverser</h2><p>之前版本的ConcurrentHashMap，都有使用Segment带代理分担各种操作，对它进行写操作会首先加锁，Segment扩容都是在写操作中触发的，因此扩容时一定加了锁。它们的Segment的扩容也是单线程的，进行节点复制并迁移，不会更改当前的数组的任何地方（重用的节点不用复制，但是也不会产生更改） 。也就是在扩容期间，Segment是不会有任何更改的，中间无论对这个Segment发生多少次读操作，都不受正在进行的扩容的影响，都会看到一致的结果（因为没有全局锁，Map的遍历还是不具有一致性，期间可能会看到写操作的更改）。<br>1.8版本的扩容，采用了多线程扩容，并且很重要的一点，那就是扩容会对当前的table数组进行更改，<strong>扩容时会在transfer完一个hash桶中的所有节点后，把一个转发节点安放进去</strong>。这会影响正在进行的读操作。普通的读操作只读去一个hash桶中的内容，containsValue这种就会遍历读取所有hahs桶，此时就不能使用之前版本的那种什么都不考虑的遍历读，因为此时读会跨越两个数组进行。<br>因此写了这个内部类，它考虑了遍历读与扩容并发的情况，专门处理1.8版本中的遍历读。</p>
<p>处理的逻辑很简单，<strong>就是碰到ForwardingNode时，保存当前正在遍历的数组以及索引信息，然后在FN.nextTable上进行遍历</strong>。如果继续碰到FN，就再保存一份信息，跳转到下下个数组进行hash桶节点的遍历。遍历完成后，返回最近一次记录的数组进行遍历，并清除掉最近一次保存的信息。这种行为跟<strong>入栈出栈</strong>很像，因此可以使用栈结构来保存。<br>这就是<strong>TableStack</strong>的由来，它是一个简化的栈，使用链表表示的。<u><em>入栈就是在链表当前头结点的前面插入一个节点，并把头结点指针指向当前节点；出栈就是删除当前的头结点，把头结点指针指向删除的节点后面的一个节点</em></u>。<br>根据transfer的性质，在FN.nextTable上进行的一次遍历只用遍历两个hash桶，index 以及 index + index。在一次出栈操作执行前，需要遍历完这两个hash桶。这里简单看下代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TableStack</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    TableStack&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Traverser</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;        <span class="comment">// current table; updated if resized，当前数组，也就是扩容完成后的旧数组</span></span><br><span class="line">    Node&lt;K,V&gt; next;         <span class="comment">// the next entry to use， 新数组，扩容完成后使用的数组</span></span><br><span class="line">    TableStack&lt;K,V&gt; stack, spare; <span class="comment">// to save/restore on ForwardingNodes， 用来 保存/恢复 转发节点</span></span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">// index of bin to use next，下一个要读取的hash桶的下标</span></span><br><span class="line">    <span class="keyword">int</span> baseIndex;          <span class="comment">// current index of initial table，起始的下标，下界</span></span><br><span class="line">    <span class="keyword">int</span> baseLimit;          <span class="comment">// index bound for initial table，终止的下标，上界</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> baseSize;     <span class="comment">// initial table size table，数组的长度</span></span><br><span class="line"> </span><br><span class="line">    Traverser(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> size, <span class="keyword">int</span> index, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tab = tab;</span><br><span class="line">        <span class="keyword">this</span>.baseSize = size;</span><br><span class="line">        <span class="keyword">this</span>.baseIndex = <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.baseLimit = limit;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Advances if possible, returning next valid node, or null if none. */</span></span><br><span class="line">    <span class="comment">// 遍历器的指针往前移动到下一个有实际数据节点，并返回这个节点，如果到头就返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = next) != <span class="keyword">null</span>) <span class="comment">// 如果已经进入了一个非空的hash桶，直接尝试获取它的下一个节点</span></span><br><span class="line">            e = e.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t; <span class="keyword">int</span> i, n;  <span class="comment">// must use locals in checks</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) <span class="comment">// 节点非null，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> next = e;</span><br><span class="line">            <span class="comment">// 一些边界判断，遍历越界了表明没有了，可以直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (baseIndex &gt;= baseLimit || (t = tab) == <span class="keyword">null</span> || (n = t.length) &lt;= (i = index) || i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((e = tabAt(t, i)) != <span class="keyword">null</span> &amp;&amp; e.hash &lt; <span class="number">0</span>) &#123; <span class="comment">// 处理特殊节点</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123; <span class="comment">// 转发节点，主要处理这个</span></span><br><span class="line">                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable; <span class="comment">// 将遍历迁移到FN.nextTable新数组上进行</span></span><br><span class="line">                    e = <span class="keyword">null</span>;</span><br><span class="line">                    pushState(t, i, n); <span class="comment">// 入栈保存当前对tab数组的遍历信息</span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 开始新一次循环，遍历nextTable中对应的hash桶</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeBin) <span class="comment">// TreeBin时，获取红黑树所有节点的链表形式的头节点，使用链表的方式遍历，更简单</span></span><br><span class="line">                    e = ((TreeBin&lt;K,V&gt;)e).first;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 保留节点，没实际数据</span></span><br><span class="line">                    e = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack != <span class="keyword">null</span>) <span class="comment">// 栈不为空</span></span><br><span class="line">                recoverState(n); <span class="comment">// 这里可以看做是出栈操作，得先遍历完FN.nextTable中的两个之后再出栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((index = i + baseSize) &gt;= n) <span class="comment">// 栈为空，准备遍历下一个hash桶</span></span><br><span class="line">                index = ++baseIndex; <span class="comment">// visit upper slots if present</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Saves traversal state upon encountering a forwarding node. */</span></span><br><span class="line">    <span class="comment">// 入栈操作，保存当前对tab的遍历信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushState</span><span class="params">(Node&lt;K,V&gt;[] t, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        TableStack&lt;K,V&gt; s = spare;  <span class="comment">// reuse if possible</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            spare = s.next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s = <span class="keyword">new</span> TableStack&lt;K,V&gt;();</span><br><span class="line">        s.tab = t;</span><br><span class="line">        s.length = n;</span><br><span class="line">        s.index = i;</span><br><span class="line">        s.next = stack;</span><br><span class="line">        stack = s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Possibly pops traversal state. */</span></span><br><span class="line">    <span class="comment">// 可能会出栈，不出栈时，更改索引，准备遍历的是FN.nextTable中对应的第二个hash桶</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        TableStack&lt;K,V&gt; s; <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((s = stack) != <span class="keyword">null</span> &amp;&amp; (index += (len = s.length)) &gt;= n) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            index = s.index;</span><br><span class="line">            tab = s.tab;</span><br><span class="line">            s.tab = <span class="keyword">null</span>;</span><br><span class="line">            TableStack&lt;K,V&gt; next = s.next;</span><br><span class="line">            s.next = spare; <span class="comment">// save for reuse</span></span><br><span class="line">            stack = next;</span><br><span class="line">            spare = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; (index += baseSize) &gt;= n)</span><br><span class="line">            index = ++baseIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20170305234602813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>看完上面的几点，基本方法就非常好理解了，下面一个个过下。</p>
<h3 id="1、基本的读操作"><a href="#1、基本的读操作" class="headerlink" title="1、基本的读操作"></a>1、基本的读操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// size方法就是调用sunCount进行计数器值汇总，然后处理下int溢出的问题</span></span><br><span class="line"><span class="comment">// 特别的，基于HashMap这类依据hash表+链地址法实现的Map，可能会存在实际size比table数组大的情况，因此也可能出现大于Integer.MAX_VALUE的情况</span></span><br><span class="line"><span class="comment">// 返回值是int型是历史遗留，这里只能兼容处理，返回一个错误但是“尽量有用”的值</span></span><br><span class="line"><span class="comment">// 准确的应该是使用mappingCount方法，但是它是1.8才新增的，旧的代码享受不到这个改正了，新代码应该中尽量使用mappingCount</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values 这里，clear方法可能导致计数值临时为负数的情况，不过不影响这个方法的使用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// hash桶不为empty时才有必要查找，定位hash桶还是熟悉的方式</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;  (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">// 特殊判断第一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// hash桶的第一个节点的hash值小于0，代表它是特殊节点，使用特化的查找方式进行查找</span></span><br><span class="line">                         <span class="comment">// ForwardingNode会把find转发到nextTable上再去执行一次；</span></span><br><span class="line">                         <span class="comment">// TreeBin则根据自身读写锁情况，判断是用红黑树方式查找，还是用链表方式查找；</span></span><br><span class="line">                         <span class="comment">// ReservationNode本身只是为了synchronized有加锁对象而创建的空的占位节点，因此本身hash桶是没节点的，一定找不到，直接返回null）</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 是普通节点，使用链表方式查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) <span class="comment">// 这个条件在我写的678的HashMap中说过几次了，这里就不说了</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用Traverser进行只读遍历</span></span><br><span class="line"><span class="comment">// 因为此操作会遍历所有hash桶，但是不使用全局锁，因此返回的结果不是最新的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    <span class="keyword">if</span> ((t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Traverser&lt;K,V&gt; it = <span class="keyword">new</span> Traverser&lt;K,V&gt;(t, t.length, <span class="number">0</span>, t.length);</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p; (p = it.advance()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> ((v = p.val) == value || (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of mappings. This method should be used</span></span><br><span class="line"><span class="comment">     * instead of &#123;<span class="doctag">@link</span> #size&#125; because a ConcurrentHashMap may</span></span><br><span class="line"><span class="comment">     * contain more mappings than can be represented as an int. The</span></span><br><span class="line"><span class="comment">     * value returned is an estimate; the actual count may differ if</span></span><br><span class="line"><span class="comment">     * there are concurrent insertions or removals.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 上面说了，size方法可能会超出int型，而返回不正确的结果，这个方法就是用来替代size的，1.8才新增的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.8新增的一个好用的方法，真的很好用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (v = get(key)) == <span class="keyword">null</span> ? defaultValue : v;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> containsValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、基本的写操作"><a href="#2、基本的写操作" class="headerlink" title="2、基本的写操作"></a>2、基本的写操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 处理null</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>; <span class="comment">// 只使用链表保存时，此变量可以看出是添加新节点前，这个hash桶中所有保存实际数据的节点数目；</span></span><br><span class="line">                      <span class="comment">//     红黑树保存时，固定为2，保证put后更改计数值时能够进行扩容检查，同时不触发红黑树化操作</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 处理初始化，并发的情况在initTable中处理，这里不考虑</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,  <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) <span class="comment">// 使用CAS添加第一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 发现转发节点，表明此时正在进行扩容，去帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 锁住f</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 保证锁住的是hash桶的第一个节点，这样阻止其他写操作进入，如果锁住的不是第一个节点，那么重新开始循环</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>; <span class="comment">// 因为第一个节点处理了，这里赋值为1</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到“相等”的节点，看看是否需要更新value的值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;  ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 遍历到链表末尾还没碰见“相等”，那么就添加新节点到链表的末尾</span></span><br><span class="line">                            <span class="comment">// 1.8开始是末尾添加，后面的remove/replace也会尝试锁住第一个节点，这样就能保证锁住hash桶的第一个节点能够阻塞其他基本的写操作</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,  value, <span class="keyword">null</span>); </span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树就使用红黑树的方式进行添加</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>; <span class="comment">// 设置为2，保证addCount中能够进行扩容判断，同时也不会触发链表转化为红黑树的操作</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,  value)) != <span class="keyword">null</span>) &#123; </span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">// 添加之前，一个hash桶中的节点数目达到阈值，尝试转化为红黑树保存</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) <span class="comment">// 表明实质上是replace操作，不用更改计数值</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount); <span class="comment">// 计数值加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 预先扩容，循环put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    tryPresize(m.size());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        putVal(e.getKey(), e.getValue(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation for the four public remove/replace methods:</span></span><br><span class="line"><span class="comment"> * Replaces node value with v, conditional upon match of cv if non-null.  If resulting value is null, delete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// remove删除，可以看成是用null替代原来的节点，因此合并在这个方法中，由这个方法一起实现remove/replace</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> || (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) <span class="comment">// 没有节点，删除不了，直接退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 发现转发节点，表明此时正在进行扩容，去帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 这里跟put一样，尝试锁住hash桶的第一个结点，要保证锁住的是第一个结点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;  ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||  (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123; </span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next); <span class="comment">// 删除的是第一个节点，就重设第一个节点，此时相当于已经释放了锁</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 处理红黑树的情况</span></span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp; (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||  (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123; </span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p)) <span class="comment">// 处理退化为链表的情况</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面这一段判断是否是删除操作，是删除操作就把计数值减1</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Removes all of the mappings from this map. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> delta = <span class="number">0L</span>; <span class="comment">// negative number of deletions 计数值的预期变化值，删除n个，delta就为-n</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Node&lt;K,V&gt;[] tab = table;</span><br><span class="line">    <span class="keyword">while</span> (tab != <span class="keyword">null</span> &amp;&amp; i &lt; tab.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> fh;</span><br><span class="line">        Node&lt;K,V&gt; f = tabAt(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">            i = <span class="number">0</span>; <span class="comment">// restart</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 跟put/remove/replace一样</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; p = (fh &gt;= <span class="number">0</span> ? f :</span><br><span class="line">                                   (f <span class="keyword">instanceof</span> TreeBin) ?  ((TreeBin&lt;K,V&gt;)f).first : <span class="keyword">null</span>); </span><br><span class="line">                    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        --delta;</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, i++, <span class="keyword">null</span>); <span class="comment">// 清空这个hash桶</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (delta != <span class="number">0L</span>)</span><br><span class="line">        addCount(delta, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> &amp;&amp; replaceNode(key, <span class="keyword">null</span>, value) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || oldValue == <span class="keyword">null</span> || newValue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, newValue, oldValue) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, value, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="C:\Users\Administrator\Desktop\面试题总结\集合框架\image-20200318175855802.png" alt="image-20200318175855802" style="zoom: 50%;" />



<h2 id="其他参考解读"><a href="#其他参考解读" class="headerlink" title="其他参考解读"></a>其他参考解读</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42130471/article/details/89813248">concurrentHashMap原理分析和总结（JDK1.8）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/72783008">Map 综述（三）：彻头彻尾理解 ConcurrentHashMap</a></p>
<h1 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%92%8CHashMap%E6%BA%90%E7%A0%81/">http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%92%8CHashMap%E6%BA%90%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LongAdder%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LongAdder原理</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">list</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E9%9B%86%E5%90%88%E7%B1%BB%E5%8D%9A%E5%AE%A2"><span class="toc-number">1.</span> <span class="toc-text">0. 集合类博客</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%BBHashMap%E6%BA%90%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">一、读HashMap源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E7%AA%A5HashMap"><span class="toc-number">2.1.</span> <span class="toc-text">初窥HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk1-8%E4%B8%ADHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">jdk1.8中HashMap的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%88%90%E5%91%98%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">HashMap成员定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tableSizeFor%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">tableSizeFor方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">hash方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E9%87%8F%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">为什么容量是2的n次幂</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">put方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#treeifyBin%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">treeifyBin方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#treeify%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">treeify方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#putTreeVal"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">putTreeVal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#untreeify"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">untreeify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moveRootToFront"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">moveRootToFront</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeNode"><span class="toc-number">2.2.5.</span> <span class="toc-text">removeNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">resize方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk1-8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97hash%E5%B0%B1%E8%83%BD%E5%BE%97%E5%87%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">jdk1.8为什么不用重新计算hash就能得出索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%9B%B4%E5%A4%9A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">扩容机制更多参考资料</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%A0%91%E5%8C%96%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">HashMap为什么要树化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">2.4.</span> <span class="toc-text">HashMap线程不安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E8%AF%A6%E8%A7%A3%E5%85%B6%E5%AE%83%E5%8F%82%E8%80%83"><span class="toc-number">2.6.</span> <span class="toc-text">HashMap详解其它参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ConcurrentHashMap%E6%BA%90%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">二、ConcurrentHashMap源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%94%B9%E5%8A%A8"><span class="toc-number">3.1.</span> <span class="toc-text">主要改动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">常量和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">1、常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">2、变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">基本类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Node%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%8A%82%E7%82%B9-%E6%99%AE%E9%80%9A%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.1.</span> <span class="toc-text">1、Node：基本节点&#x2F;普通节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81TreeNode%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">2、TreeNode：红黑树节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81ForwardingNode%EF%BC%9A%E8%BD%AC%E5%8F%91%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.3.</span> <span class="toc-text">3、ForwardingNode：转发节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81TreeBin%EF%BC%9A%E4%BB%A3%E7%90%86%E6%93%8D%E4%BD%9CTreeNode%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.4.</span> <span class="toc-text">4、TreeBin：代理操作TreeNode的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81ReservationNode%EF%BC%9A%E4%BF%9D%E7%95%99%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.5.</span> <span class="toc-text">5、ReservationNode：保留节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">构造方法与初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">一些基本的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.</span> <span class="toc-text">计数操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">3.7.</span> <span class="toc-text">扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%80%E4%B8%AAtransfer%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.7.1.</span> <span class="toc-text">1、一个transfer任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81transfer%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%B3%E8%AF%B7"><span class="toc-number">3.7.2.</span> <span class="toc-text">2、transfer任务的申请</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81resizeStamp%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E9%87%8D%E5%8F%A0%E7%9B%B8%E5%85%B3"><span class="toc-number">3.7.3.</span> <span class="toc-text">3、resizeStamp以及扩容重叠相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Point-1"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">Point 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Point-2"><span class="toc-number">3.7.3.2.</span> <span class="toc-text">Point 2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%89%A9%E5%AE%B9%E4%BB%A3%E7%A0%81"><span class="toc-number">3.7.4.</span> <span class="toc-text">4、扩容代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E9%81%8D%E5%8E%86%E5%99%A8Traverser"><span class="toc-number">3.8.</span> <span class="toc-text">只读遍历器Traverser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.9.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">3.9.1.</span> <span class="toc-text">1、基本的读操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">3.9.2.</span> <span class="toc-text">2、基本的写操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E8%80%83%E8%A7%A3%E8%AF%BB"><span class="toc-number">3.10.</span> <span class="toc-text">其他参考解读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81"><span class="toc-number">4.</span> <span class="toc-text">三、</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Sentinel/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Sentinel/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.161Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Replication/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Replication/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.155Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关键字"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字">关键字</a><time datetime="2021-12-18T14:44:09.151Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>