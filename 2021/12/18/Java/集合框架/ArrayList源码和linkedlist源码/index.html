<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>list | 暮成雪的博客</title><meta name="keywords" content="list"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 读ArrayList源码一、基本性质public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&amp;#123;    private static final long seri">
<meta property="og:type" content="article">
<meta property="og:title" content="list">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="1 读ArrayList源码一、基本性质public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&amp;#123;    private static final long seri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:43.635Z">
<meta property="article:modified_time" content="2020-02-23T06:12:38.000Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="list">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'list',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-02-23 06:12:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">list</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:43.635Z" title="发表于 2021-12-18 14:42:43">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-02-23T06:12:38.000Z" title="更新于 2020-02-23 06:12:38">2020-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE%E9%83%A8%E5%88%86/">JavaSE部分</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="list"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-读ArrayList源码"><a href="#1-读ArrayList源码" class="headerlink" title="1 读ArrayList源码"></a>1 读ArrayList源码</h1><h2 id="一、基本性质"><a href="#一、基本性质" class="headerlink" title="一、基本性质"></a>一、基本性质</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、底层使用<strong>原生数组实现</strong>，实现RandomAccess接口，可以<strong>随机访问</strong>，随机访问指的是**下标索引操作index(i)的时间复杂度是O(1)**。</p>
<blockquote>
<p>size、isEmpty、get、set、iterator和listIterator操作在O(1)内完成，add(e)操作平均在O(1)内完成，即添加n个元素需要O(n)时间（这个是Collection.add，是在尾部添加注意区分下List.add(index, e)）。其他操作基本都是O(n)内完成。ArrayList与LinkedList实现相比，O(n)的各个方法的时间复杂度的常数因子更小。</p>
</blockquote>
<p>2、因为底层数组 elementData 的容量是不能改变的，所以容量不够时，需要把 elementData 换成一个更大的数组，这个过程叫作<strong>扩容</strong>。实际的元素的数量size，总是不会超过底层数组的容量 elementData.length，因为扩容需要申请更大的内存，并且需要原来数组的进行一次<strong>复制</strong>，所以扩容是个耗时的操作。在添加大量元素之前，使用者最好是预估一个大致的数量，<strong>手动调用ensureCapacity进行一次扩容操作</strong>，避免一个个添加导致频繁扩容影响性能。 </p>
<p>3、ArrayList是未同步的，多线程并发读写时需要外部同步，如果不外部同步，那么可以使用<strong>Collections.synchronizedList</strong>方法对ArrayList的实例进行一次封装，或者使用Vector。</p>
<p>4、对存储的<strong>元素无限制</strong>，允许null元素。</p>
<p>5、ArrayList的iterator和listIterator方法返回的迭代器是<strong>快速失败</strong>的，也就是如果在创建迭代器之后的任何时间被<strong>结构性修改</strong>，除了通过迭代器自己的remove或add方法之外，迭代器将直接抛出一个ConcurrentModificationException，从而达到快速失败<strong>fail-fast</strong>的目的，尽量避免不确定的行为。ArrayList的迭代器的快速失败行为不能被严格保证，并发修改时它会尽量但不100%保证抛出ConcurrentModificationException。因此，依赖于此异常的代码的正确性是没有保障的，迭代器的快速失败行为应该<strong>仅用于检测bug</strong>。</p>
<p>6、实现clone接口，可以调用其clone方法（虽然clone()是<strong>Object中的方法，但是它是protected</strong>，使用子类的clone()必须在子类中覆盖此方法）。clone方法复制一个ArrayList，底层数组elementData不共享，但是实际的元素还是共享的。不过clone是ArrayList中覆盖的，不属于List中的方法，因此常见的声明形式<br>     <code>List&lt;String&gt; strs = new ArrayList&lt;&gt;()；</code><br>声明出来的变量不能直接使用clone方法，本身也用得极少。</p>
<p>7、实现Serializable接口，可以被序列化。ArrayList”实现”了自定义序列化方法，这么做主要是为了节省空间 。对于占用空间的大头——元素list，仅仅序列化实际size大小的元素，同时不序列化对于新对象无用属性的——来自父类AbstractList的modCount。ArrayList的实际size不会超过底层数组的length，大多数情况下比底层数组length小，使用默认序列化的话，会直接序列化整个底层数组，序列化后字节流会变大，浪费空间。</p>
<h2 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h2><h3 id="1、默认构造方法，ArrayList"><a href="#1、默认构造方法，ArrayList" class="headerlink" title="1、默认构造方法，ArrayList()"></a>1、默认构造方法，ArrayList()</h3><p>关于默认构造方法，你可能在别的地方看见过这种话：无参构造方法（默认构造方法）构造的ArrayList的底层数组elementData大小（容量）默认为10。这里告诉你，这不一定是对的。这句话在1.6版本中是对的（更之前的版本我没看），从1.7开始这句话就有问题了。下面我贴出了三个版本的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk1.6的 ，初始化成10个容量。</span></span><br><span class="line"><span class="comment">/** Constructs an empty list with an initial capacity of ten. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jdk1.7的，相对1.6版本，引入了一个新的常量EMPTY_ELEMENTDATA，它是一个空数组，因此容量为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk1.7的</span></span><br><span class="line"><span class="comment">/** Shared empty array instance used for empty instances. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Constructs an empty list with an initial capacity of ten. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk1.8的，相对1.7版本，又引入了一个新的常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA ，它也是一个空数组，因此容量也为0。至于两个空数组有什么区别，看下面一点说的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Shared empty array instance used for empty instances. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Constructs an empty list with an initial capacity of ten. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java集合类在jdk1.7版本基本上都有一种改动：<strong>懒初始化</strong>。懒初始化指的是默认构造方法构造的集合类，占据尽可能<strong>少的内存空间</strong>（对于ArrayList来说，使用空数组来占据尽量少的空间，不使用null是为了避免null判断），在<u><em>第一次进行包含有添加语义的操作</em></u>时，才进行真正的初始化工作。1.7开始的ArrayList，默认构造方法构造的实例，底层数组是空数组，容量为0，在进行第一次add/addAll等操作时才会真正给底层数组赋非empty的值。如果add/addAll添加的元素小于10，则把elementData数组扩容为10个元素大小，否则使用刚好合适的大小（例如，第一次addAll添加6个，那么扩容为10个，第一次添加大于10个的，比如24个，扩容为24个，刚好合适）；1.8版本，默认构造的实例这个行为没有改变，只是用的数组名字变了。</p>
<h3 id="2、带初始容量的构造方法"><a href="#2、带初始容量的构造方法" class="headerlink" title="2、带初始容量的构造方法"></a>2、带初始容量的构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.6</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.7 跟1.6的一样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">// 重用空数组，一个小小的优化</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>678三个版本的这个构造方法的实际行为基本一致：如果initialCapacity &gt;= 0，把底层数组elementData赋值为一个大小为initialCapacity的数组，数组的所有元素都是默认值null。1.8稍微进行了一点优化，也是赋值为空数组，但是重用了常量对象。下面写个简单的例子看一个细微的区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk1.6，两个构造的区别很明显</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; la = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>); <span class="comment">// la.elementData = new Object[0], la.elementData.length = 0</span></span><br><span class="line">        la.add(<span class="string">&quot;111&quot;</span>); <span class="comment">// la.elementDate.length = 1，这里一次性扩容了1个，后续再按照通用扩容策略执行扩容操作</span></span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; lb = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// lb.elementData = new Object[10], lb.elementData.length = 10</span></span><br><span class="line">        lb.add(<span class="string">&quot;111&quot;</span>); <span class="comment">// lb.elementDate.length = 10，这里没有进行扩容，后续再按照通用扩容策略执行扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// jdk1.7，两个构造在第一次进行添加时才看得出区别</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; la = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>); <span class="comment">// la.elementData = new Object[0], la.elementData.length = 0</span></span><br><span class="line">        la.add(<span class="string">&quot;111&quot;</span>); <span class="comment">// la.elementDate.length = 1，这里一次性扩容了1个，后续再按照通用扩容策略执行扩容操作</span></span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; lb = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// lb.elementData = EMPTY_ELEMENTDATA, lb.elementData.length = 0</span></span><br><span class="line">        lb.add(<span class="string">&quot;111&quot;</span>); <span class="comment">// lb.elementDate.length = 10，这里一次性扩容了10个，后续再按照通用扩容策略执行扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// jdk1.8，同1.7</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; la = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>); <span class="comment">// la.elementData = EMPTY_ELEMENTDATA, la.elementData.length = 0</span></span><br><span class="line">        la.add(<span class="string">&quot;111&quot;</span>); <span class="comment">// la.elementDate.length = 1，这里一次性扩容了1个，后续再按照通用扩容策略执行扩容操作</span></span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; lb = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// lb.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA, lb.elementData.length = 0</span></span><br><span class="line">        lb.add(<span class="string">&quot;111&quot;</span>); <span class="comment">// lb.elementDate.length = 10，这里一次性扩容了10个，后续再按照通用扩容策略执行扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从1.7版本开始，new ArrayList&lt;&gt;()和new ArrayList&lt;&gt;(0)，虽然创建后底层内容和容量都一样，但是实际的行为有些细小的差别，1.8中使用两个空数组，正如注释所说的，是在优化（避免创建无用的空数组）的同时，保留其扩容初始策略区别。只用一个空数组就不能再优化的同时，继续保持这个小区别了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk1.8	</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//注意这里EMPTY_ELEMENTDATA</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;<span class="comment">//注意这里DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">       <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在进行add的时候首先要进行<code>ensureCapacityInternal(size + 1);  // Increments modCount!!</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可以解释new ArrayList&lt;&gt;()和new ArrayList&lt;&gt;(0)并进行第一次add之后的区别：</span></span><br><span class="line"><span class="comment">//前者elementDate.length = 1</span></span><br><span class="line"><span class="comment">//后者elementDate.length = 10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、Collection拷贝-构造方法"><a href="#3、Collection拷贝-构造方法" class="headerlink" title="3、Collection拷贝 构造方法"></a>3、Collection拷贝 构造方法</h3><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>678三个版本的关系和上述第2点一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk 1.6</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    size = elementData.length;</span><br><span class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// jdk 1.7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    size = elementData.length;</span><br><span class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// jdk 1.8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            <span class="comment">//用来创建1个Object[]数组，这样数组中就可以存放任意对象了</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此构造方法会有和Array.copyOf/System.arraycopy一样的问题，那就是它只是新建一个elementData数组，数组的内容对应相等，但是不拷贝实际的元素，实际的元素占据的内存空间还是共享的.。</p>
<p><strong>为什么c.toArray might (incorrectly) not return Object[] (see 6260652)</strong></p>
<blockquote>
<p>see 6260652 这个编号代表JDK bug库中的编号。可以去官网查看bug详情：<a target="_blank" rel="noopener" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652">JDK-6260652 : (coll) Arrays.asList(x).toArray().getClass() should be Object[].class</a> 看如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//换成object就不会有问题了</span></span><br><span class="line">        <span class="comment">//List&lt;Object&gt; list = Arrays.asList(&quot;abc&quot;);</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// class java.util.Arrays$ArrayList 内部类 并不是真的arrayList</span></span><br><span class="line">        System.out.println(list.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// class [Ljava.lang.String;</span></span><br><span class="line">        Object[] objArray = list.toArray();</span><br><span class="line">        System.out.println(objArray.getClass());</span><br><span class="line"></span><br><span class="line">        objArray[<span class="number">0</span>] = <span class="keyword">new</span> Object(); <span class="comment">// cause ArrayStoreException</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//List&lt;String&gt; list = Arrays.asList(&quot;abc&quot;);需要注意，可以知道返回的实际类型是java.util.Arrays$ArrayList，而不是ArrayList。我们调用Object[] objArray = list.toArray();返回是String[]数组，所以我们不能将Object对象，放到objArray数组中。 </span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        dataList.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        dataList.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">		<span class="comment">// class java.util.ArrayList</span></span><br><span class="line">        System.out.println(dataList.getClass());</span><br><span class="line"></span><br><span class="line">        Object[] listToArray = dataList.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// class [Ljava.lang.Object;返回的是Object数组</span></span><br><span class="line">        System.out.println(listToArray.getClass());</span><br><span class="line">        listToArray[<span class="number">0</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        listToArray[<span class="number">0</span>] = <span class="number">123</span>;</span><br><span class="line">        listToArray[<span class="number">0</span>] = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//ArrayList对象的toArray()返回就是Object[]数组，所以我们可以将任意对象存放到返回的Object[]数组中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Arrays的内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2764017481108945198L</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">            ArrayList(E[] array) &#123;</span><br><span class="line">                a = Objects.requireNonNull(array);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>通过test4和test3可以看出，如果我们有1个List<String> stringList对象，当我么调用Object[] objectArray = stringList.toArray();的时候，objectArray 并不一定能够放置Object对象。这就是源码中的注释：c.toArray might (incorrectly) not return Object[] (see 6260652)。为了考虑这种情况，所以源码中进行了if判断，来防止错误的数组对象导致异常。<code>Arrays.copyOf(elementData, size, Object[].class);</code>这个方法就是用来创建1个Object[]数组，这样数组中就可以存放任意对象了。</p>
<h2 id="三、扩容方法"><a href="#三、扩容方法" class="headerlink" title="三、扩容方法"></a>三、扩容方法</h2><p>ensureCapacity/ensureCapacityInternal提前声明下：这两个方法只是确保容量，不一定会扩容，但是为了好理解，下面的文字中所说的”扩容”指的就是这两个方法。因为原生的数组的容量不能改变，要改变数组的容量，只能是新建一个数组，并把原来数组的内容复制到新数组对应位置上去。数组拷贝使用的是Arrays.copyOf，底层用的是System.arraycopy，比循环赋值效率高。扩容示意<br><img src="https://img-blog.csdn.net/20170225200816210?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>扩容方法四个位置用到：两个add方法，两个addAll方法，一个反序列化方法，还有就是手动扩容方法ensureCapacity（称之为手动，是因为此方法是public的，可以外部手动调用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动扩容方法（可以外部调用，不过大多数情况都是List&lt;?&gt; list= new ArrayList&lt;&gt;()，这样是调用不到这个方法的）</span></span><br><span class="line"><span class="comment">// 这个方法只是简单区别下list是不是通过 new ArrayList() 来创建的，这一点前面说了</span></span><br><span class="line"><span class="comment">// 如果是，则尝试最小扩容10个，不是则尝试扩容指定个，具体也是通过内部扩容方法完成容量确保</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面是内部扩容相关的几个方法的代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// overflow-conscious code 考虑int型溢出</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code 考虑int型溢出</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow int型溢出，直接报错</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面这是1.6的相关代码，可以对比看下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        Object oldData[] = elementData;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别就是</strong>：1.6的方法只是简单进行了逻辑上的操作，没有过多考虑int型溢出的问题，从1.7（上面贴的是1.8的）开始对这个进行了完善。先仔细看看1.6的问题，整体来说都是int型溢出的问题:</p>
<p>1、没考虑入参minCapacity可能因为int溢出变为负数。这个方法可以外部手动调用，手动扩容传入负数这个肯定是应该拦截掉的。但是自动扩容会因为int溢出产生负数，碰到这种情况时应该特殊处理，而不是什么都不做，等着后面抛出一个ArrayIndexOutOfBoundsException。</p>
<p>2、就是这句代码不太好，过早溢出     <code>int newCapacity = (oldCapacity * 3)/2 + 1;</code>虽然上面这行代码和1.7开始的oldCapacity + (oldCapacity &gt;&gt; 1) 看上去一样，都是相当于1.5倍，但实际上是有区别的。两个区别，第一个小区别是jdk1.6的那种乘除运算的数学结果比后面一个大1比如oldCapacity=10，1.6的算法得到16，1.7开始的算法得到15，这个影响不大；第二个区别就是两者在数字比较大是运算结果不一样，比如oldCapacity=10^9，这个数和Integer.MAX_VALUE位数一样，用1.6的算法得到的会是错误的-647483647，用1.7的则是正确的1500000000，这时候明明可以1.5倍扩容，但是jdk1.6却用的是按需扩容。</p>
<blockquote>
<p>在计算机里面对于int型的两个不同的数a和b，有<br>a-b&gt;0 <strong>不等价于</strong> a&gt;b<br>因为，a-b&gt;0会被int溢出影响，a&gt;b不会受int溢出影响。无符号的int型中a-b&gt;0是一定成立的；有符号的int型，负数可以看成是正数的溢出，假设a = Integer.MAX_VALUE + 10，b = Integer.MAX_VALUE - 10，很明显a是负数，b是正数，运行一遍a&gt;b得到false，再运行一遍a-b得到的是20，a-b&gt;0得到true。因此对于int型，a&gt;b和a-b&gt;0在if判断中有不同的功能，前者是纯粹比较大小，正数一定大于负数；后者可以判断溢出，正数不一定大于负数。</p>
</blockquote>
<p><strong>所以1.7版本对上面两个问题做了修改</strong>。</p>
<p>1、从1.7开始将内部扩容和外部可以调用的扩容方法分开了，通过源码（上面贴的是1.8的代码，可以看出是一样的）可以看出：<strong>外部调用</strong>的手动扩容方法ensureCapacity要多一个判断条件 <strong>minCapacity &gt; minExpand</strong>，这个判断条件拦截掉负数的minCapacity，这样调用内部扩容ensureCapacityInternal方法时，minCapacity一定是正数；<strong>内部扩容</strong>方法直接就用<strong>minCapacity - elementData.length &gt; 0</strong>判断，此条件可以检测出int型溢出，碰到溢出最后会抛出一个OOM错误。jdk1.7用OOM，这比jdk1.6用ArrayIndexOutOfBoundsException更好，因为此时数组大小超出了虚拟机对数组的限制，虚拟机无法处理这种情况了，抛出一个ERROR是合理的。<br>2、使用这行代码<br>     <code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code><br>这行不仅仅是是用<strong>位运算加快执行速度</strong>，上面说了，这种做法才是对的，是真正的1.5倍。不仅仅因为那一个大小的差别，更重要的是避免过早出现int溢出的情况，保证了内部自动扩容会尽量按规定的策略执行。同时整个扩容处理流程中多增加了几处if判断，对各种情况处理更加完善。</p>
<blockquote>
<p>还有一个问题就是，MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8。这个是1.7开始才有的，注释说这个是因为在一些虚拟机的数组实现中，会有<strong>array header这个保留部分</strong>，所以数组最大长度并不是实际的Integer.MAX_VALUE。这个在1.8自带的HotSpot上测试（环境Win7 64位，Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)），准确值应该是Integer.MAX_VALUE - 2，比这个值大就会出现OutOfMemoryError: Requested array size exceeds VM limit。此Error和hugeCapacity中抛出的OOM基本上差不多，这两个跟一般的OOM还是有区别的。抛出这个异常时，一般是程序有问题，此时虚拟机看看数组大小，就知道了它是不能完成这样的内存分配的，跟剩余的内存空间大小没关系。</p>
</blockquote>
<hr>
<p>在带初始容量的构造方法 public ArrayList(int initialCapacity) 中，并没有判断初始容量是否大于MAX_ARRAY_SIZE。个人觉得还是判断下好，不判断可能在扩容时会有点问题。下面给一组变量值大家试下，看下是不是真有问题。</p>
<blockquote>
<p>初始数组长度 elementData.length = Integer.MAX_VALUE - 5 = 2147483642；<br>还要继续添加的长度 expand = Integer.MAX_VALUE - 2 = 2147483645；<br>最小容量 minCapacity = expand + elementData.length = -9；<br>ensureExplicitCapacity方法中 minCapacity - elementData.length = 2147483645 &gt; 0，会继续执行grow方法；<br>grow方法中 newCapacity = elementData.length + (elementData.length &gt;&gt; 1) = -1073741833；<br>grow方法中的第一个if，newCapacity - minCapacity = -1073741824 &lt; 0，执行第一个if中的 newCapacity = minCapacity，newCapacity = -9；<br>grow方法中的第二个if，newCapacity - MAX_ARRAY_SIZE = -2147483648 &lt; 0，不执行第二个if中的语句；<br>执行最后的Arrays.copyOf，因为newCapacity = -9 &lt; 0，会抛出异常NegativeArraySizeException。</p>
<p>grow方法中第二个if，如果newCapacity是负数，只有是-9到-1这几个负数，才会不执行hugeCapacity方法而是直接执行Arrays.copyOf抛出异常。如果构造方法中拦截判断下是否大于MAX_ARRAY_SIZE，一开始的数组长度就限制在Integer.MAX_VALUE - 8，应该是无法通过一个正数的expand，使得minCapacity在[-9,-1]内。严格证明暂时给不出，实际运行中由于内存限制无法演示。</p>
</blockquote>
<hr>
<h2 id="四、常用方法"><a href="#四、常用方法" class="headerlink" title="四、常用方法"></a>四、常用方法</h2><h3 id="1、来自List接口中的方法"><a href="#1、来自List接口中的方法" class="headerlink" title="1、来自List接口中的方法"></a>1、来自List接口中的方法</h3><p>E get(int index)：这个没啥说的。<br>E set(int index, E element)：这个没啥说的。<br>void add(int index, E element)：这个内部会进行数组复制，复制原来index开始的数组到 index+1 开始的位置，因此在ArrayList中间add元素是比较慢的，平均下来是O(n)的时间。没必要时尽量不使用这个方法，而是直接使用 add(e) 添加到尾部，add(e) 平均下来只会耗费O(1)的时间，效率高很多。<br>简单画了个图，可以看下。</p>
<p><strong>E get(int index)：</strong>这个没啥说的。<br><strong>E set(int index, E element)：</strong>这个没啥说的。<br><strong>void add(int index, E element)：</strong>这个内部会进行<strong>数组复制</strong>，复制原来index开始的数组到 index+1 开始的位置，因此在ArrayList中间add元素是比较慢的，平均下来是**O(n)<strong>的时间。没必要时尽量不使用这个方法，而是直接使用 add(e) 添加到尾部，</strong>add(e) 平均下来只会耗费O(1)**的时间，效率高很多。<br>简单画了个图，可以看下。</p>
<p><img src="https://img-blog.csdn.net/20170225201521045?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><strong>E remove(int index)<strong>：基本同上，会进行数组复制，这是数组实现的list避免不了的问题。注意下实现中的</strong>elementData[–size] = null; // clear to let GC do its work</strong>，这句让list不引用元素，让元素可以被回收（当然，还得其他地方都不引用元素），避免集合类“假删除”造成内存泄漏。<br>remove示意图如下。<br><img src="https://img-blog.csdn.net/20170225201607687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><strong>int indexOf(Object o)：</strong>此方法和下面的lastIndexOf方法会进行null判断，o == null则在遍历时使用 == 进行比较，o != null则在遍历时使用equals方法进行比较，所以使用时请注意下元素的equals方法。返回的是第一个相等的index，<strong>正序遍历</strong><br><strong>int lastIndexOf(Object o)<strong>：同上。</strong>倒序遍历</strong><br><strong>boolean addAll(int index, Collection&lt;? extends E&gt; c)<strong>：elementData数组中插入c.toArray()数组，使用的System.arraycopy复制进去。<br><strong>ListIterator<E> listIterator(int index)<strong>：返回一个基于数组操作的ListIterator，</strong>ListIterator是Iterator的增强</strong>实现。传统的Iterator只能往一个方向迭代，并且只能在迭代中进行remove这一个写操作；</strong>ListIterator能够双向迭代</strong>，支持迭代时获取下标，并且能够在<strong>迭代中进行add和set</strong>操作。不过List这一系的迭代器弄得比较乱，抽象类AbstractList中有一套，几个主要实现类ArrayList、LinkedList、Vector、CopyOnWriteArrayList中又各自有一套。父类中那一套是通用的，各个具体的类中的那一套，一般都是优化过的，效率会提升一些，所以不用管父类的迭代器了，那些虽然通用，但是效率不高，差不多过时了。jdk1.6的ArrayList是直接使用父类Abstract中的通用的那一套，效率稍微低些。<br>**ListIterator<E> listIterator()**：就是new ListItr(0);<br><strong>List<E> subList(int fromIndex, int toIndex)<strong>：返回此List的某一段的视图，具体返回类型是java.util.ArrayList$SubList这个</strong>内部类</strong>，ArrayList.subList是复用原ArrayList的elementdata数组，操作原数组也会对subList有影响。jdk1.6中是用父类的这个方法，返回一个通用的java.util.SubLlist，1.7开始使用的是java.util.ArrayList.SubList，直接操作ArrayList的数组，效率更高。虽然重写了一份功能几乎一样的代码，但是作为一个基层的类，效率还是很重要的。</p>
<h3 id="2、来自Collection-Iteratable-接口的方法"><a href="#2、来自Collection-Iteratable-接口的方法" class="headerlink" title="2、来自Collection(Iteratable)接口的方法"></a>2、来自Collection(Iteratable)接口的方法</h3><p>**Iterator<E> iterator()**：返回一个内部的实现类，从jdk1.7开始该实现类使用数组的特性优化实现Iterator的几个方法，1.6返回的是父类AbstractList中定义的一个List接口通用的迭代器。<br>**int size()**：直接返回属性size<br>**boolean isEmpty()**：size == 0<br>**boolean contains(Object o)**：使用的是indexOf<br><strong>boolean add(E e)<strong>：尾部添加，只用考虑是否扩容，不扩容时的插入不用考虑数组元素移动的问题，平均下来是O(1)的时间。这里可以简单证明下：初始a个容量，每次扩容后是1.5倍，设为c；那么扩容次数为x = O(logc(n))（c为底数）；扩容移动的元素个数，等比数列求和，为O(c^x) = O(n)；不扩容时每个元素为O(1)，不扩容总共消耗小于O(n)；总共耗时O(n)，平均耗时O(1)。<br><strong>boolean remove(Object o)：</strong>移除</strong>正序遍历第一个“相等”的元素</strong>，此处<u><em>相等和indexOf中的一样，null使用 ==，非null使用equals</em></u>。移除时使用的fastRemove(int index)跟remove(int index)行为一样，因为是内部使用，所以不用检查边界，而且返回void。<br>**boolean containsAll(Collection<?> c)**：继承使用AbstractCollection中的方法，使用for-each挨个检验contains。对于Iterable的实现类，for-each是用Iterator实现的。在ArrayList这种基于数组的实现中，传统for循环比Iterator要快，Iterator比直接数组下标取值要多不少步骤，在N次简单循环这种狂飙cpu的操作中，每个步骤都是花时间的，所以Iterator（for-each循环）要慢。不够估计是此方法用的不多，在ArrayList中没有用数组的特性进一步优化此方法。1.7以后ArrayList中其余几个All方法都重写了，就这个All方法还是用的父类的。
**boolean addAll(Collection<? extends E> c)**：c.toArray，数组尾部追加数组，先确保容量，然后复制要add的数组就行。
**boolean removeAll(Collection<?> c)<strong>：<code>return batchRemove(c, false);</code>可以理解为差集操作，这个和下面的retainAll <code>return batchRemove(c, true);</code>一起讲，都是利用</strong>batchRemove**方法，只是判断是否删除一个元素时行为相反。1.8在调用batchRemove进行了null判断，c == null会提前抛出NPE，1.6的是重用父类AbstractCollection中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此方法就是一个简单的数组批量删除方法，并且删除后剩余的元素相对顺序不变，且全部往前移动</span></span><br><span class="line"><span class="comment">// 之所以使用try-fianlly是因为c.contains可能会抛出异常(c == null，或者实现类中不允许null），导致ArrayList没有能更新size以及对底层数组进行整理，</span></span><br><span class="line"><span class="comment">//     使用finally可以保证保证这一点，并且与父类AbstractCollection中已经实现的removeAll/retainAll方法的行为的一致性</span></span><br><span class="line"><span class="comment">// 通过finally中的代码可以看出，这些没有进行判断的元素会全部保留。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)<span class="comment">//关键逻辑</span></span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r, elementData, w, size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>boolean retainAll(Collection&lt;?&gt; c)：</strong>交集操作，上面removeAll已经讲了。<br>**void clear()**：for循环清空elementData数组，并把size置为0，不改变容量。<br><strong>boolean equals(Object o)：</strong>继承使用父类AbstractList中的方法，算法和判断两个数组内容是否全等一样，就是用的是迭代器而不是传统for循环，此方法用得很少，所以没用数组特性进一步优化。<br><strong>int hashCode()：</strong>同上，继承使用父类AbstractList中的方法，hashCode算法也不特殊，线性结构常用的hash = 31 * hash + e.hashCode。<br><strong>Object[] toArray()：</strong>直接使用Arrays.copyOf拷贝一份elementData数组作为返回值，也就是数组不共享但是元素共享。<br><strong><T> T[] toArray(T[] a)：</strong>此方法说明下，觉得行为有些不太友好。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此方法很简单，分<strong>3种情况</strong>处理：<u><em>给定数组空间小了，新建一样大小数组并拷贝过去（新建操作是在Arrays.copyOf里面完成的）；刚好相等，直接拷贝就过去完事；给定数组大了，拷贝过去后，由于只覆盖了原数组的前面一部分，再把接下来的一个元素变为null</em></u>。觉得不友好的就是给定数组大了的这种情况，因为它会多覆盖掉一个值，注释中说这么做的原因是“当调用者知道列表不包含任何空元素时，这在确定列表的长度时非常有用”，这是个坑啊。下面的demo简单展示了这个坑。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; sList = Arrays.asList(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="comment">// 推荐使用空数组</span></span><br><span class="line">        String[] s0 = &#123;&#125;;</span><br><span class="line">        System.err.println(<span class="string">&quot;s0 = &quot;</span> + Arrays.toString(sList.toArray(s0)));</span><br><span class="line">        <span class="comment">// s0 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 也可以使用等长数组</span></span><br><span class="line">        String[] s10 = <span class="keyword">new</span> String[sList.size()];</span><br><span class="line">        System.err.println(<span class="string">&quot;s10 = &quot;</span> + Arrays.toString(sList.toArray(s10)));</span><br><span class="line">        <span class="comment">// s10 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 除非你清楚，否则不要像下面这么做，因为s20[10]被此方法设置为null</span></span><br><span class="line">        String[] s20 = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br><span class="line">        s20[<span class="number">10</span>] = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">        s20[<span class="number">11</span>] = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        s20[<span class="number">12</span>] = <span class="string">&quot;12&quot;</span>;</span><br><span class="line">        System.err.println(<span class="string">&quot;s20 = &quot;</span> + Arrays.toString(sList.toArray(s20)));</span><br><span class="line">        <span class="comment">// s20 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, null, 11, 12, null, null, null, null, null, null, null]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、独有的两个方法"><a href="#五、独有的两个方法" class="headerlink" title="五、独有的两个方法"></a>五、独有的两个方法</h2><p>public void ensureCapacity(int minCapacity)：可以外部调用的手动扩容方法，在要添加大量元素之前，预估下容量，调用这个方法手动扩容，避免频繁自动扩容降低性能。<br>public void trimToSize()：节省空间，使得elementData刚好容纳下所有元素。</p>
<h1 id="2-读LinkedList源码"><a href="#2-读LinkedList源码" class="headerlink" title="2 读LinkedList源码"></a>2 读LinkedList源码</h1><h2 id="一、基本性质-1"><a href="#一、基本性质-1" class="headerlink" title="一、基本性质"></a>一、基本性质</h2><p>1、基于双向链表实现的List可以顺序访问，直接父类是AbstractSequentialList，不实现RandomAccess接口，不支持随机访问。<br>AbstractSequentialList这个抽象类实现了最基本的顺序访问功能，虽然支持随机访问的也支持顺序访问，但是一般设计上还是会把它们两个当成无关联的两个特性。所以当利用随机访问特性时优先extends AbstractList而不是此类，当然实现此类也可以，只是没必要。<br>具体点，jdk1.6使用的是一个<strong>带有头结点的双向循环链表</strong>，头结点不存储实际数据，循环链表指的是能够只通过一个方向的指针重新遍历到自己这个节点的链表，示意图如下。</p>
<p><img src="https://img-blog.csdn.net/20170225203016252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>jdk1.7之后使用的是不带头结点的普通的双向链表，增加两个节点指针first、last分别指向首尾节点，示意图如下。</p>
<p><img src="https://img-blog.csdn.net/20170225203056783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>为什么要这样？感觉应该是为了<strong>节省那一个空间</strong>，毕竟链表带不带头结点实际操作没多大改变，性能也不变。这一点可以算作是678几个版本唯一的有意义的区别了。<br><em><u>虽然链表的插入、删除都是O(1)，但那是在节点已知的情况下</em></u>。LinkedList中定位一个节点需要遍历链表，因此<strong>与下标有关的插入、删除时间复杂度都变为O(n)<strong>，下标无关的</strong>删除</strong> remove(obj) 也需要遍历，所以也是O(n)，<strong>尾部的添加、删除不需要遍历，时间复杂度为O(1)<strong>，因此LinkedList</strong>整体读写效率不如ArrayList</strong>。但是链表结构<strong>对内存要求低</strong>，不需要大块连续内存来满足扩容，能够自动动态地消耗内存，容量变小时会自动释放曾经占用的内存，<strong>ArrayList则需要手动trim</strong>。</p>
<p>2、相比ArrayList，此类还额外实现了Deque接口，可以充当<strong>一般的双端队列或者栈</strong>，所以LinkedList很通用，可以作为一些混合数据结构的基础。</p>
<p>3、<strong>理论上无容量限制，只受虚拟机自身限制影响</strong>，所以没有扩容方法。</p>
<p>4、和ArrayList一样，LinkedList也是是<strong>未同步</strong>的，多线程并发读写时需要外部同步，如果不外部同步，那么可以使用<strong>Collections.synchronizedList</strong>方法对LinkedList的实例进行一次封装。</p>
<p>5、和ArrayList一样，LinkedList也对存储的元素无限制，<strong>允许null元素</strong>。</p>
<p>6、和ArrayList一样，LinkedList的<strong>迭代器也是快速失败</strong>的，并且也不是100%保证，不应去依赖这个性质。</p>
<p>7、实现Cloneable接口，可以被clone。和ArrayList一样，clone是自己写的方法，<strong>实际元素也是双方共享</strong>。</p>
<p>8、实现Serializable接口，可以被序列化/反序列化。相关的两个方法是自己写的，序列化时只序列化size以及顺序序列化每一个实际的元素，不序列化其他无用的指针，节省空间。反序列化就是把size个元素按顺序再一个个在尾部添加一遍。</p>
<h2 id="二、构造方法-1"><a href="#二、构造方法-1" class="headerlink" title="二、构造方法"></a>二、构造方法</h2><h3 id="1、默认构造方法（无参构造方法）"><a href="#1、默认构造方法（无参构造方法）" class="headerlink" title="1、默认构造方法（无参构造方法）"></a>1、默认构造方法（无参构造方法）</h3><p><code>public LinkedList()</code>1.6的把header这个变量声明时的初始值是一个空的Entry，构造方法中只是改一下对应指针的指向，具体构造出来的结构可以看下上面的第一张图片中size = 0的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;E&gt; header = <span class="keyword">new</span> Entry&lt;E&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Constructs an empty list. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header.next = header.previous = header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.7开始，因为不再使用header节点，所以默认构造方法声明也不做，first和last会被默认初始化为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是1.8的代码，1.7的一样</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null) 这是个固定不变的关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null) 这是个固定不变的关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Constructs an empty list. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;<span class="comment">//因为给LinkedList指定初始容量没什么实际意义，所以不需要指定初始容量的构造方法。</span></span><br></pre></td></tr></table></figure>

<h3 id="2、Collection拷贝构造方法"><a href="#2、Collection拷贝构造方法" class="headerlink" title="2、Collection拷贝构造方法"></a>2、Collection拷贝构造方法</h3><p><code>public LinkedList(Collection&lt;? extends E&gt; c)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三个版本都一样，这个没什么好说的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、常用方法"><a href="#三、常用方法" class="headerlink" title="三、常用方法"></a>三、常用方法</h2><p>LinkedList的操作都是基本的链表操作，不超过数据结构教材中讲的内容，不太懂的可以复习下数据结构。<br>1.6的指针操作主要是靠private Entry<E> addBefore(E e, Entry<E> entry)和remove(Entry<E> e)两个方法，因为有头结点的原因，方法操作的一致性高，流程中if判断比较少。<br>1.7开始变成了linkBefore/unlink方法，因为没有header节点，需要用if判断的就多一些，总共写了linkBefore/linkFirst/linkedLast/unlink/unlinkFirst/unlinkLast这6个方法，其实可以把linkBefore/unlink里面的逻辑再完善下，这样也可以只用两个。三个版本代码基本上没什么实质性的改动。</p>
<h3 id="Node-node-int-index"><a href="#Node-node-int-index" class="headerlink" title="Node node(int index)"></a>Node<E> node(int index)</h3><p>先说下这个简单的优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 这是1.8的代码，之前版本逻辑一样</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个很小的优化，根据下标判断下哪种路径更短，该从头开始还是从尾部开始。因为下标index是从0开始的，所以if (index &lt; (size &gt;&gt; 1))这句是没有问题的，加上等号才有问题。</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>简单看下add 方法 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是jdk1.8的代码，因为没有使用头结点，所以代码比1.6的看起来麻烦些，if判断更多</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index); <span class="comment">// 检查下标</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (index == size) <span class="comment">// 是在尾部添加</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 中间添加，需要寻找当前index处的节点，把新节点添加在它的前面</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法简单画了个图，可以看下。</p>
<p><img src="https://img-blog.csdn.net/20170225205034448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是jdk1.8的代码，因为没有使用头结点，所以代码比1.6的看起来麻烦些，if判断更多</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123; <span class="comment">// 要删除的是第一个节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123; <span class="comment">// 要删除的是最后一个节点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20170225205128745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM5Mjg5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h3><p>有两个构造函数，一个是初始化一个空的实例，另外一个是传入一个集合进行初初始化。在初始化的时候主要调用了addAll()方法，那么这个addAll()方法是怎么样添加元素的呢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入给定集合的元素，从指定的index开始插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();<span class="comment">//为什么要将集合转为数组？？？？？</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;<span class="comment">//前驱和后继引用</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;<span class="comment">//如果插入的位置刚好在最后位置</span></span><br><span class="line">        succ = <span class="keyword">null</span>;<span class="comment">//后继用用置位空</span></span><br><span class="line">        pred = last;<span class="comment">//前驱为last所引用的尾结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);<span class="comment">//寻找插入的节点位置</span></span><br><span class="line">        pred = succ.prev;<span class="comment">//保存该节点的前驱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;<span class="comment">//循环插入每个节点</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;<span class="comment">//向下转型</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);<span class="comment">//生成一个新节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//前驱为空，表示在第一个位置插入</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则在index前面插入新节点</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;<span class="comment">//前驱为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;<span class="comment">//后继为空</span></span><br><span class="line">        last = pred;<span class="comment">//在末尾插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;<span class="comment">//否则链接最后的节点</span></span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;<span class="comment">//节点个数增加</span></span><br><span class="line">    modCount++;<span class="comment">//结构性修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法首先是将集合转为数组，那么为什么要这样子做呢，我们来看看toArray()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an array containing all of the elements in this list</span></span><br><span class="line"><span class="comment"> * in proper sequence (from first to last element).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are</span></span><br><span class="line"><span class="comment"> * maintained by this list.  (In other words, this method must allocate</span></span><br><span class="line"><span class="comment"> * a new array).  The caller is thus free to modify the returned array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method acts as bridge between array-based and collection-based</span></span><br><span class="line"><span class="comment"> * APIs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an array containing all of the elements in this list</span></span><br><span class="line"><span class="comment"> *         in proper sequence</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体的插入过程可以用下图来解释<br>A找到节点<br><img src="https://img-blog.csdnimg.cn/20190503164649904.png" alt="在这里插入图片描述"><br>找到下标为Index的节点标记为succ，找到它的前驱节点标记为pred，</p>
<p>B插入新节点</p>
<p><img src="https://img-blog.csdnimg.cn/20190503164818114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd5dWFuX3NpYmFs,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">C移动指向</p>
<p><img src="https://img-blog.csdnimg.cn/20190503164909118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd5dWFuX3NpYmFs,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>D循环执行B C 步骤（上述图中的错误：插入新节点之后newNode并没有和ele2连接，循环结束才连接起来的）</p>
<h3 id="linkFirst-E-e"><a href="#linkFirst-E-e" class="headerlink" title="linkFirst(E e)"></a>linkFirst(E e)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在头部插入一个新节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; f = first;<span class="comment">//1、创建一个引用</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//2、创建新节点，它的下一个节点为当前的头结点</span></span><br><span class="line">      first = newNode;<span class="comment">//3、头引用指向新节点</span></span><br><span class="line">      <span class="keyword">if</span> (f == <span class="keyword">null</span>)<span class="comment">//如果没有头结点，只有尾结点</span></span><br><span class="line">          last = newNode;<span class="comment">//新节点为尾结点</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          f.prev = newNode;<span class="comment">//4、否则之前的头结点的前引用指向新节点</span></span><br><span class="line">      size++;</span><br><span class="line">      modCount++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190503165055674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd5dWFuX3NpYmFs,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="linkLast-E-e"><a href="#linkLast-E-e" class="headerlink" title="linkLast(E e)"></a>linkLast(E e)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在尾部插入一个新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//创建一个指向尾部的指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);<span class="comment">//创建新节点，新节点的前一个节点为当前的尾结点</span></span><br><span class="line">    last = newNode;<span class="comment">//last引用指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;<span class="comment">//当前尾结点的前引用指向新的尾结点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="linkBefore-E-e-Node-succ"><a href="#linkBefore-E-e-Node-succ" class="headerlink" title="linkBefore(E e, Node succ)"></a>linkBefore(E e, Node succ)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在某个节点之前插入一个新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;<span class="comment">//找到该节点的前驱</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//前驱为空</span></span><br><span class="line">        first = newNode;<span class="comment">//新节点为第一个节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//否则在前面插入</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node x)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除某个非空节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert x != null;</span></span><br><span class="line">      <span class="comment">//1、找到保存节点信息，找到前置和后继节点</span></span><br><span class="line">      <span class="keyword">final</span> E element = x.item;<span class="comment">//保存要删除节点的信息</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//保存后继节点</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//保存前置节点</span></span><br><span class="line"><span class="comment">//2、修改前置指针</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//如果前置为空，</span></span><br><span class="line">          first = next;<span class="comment">//则后置节点为第一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prev.next = next;<span class="comment">//否则将前置节点的下一个节点指向后继</span></span><br><span class="line">          x.prev = <span class="keyword">null</span>;<span class="comment">//将要删除节点的引用置空</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//3、修改后继指针</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//后继为空，则前置节点为最后节点</span></span><br><span class="line">          last = prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next.prev = prev;<span class="comment">//否则后继节点的引用指向前置</span></span><br><span class="line">          x.next = <span class="keyword">null</span>;<span class="comment">//将要删除节点的引用置空</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//4、将节点置空，方便GC</span></span><br><span class="line">      x.item = <span class="keyword">null</span>;<span class="comment">//节点置空，GC</span></span><br><span class="line">      size--;</span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>1、找到保存节点信息，找到前置和后继节点</p>
<p><img src="https://img-blog.csdnimg.cn/20190503170525131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd5dWFuX3NpYmFs,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、修改前置指针</p>
<p><img src="https://img-blog.csdnimg.cn/2019050317072748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd5dWFuX3NpYmFs,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>3、修改后继指针</p>
<p><img src="https://img-blog.csdnimg.cn/20190503170804872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd5dWFuX3NpYmFs,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、将节点置空，方便GC</p>
<p><img src="https://img-blog.csdnimg.cn/20190503170853923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd5dWFuX3NpYmFs,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、栈和队列的操作"><a href="#四、栈和队列的操作" class="headerlink" title="四、栈和队列的操作"></a>四、栈和队列的操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检索头结点元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 与peek()作用一样</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getFirst();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除并返回第一个节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 与poll()作用一样</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeFirst();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在尾部添加节点与add()一样</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Deque operations</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在头部插入节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       addFirst(e);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Java中的Iterable与Iterator详解"><a href="#3-Java中的Iterable与Iterator详解" class="headerlink" title="3. Java中的Iterable与Iterator详解"></a>3. Java中的Iterable与Iterator详解</h1><p>在Java中，我们可以对List集合进行如下几种方式的遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">23</span>);</span><br><span class="line">list.add(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.print(list.get(i) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.print(it.next() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种就是普通的for循环，第二种为迭代器遍历，第三种是for each循环。<strong>后面两种方式涉及到Java中的iterator和iterable对象</strong>，接下来我们来看看这两个对象的区别以及如何在自定义类中实现for each循环。</p>
<h2 id="Iterator与Iterable"><a href="#Iterator与Iterable" class="headerlink" title="Iterator与Iterable"></a>Iterator与Iterable</h2><p>iterator为Java中的<strong>迭代器对象</strong>，是能够对List这样的集合进行迭代遍历的底层依赖。而<strong>iterable接口</strong>里定义了返回iterator的方法，<strong>相当于对iterator的封装</strong>，<u><em>同时实现了iterable接口的类可以支持for each循环</em></u>。</p>
<h3 id="iterator内部细节"><a href="#iterator内部细节" class="headerlink" title="iterator内部细节"></a>iterator内部细节</h3><p>jdk中Iterator接口主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>iterator通过以上两个方法定义了对集合迭代访问的方法，而具体的实现方式依赖于不同的实现类，具体的集合类实现Iterator接口中的方法以实现迭代。</p>
<p>可以发现，在List中并没有实现Iterator接口，而是实现的Iterable接口。进一步观察Iterable接口的源码可以发现其只是返回了一个Iterator对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以使用如下方式来对List进行迭代了（通过调用iterator()方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.print(it.next() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时实现了Iterable接口的还可以使用for each循环。</p>
<h3 id="for-each原理"><a href="#for-each原理" class="headerlink" title="for each原理"></a>for each原理</h3><p>其实for each循环内部也是依赖于Iterator迭代器，只不过Java提供的语法糖，Java编译器会将其转化为Iterator迭代器方式遍历。我们对以下for each循环进行反编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Integer i : list) &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>反编译后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i;</span><br><span class="line">for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(i))&#123;</span><br><span class="line">        i = (Integer)iterator.next();        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Java的for each增强循环是通过iterator迭代器方式实现的。</p>
<h3 id="深入探讨Iterable与Iterator关系"><a href="#深入探讨Iterable与Iterator关系" class="headerlink" title="深入探讨Iterable与Iterator关系"></a>深入探讨Iterable与Iterator关系</h3><p>有一个问题，为什么不直接将hasNext()，next()方法放在Iterable接口中，其他类直接实现就可以了？</p>
<p>原因是有些集合类可能<strong>不止一种遍历方式</strong>，实现了Iterable的类可以再<strong>实现多个Iterator内部类</strong>，例如<code>LinkedList</code>中的<code>ListItr</code>和<code>DescendingIterator</code>两个内部类，就分别实现了<strong>双向遍历</strong>和<strong>逆序遍历</strong>。通过返回不同的<code>Iterator</code>实现不同的遍历方式，这样更加灵活。如果把两个接口合并，就没法返回不同的<code>Iterator</code>实现类了。ListItr相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>如上所示可以通过调用<code>list.listIterator()</code>方法返回iterator迭代器（<code>list.iterator()</code>只是其默认实现）</p>
<p><code>DescendingIterator</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;     </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样可以通过<code>list.descendingIterator()</code>使用该迭代器。</p>
<h2 id="实现自己的迭代器"><a href="#实现自己的迭代器" class="headerlink" title="实现自己的迭代器"></a>实现自己的迭代器</h2><p>我们现在有一个自定义类ArrayMap，现在如果对其进行如下for each遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayMap&lt;String, Integer&gt; am = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">am.put(<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">am.put(<span class="string">&quot;syrups&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s: am) &#123;</span><br><span class="line">   System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们并没有实现hashNext和next抽象方法，所以无法对其进行遍历。</p>
<h3 id="自定义迭代器类"><a href="#自定义迭代器类" class="headerlink" title="自定义迭代器类"></a>自定义迭代器类</h3><p>我们首先自定义一个迭代器类实现hashNext和next方法，并将其作为<strong>ArrayMap的内部类</strong>，相关代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> ptr;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">KeyIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ptr = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (ptr != size);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         K returnItem = keys[ptr];</span><br><span class="line">         ptr += <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> returnItem;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们在next中指定的遍历规则是根据ArrayMap的key值进行遍历。有了上述迭代器类，我们就可以使用iterator方式在外部对其进行遍历了，遍历代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayMap&lt;String, Integer&gt; am = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">am.put(<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">am.put(<span class="string">&quot;syrups&quot;</span>, <span class="number">10</span>);</span><br><span class="line">ArrayMap.KeyIterator ami = am.<span class="function">new <span class="title">KeyIterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">while</span> (ami.hasNext()) &#123;</span><br><span class="line">    System.out.println(ami.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，通过创建KeyIterator对象进行迭代访问（注意外部类创建内部类对象的方式）。</p>
<h3 id="支持for-each循环"><a href="#支持for-each循环" class="headerlink" title="支持for each循环"></a>支持for each循环</h3><p>现在还不能支持for each循环访问，因为我们还没有实现iterable接口，首先在ArrayMap中实现Iterable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K[] keys;</span><br><span class="line">    <span class="keyword">private</span> V[] values;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keys = (K[]) <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        values = (V[]) <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重写iterator()方法，并在其中返回我们自己的迭代器对象(iterator)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们自定义的KeyIterator类必须要实现Iterator接口，否则在iterator()方法中返回的类型不匹配。</p>
<h2 id="ArrayList中的迭代器"><a href="#ArrayList中的迭代器" class="headerlink" title="ArrayList中的迭代器"></a>ArrayList中的迭代器</h2><h3 id="iterator-方法"><a href="#iterator-方法" class="headerlink" title="iterator()方法"></a>iterator()方法</h3><p>并没有实现interface Iterable<T>接口，但是有iterator() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class">    * <span class="title">Returns</span> <span class="title">an</span> <span class="title">iterator</span> <span class="title">over</span> <span class="title">the</span> <span class="title">elements</span> <span class="title">in</span> <span class="title">this</span> <span class="title">list</span> <span class="title">in</span> <span class="title">proper</span> <span class="title">sequence</span>.</span></span><br><span class="line"><span class="class">    *</span></span><br><span class="line"><span class="class">    * &lt;<span class="title">p</span>&gt;<span class="title">The</span> <span class="title">returned</span> <span class="title">iterator</span> <span class="title">is</span> &lt;<span class="title">a</span> <span class="title">href</span></span>=<span class="string">&quot;#fail-fast&quot;</span>&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span><br><span class="line">    *</span><br><span class="line">    * <span class="meta">@return</span> an iterator over the elements in <span class="keyword">this</span> list in proper sequence</span><br><span class="line">    */</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.ListItr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/">http://muchengxue.github.io/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/list/">list</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%92%8CHashMap%E6%BA%90%E7%A0%81/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">集合</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCOWArrayList_%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">COWArrayList</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%AF%BBArrayList%E6%BA%90%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">1 读ArrayList源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.</span> <span class="toc-text">一、基本性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">二、构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8CArrayList"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、默认构造方法，ArrayList()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B8%A6%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、带初始容量的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Collection%E6%8B%B7%E8%B4%9D-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、Collection拷贝 构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">三、扩容方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">四、常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9D%A5%E8%87%AAList%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、来自List接口中的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9D%A5%E8%87%AACollection-Iteratable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、来自Collection(Iteratable)接口的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%8B%AC%E6%9C%89%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">五、独有的两个方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AF%BBLinkedList%E6%BA%90%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">2 读LinkedList源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8-1"><span class="toc-number">2.1.</span> <span class="toc-text">一、基本性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">2.2.</span> <span class="toc-text">二、构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">1、默认构造方法（无参构造方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Collection%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2、Collection拷贝构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">三、常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-node-int-index"><span class="toc-number">2.3.1.</span> <span class="toc-text">Node node(int index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add"><span class="toc-number">2.3.2.</span> <span class="toc-text">add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove"><span class="toc-number">2.3.3.</span> <span class="toc-text">remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addAll-int-index-Collection-lt-extends-E-gt-c"><span class="toc-number">2.3.4.</span> <span class="toc-text">addAll(int index, Collection&lt;? extends E&gt; c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkFirst-E-e"><span class="toc-number">2.3.5.</span> <span class="toc-text">linkFirst(E e)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkLast-E-e"><span class="toc-number">2.3.6.</span> <span class="toc-text">linkLast(E e)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkBefore-E-e-Node-succ"><span class="toc-number">2.3.7.</span> <span class="toc-text">linkBefore(E e, Node succ)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink-Node-x"><span class="toc-number">2.3.8.</span> <span class="toc-text">unlink(Node x)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.</span> <span class="toc-text">四、栈和队列的操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Java%E4%B8%AD%E7%9A%84Iterable%E4%B8%8EIterator%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">3. Java中的Iterable与Iterator详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator%E4%B8%8EIterable"><span class="toc-number">3.1.</span> <span class="toc-text">Iterator与Iterable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">iterator内部细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-each%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">for each原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8Iterable%E4%B8%8EIterator%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.3.</span> <span class="toc-text">深入探讨Iterable与Iterator关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">实现自己的迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">自定义迭代器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81for-each%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">支持for each循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">ArrayList中的迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator-%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">iterator()方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Sentinel/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Sentinel/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.161Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Replication/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Replication/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.155Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关键字"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字">关键字</a><time datetime="2021-12-18T14:44:09.151Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>