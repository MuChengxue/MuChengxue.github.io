<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>关于synchronized和Lock | 暮成雪的博客</title><meta name="keywords" content="关键字"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Java 同步关键字synchronized1 引言在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，有些情况下它并不那么重了。下面介绍Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。    术语 英文 说明    CA">
<meta property="og:type" content="article">
<meta property="og:title" content="关于synchronized和Lock">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%85%B3%E4%BA%8Esynchronized%E5%92%8CLock/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="一、Java 同步关键字synchronized1 引言在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，有些情况下它并不那么重了。下面介绍Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。    术语 英文 说明    CA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:26.184Z">
<meta property="article:modified_time" content="2020-04-06T16:44:44.218Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="关键字">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%85%B3%E4%BA%8Esynchronized%E5%92%8CLock/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '关于synchronized和Lock',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-04-06 16:44:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">关于synchronized和Lock</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:26.184Z" title="发表于 2021-12-18 14:42:26">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-04-06T16:44:44.218Z" title="更新于 2020-04-06 16:44:44">2020-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE%E9%83%A8%E5%88%86/">JavaSE部分</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>120分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="关于synchronized和Lock"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%85%B3%E4%BA%8Esynchronized%E5%92%8CLock/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%85%B3%E4%BA%8Esynchronized%E5%92%8CLock/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Java-同步关键字synchronized"><a href="#一、Java-同步关键字synchronized" class="headerlink" title="一、Java 同步关键字synchronized"></a>一、Java 同步关键字synchronized</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，有些情况下它并不那么重了。下面介绍Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>英文</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CAS</td>
<td>Compare and Swap</td>
<td>比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</td>
</tr>
</tbody></table>
<h2 id="3-同步的情景"><a href="#3-同步的情景" class="headerlink" title="3 同步的情景"></a>3 同步的情景</h2><p>Java中的每一个对象都可以作为锁。</p>
<ul>
<li>对于同步方法，锁是当前调用方法的实例对象。</li>
</ul>
<blockquote>
<p>下面是一个同步的实例方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在方法声明中同步（synchronized ）关键字,这告诉Java该方法是同步的。Java实例方法同步是<strong>同步在拥有该方法的对象上</strong>。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。<strong>一个实例一个线程。</strong></p>
</blockquote>
<ul>
<li>对于静态同步方法，锁是当前对象的Class对象（所有实例）。</li>
</ul>
<blockquote>
<p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，这里synchronized 关键字告诉Java这个方法是同步的。静态方法的同步是指同步在<u>该<strong>方法所在的类对象上</strong>。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</u>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，<strong>一个类只能由一个线程同时执行。</strong></p>
</blockquote>
<ul>
<li>对于同步方法块，锁是Synchronized括号里配置的对象。</li>
</ul>
<blockquote>
<p><strong>实例方法中的同步块</strong></p>
<p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。在非同步的Java方法中的同步块的例子如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">       <span class="keyword">this</span>.count += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。</p>
<p>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">      log.writeln(msg1);</span><br><span class="line">      log.writeln(msg2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">         log.writeln(msg2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><u><em>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。</em></u></p>
<p><strong>静态方法中的同步块</strong></p>
<p>和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">        log.writeln(msg1);</span><br><span class="line">        log.writeln(msg2);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(MyClass.class)&#123;</span><br><span class="line">          log.writeln(msg1);</span><br><span class="line">          log.writeln(msg2);</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法不允许同时被线程访问。</p>
<p><strong>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</strong></p>
</blockquote>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁存在哪里呢？锁里面会存储什么信息呢？</p>
<h2 id="4-同步的原理"><a href="#4-同步的原理" class="headerlink" title="4 同步的原理"></a>4 同步的原理</h2><p>JVM规范规定JVM基于进入和退出<strong>Monitor对象</strong>来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<u>monitorenter和monitorexit</u>指令实现，而方法同步是使用另外一种方式实现的(<u>ACC_SYNCHRONIZED</u>)，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。<strong>任何对象都有一个 monitor 与之关联</strong>，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>
<h3 id="4-1-Java对象头"><a href="#4-1-Java对象头" class="headerlink" title="4.1 Java对象头"></a>4.1 Java对象头</h3><p>可以参考这篇<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhengbin/p/6490953.html">博客</a>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-a847c8ce7cb23ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/348/format/webp" alt="img"></p>
<p><img src="D:\学习资料\面试题总结\并发编程\对象内存结构.png"></p>
<p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32/64bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode或锁信息等。</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Array length</td>
<td>数组的长度（如果当前对象是数组）</td>
</tr>
</tbody></table>
<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的<strong>Mark Word的默认存储结构</strong>如下：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25 bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁状态</td>
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table>
<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。由于目前基本都在使用64位JVM,此处不再对32位的结构进行详细说明:</p>
<table>
<thead>
<tr>
<th align="left">偏向锁标识位1bit</th>
<th align="left">锁标识位2bit</th>
<th align="left">锁状态</th>
<th align="left">存储内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">01</td>
<td align="left">未锁定</td>
<td align="left">hash code(31),分代年龄(4),cms_free(1),unused(25)</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">01</td>
<td align="left">偏向锁</td>
<td align="left">**线程ID(54),**时间戳Epoch(2),年龄(4),cms_free(1)</td>
</tr>
<tr>
<td align="left">无</td>
<td align="left">00</td>
<td align="left">轻量级锁</td>
<td align="left">栈中锁记录的指针(62)</td>
</tr>
<tr>
<td align="left">无</td>
<td align="left">10</td>
<td align="left">重量级锁</td>
<td align="left">monitor的指针(62)</td>
</tr>
<tr>
<td align="left">无</td>
<td align="left">11</td>
<td align="left">GC标记</td>
<td align="left">空，不需要记录信息(62)</td>
</tr>
</tbody></table>
<h3 id="4-2-锁的升级"><a href="#4-2-锁的升级" class="headerlink" title="4.2 锁的升级"></a>4.2 锁的升级</h3><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了<strong>提高获得锁和释放锁的效率</strong>，下文会详细分析。</p>
<p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了<strong>轻量级锁的概念。</strong></p>
<p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个<code>Lock Record</code>，其包括一个用于存储对象头中的 <code>mark word</code>（官方称之为<code>Displaced Mark Word</code>）以及一个指向对象的指针。下图右边的部分就是一个<code>Lock Record</code>。</p>
<p>[<img src="https://camo.githubusercontent.com/3579362e569b9ea6046cf34702dba32eceb212bb/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162323461633733643f773d38363926683d33353126663d706e6726733d3331313531" alt="img"></p>
<p><strong>加锁过程</strong></p>
<p>1.在线程栈中创建一个<code>Lock Record</code>，将其<code>obj</code>（即上图的Object reference）字段指向锁对象。</p>
<p>2.直接通过CAS指令将<code>Lock Record</code>的地址存储在对象头的<code>mark word</code>中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3。</p>
<p>3.如果是当前线程已经持有该锁了，代表这是一次锁<strong>重入</strong>。设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个<strong>重入计数器</strong>的<strong>作用</strong>。然后结束。</p>
<p>4.走到这一步说明发生了竞争，需要膨胀为重量级锁。</p>
<p><strong>解锁过程</strong></p>
<p>1.遍历线程栈,找到所有<code>obj</code>字段等于当前锁对象的<code>Lock Record</code>。</p>
<p>2.如果<code>Lock Record</code>的<code>Displaced Mark Word</code>为null，代表这是一次重入，将<code>obj</code>设置为null后continue。</p>
<p>3.如果<code>Lock Record</code>的<code>Displaced Mark Word</code>不为null，则利用CAS指令将对象头的<code>mark word</code>恢复成为<code>Displaced Mark Word</code>。如果成功，则continue，否则膨胀为重量级锁。</p>
<h3 id="4-3-偏向锁"><a href="#4-3-偏向锁" class="headerlink" title="4.3 偏向锁"></a>4.3 偏向锁</h3><p>Hotspot的作者经过以往的研究发现<u>大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁</u>。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费<strong>CAS操作</strong>来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p><strong>偏向锁的撤销</strong>：偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制，所以<strong>当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</strong>。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<p><a target="_blank" rel="noopener" href="http://ifeve.com/java-synchronized/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80/"><img src="http://ifeve.com/wp-content/uploads/2012/10/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png" alt="偏向锁的撤销"></a></p>
<p><strong>关闭偏向锁：</strong>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p>
<h3 id="4-4-轻量级锁"><a href="#4-4-轻量级锁" class="headerlink" title="4.4 轻量级锁"></a>4.4 轻量级锁</h3><p><strong>轻量级锁加锁</strong>：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间Lock Record，并将对象头中的Mark Word复制到锁记录Lock Record中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录Lock Record的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p><strong>轻量级锁解锁</strong>：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><a target="_blank" rel="noopener" href="http://ifeve.com/java-synchronized/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/"><img src="http://ifeve.com/wp-content/uploads/2012/10/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="轻量级锁"></a></p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h2 id="5-锁的优缺点对比"><a href="#5-锁的优缺点对比" class="headerlink" title="5 锁的优缺点对比"></a>5 锁的优缺点对比</h2><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody></table>
<h2 id="6-Monitor监视器对象"><a href="#6-Monitor监视器对象" class="headerlink" title="6 Monitor监视器对象"></a>6 Monitor监视器对象</h2><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。在下面的例子中，使用了同步块和同步方法，通过使用javap工具查看生成的class文件信息，来分析synchronized关键字的实现细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对Synchronized Class对象进行加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Synchronized.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 静态同步方法，对Synchronized Class对象进行加锁</span></span><br><span class="line">            m();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在synchronized.class的同级目录下执行：javap -v synchronized.class，部分输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC <span class="comment">//方法修饰符，表示public static</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">1</span>                  <span class="comment">// class testnew/Synchronized</span></span><br><span class="line">         <span class="number">2</span>: dup                                  </span><br><span class="line">         <span class="number">3</span>: monitorenter                      <span class="comment">// monitorenter：监视器进入，获取锁</span></span><br><span class="line">         <span class="number">4</span>: monitorexit                          <span class="comment">// monitorexit: 监视器退出，释放锁</span></span><br><span class="line">         <span class="number">5</span>: invokestatic  #<span class="number">16</span>                 <span class="comment">// Method m:()V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED <span class="comment">//方法修饰符，表示public static synchronized</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>说明：对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。无论采用哪种方法，其本质是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的，也就是同一个时刻只能有一个线程获取到由synchronized所保护对象的监视器。</p>
<p><strong>方法级的同步是隐式的。</strong>同步方法的常量池中会有一个<code>ACC_SYNCHRONIZED</code>标志。当某个线程要访问某个方法的时候，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
<p><strong>同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现。</strong>可以把执行<code>monitorenter</code>指令理解为加锁，执行<code>monitorexit</code>理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行<code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行<code>monitorexit</code>指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。下图描述了对象、对象的监视器、同步队列和执行线程之间的关系。</p>
<p><img src="https://images2018.cnblogs.com/blog/1152603/201805/1152603-20180520175827460-1911990238.png" alt="img"></p>
<p>可以看出，任意线程对Object（Object由synchronized保护）的方法，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列总的线程，使其重新尝试对监视器的获取。</p>
<h1 id="二、synchronized源码解析"><a href="#二、synchronized源码解析" class="headerlink" title="二、synchronized源码解析"></a>二、synchronized源码解析</h1><h2 id="00-灵魂图解"><a href="#00-灵魂图解" class="headerlink" title="00 灵魂图解"></a>00 灵魂图解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node may be on the WaitSet, the EntryList (or cxq), or in transition</span></span><br><span class="line"><span class="comment">// from the WaitSet to the EntryList.</span></span><br></pre></td></tr></table></figure>

<p>ObjectMonitor是一个对象监视器，前面的第一张图就是对ObjectMonitor的一个抽象。其中_EntryList 是一个双向链表，也就是我们抽象层中提到的EntryList，WaitSet 是一个环形双向链表，对应抽象层中的WaitSet，_cxq对应ContentionList.</p>
<p> _cxq ：存储ObjectWaiter对象的单向列表。多线程竞争锁时，会先进入此队列中。 </p>
<p>_EntryList：存储处于<strong>Blocked状态</strong>的ObjectWaiter对象列表。</p>
<p> _WaitSet：存储<strong>wait状态</strong>的ObjectWaiter对象列表。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialize the monitor, exception the semaphore, all other fields</span></span><br><span class="line"><span class="comment">// are simple integers or pointers</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = NULL;<span class="comment">//markOop对象头</span></span><br><span class="line">  _count        = <span class="number">0</span>;</span><br><span class="line">  _waiters      = <span class="number">0</span>,<span class="comment">//等待线程数</span></span><br><span class="line">  _recursions   = <span class="number">0</span>; <span class="comment">//线程的重入次数</span></span><br><span class="line">  _object       = NULL;</span><br><span class="line">  _owner        = NULL;<span class="comment">//标识拥有该monitor的线程</span></span><br><span class="line">  _WaitSet      = NULL; <span class="comment">//等待线程组成的双向循环链表，_WaitSet是第一个节点</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = NULL ;</span><br><span class="line">  _succ         = NULL ;</span><br><span class="line">  _cxq          = NULL ;<span class="comment">//多线程竞争锁进入时的单向链表</span></span><br><span class="line">  FreeNext      = NULL ;</span><br><span class="line">  _EntryList    = NULL ; <span class="comment">//_owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  _previous_owner_tid = <span class="number">0</span>;<span class="comment">//监视器前一个拥有线程的ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="D:\学习资料\面试题总结\并发编程\image-20200317183313545.png"></p>
<p><img src="D:\学习资料\面试题总结\并发编程\1.png"></p>
<p><img src="D:\学习资料\面试题总结\并发编程\68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162306164346662653f773d3131303126683d34303026663d7765627026733d3135363832.png"></p>
<h2 id="0-cmpxchg-ptr"><a href="#0-cmpxchg-ptr" class="headerlink" title="0 cmpxchg_ptr"></a>0 cmpxchg_ptr</h2><p>Atomic::cmpxchg_ptr方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值</p>
<h2 id="1-java对象实例-OOP-Klass-源码"><a href="#1-java对象实例-OOP-Klass-源码" class="headerlink" title="1 java对象实例-OOP-Klass(源码)"></a>1 java对象实例-OOP-Klass(源码)</h2><p>synchronized实现的锁是存储在<strong>Java对象头里</strong>，什么是对象头呢？在Hotspot虚拟机中，对象在内存中的存储布局，可以分为三个区域：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-a847c8ce7cb23ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/348/format/webp" alt="img"></p>
<p>当我们在Java代码中，使用<strong>new</strong>创建一个对象实例的时候，(Hotspot虚拟机)JVM层面实际上会创建一个<strong>instanceOopDesc</strong>对象。Hotspot虚拟机采用<strong>OOP-Klass二分模型</strong>来描述Java对象实例，其中<strong>OOP</strong>(Ordinary Object Point)指的是普通对象指针，它用来表示<strong>对象的实例信息</strong>，看起来像个指针实际上是藏在指针里的对象；而 <strong>Klass</strong> 则包含 <strong>元数据和方法信息</strong>，用来描述 Java 类。Hotspot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述<strong>数组类型</strong></p>
<p><strong>instanceOopDesc</strong>的定义在Hotspot源码中的instanceOop.hpp文件中，另外，arrayOopDesc的定义对应arrayOop.hpp(/hotspot/file/d17814ea88e3/src/share/vm/oops/instanceOop.hpp)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An instanceOop is an instance of a Java Class</span></span><br><span class="line"><span class="comment">// Evaluating &quot;new HashTable()&quot; will create an instanceOop.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// aligned header size.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(instanceOopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If compressed, the offset of the fields of the instance may not be aligned.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">base_offset_in_bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// offset computation code breaks if UseCompressedClassPointers</span></span><br><span class="line">    <span class="comment">// only is true</span></span><br><span class="line">    <span class="keyword">return</span> (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?</span><br><span class="line">             <span class="built_in">klass_gap_offset_in_bytes</span>() :</span><br><span class="line">             <span class="built_in"><span class="keyword">sizeof</span></span>(instanceOopDesc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">contains_field_offset</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> nonstatic_field_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base_in_bytes = <span class="built_in">base_offset_in_bytes</span>();</span><br><span class="line">    <span class="keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp;</span><br><span class="line">            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHARE_VM_OOPS_INSTANCEOOP_HPP</span></span></span><br></pre></td></tr></table></figure>

<p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义在Hotspot源码中的 oop.hpp文件中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// oopDesc is the top baseclass for objects classes.  The &#123;name&#125;Desc classes describe</span></span><br><span class="line"><span class="comment">// the format of Java objects so the fields can be accessed from C++.</span></span><br><span class="line"><span class="comment">// oopDesc is abstract.</span></span><br><span class="line"><span class="comment">// (see oopHierarchy for complete oop class hierarchy)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// no virtual functions allowed</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMCIVMStructs</span>;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  	<span class="comment">//oopDesc的定义包含两个成员，分别是_mark和_metadata。_mark表示对象标记、属于markOop类型，也就是接		下来要讲解的Mark Word，它记录了对象和锁的有关信息。_metadata表示类元信息，类元信息存储的是对象指向		它的类	元数据(Klass)的首地址，其中Klass表示普通指针、_compressed_klass表示压缩类指针。</span></span><br><span class="line">  <span class="keyword">volatile</span> markOop _mark;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">metadata</span> &#123;</span></span><br><span class="line">    Klass*      _klass;</span><br><span class="line">    narrowKlass _compressed_klass;</span><br><span class="line">  &#125; _metadata;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> markOop  <span class="title">mark</span><span class="params">()</span>          <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> markOop  <span class="title">mark_raw</span><span class="params">()</span>      <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> markOop* <span class="title">mark_addr_raw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_mark</span><span class="params">(<span class="keyword">volatile</span> markOop m)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_mark_raw</span><span class="params">(<span class="keyword">volatile</span> markOop m)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_mark_raw</span><span class="params">(HeapWord* mem, markOop m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">release_set_mark</span><span class="params">(markOop m)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> markOop <span class="title">cas_set_mark</span><span class="params">(markOop new_mark, markOop old_mark)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> markOop <span class="title">cas_set_mark_raw</span><span class="params">(markOop new_mark, markOop old_mark, atomic_memory_order order = memory_order_conservative)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used only to re-initialize the mark word (e.g., of promoted</span></span><br><span class="line">  <span class="comment">// objects during a GC) -- requires a valid klass pointer</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_mark</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_mark_raw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Klass* <span class="title">klass</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Klass* <span class="title">klass_or_null</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">volatile</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Klass* <span class="title">klass_or_null_acquire</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">volatile</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> Klass** <span class="title">klass_addr</span><span class="params">(HeapWord* mem)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> narrowKlass* <span class="title">compressed_klass_addr</span><span class="params">(HeapWord* mem)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Klass** <span class="title">klass_addr</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> narrowKlass* <span class="title">compressed_klass_addr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_klass</span><span class="params">(Klass* k)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">release_set_klass</span><span class="params">(HeapWord* mem, Klass* klass)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For klass field compression</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">klass_gap</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_klass_gap</span><span class="params">(<span class="keyword">int</span> z)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_klass_gap</span><span class="params">(HeapWord* mem, <span class="keyword">int</span> z)</span></span>;</span><br><span class="line">  <span class="comment">// For when the klass pointer is being used as a linked list &quot;next&quot; field.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_klass_to_list_ptr</span><span class="params">(oop k)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> oop <span class="title">list_ptr_from_klass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size of object header, aligned to platform wordSize</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(oopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns whether this is an instance of k or an instance of a subclass of k</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_a</span><span class="params">(Klass* k)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the actual oop size of the object</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sometimes (for complicated concurrency-related reasons), it is useful</span></span><br><span class="line">  <span class="comment">// to be able to figure out the size of an object knowing its klass.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">size_given_klass</span><span class="params">(Klass* klass)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// type test operations (inlined in oop.inline.hpp)</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_instance</span><span class="params">()</span>            <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_array</span><span class="params">()</span>               <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_objArray</span><span class="params">()</span>            <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_typeArray</span><span class="params">()</span>           <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// type test operations that don&#x27;t require inclusion of oop.inline.hpp.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_instance_noinline</span><span class="params">()</span>          <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_array_noinline</span><span class="params">()</span>             <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_objArray_noinline</span><span class="params">()</span>          <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_typeArray_noinline</span><span class="params">()</span>         <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> oop        <span class="title">as_oop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;oopDesc*&gt;(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// field addresses in oop</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="title">field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>     <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="title">field_addr_raw</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Need this as public for garbage collection.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">inline</span> T* <span class="title">obj_field_addr_raw</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">field_offset</span><span class="params">(T* p)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ######################## compare方法 ######################## </span></span><br><span class="line">  <span class="comment">// Standard compare function returns negative value if o1 &lt; o2</span></span><br><span class="line">  <span class="comment">//                                   0              if o1 == o2</span></span><br><span class="line">  <span class="comment">//                                   positive value if o1 &gt; o2</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">compare</span><span class="params">(oop o1, oop o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* o1_addr = (<span class="keyword">void</span>*)o1;</span><br><span class="line">    <span class="keyword">void</span>* o2_addr = (<span class="keyword">void</span>*)o2;</span><br><span class="line">    <span class="keyword">if</span> (o1_addr &lt; o2_addr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1_addr &gt; o2_addr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ######################## equals方法 ######################## </span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">equals</span><span class="params">(oop o1, oop o2)</span> </span>&#123; <span class="keyword">return</span> Access&lt;&gt;::<span class="built_in">equals</span>(o1, o2); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access to fields in a instanceOop through these methods.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;DecoratorSet decorator&gt;</span><br><span class="line">  <span class="function">oop <span class="title">obj_field_access</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">oop <span class="title">obj_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obj_field_put</span><span class="params">(<span class="keyword">int</span> offset, oop value)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obj_field_put_raw</span><span class="params">(<span class="keyword">int</span> offset, oop value)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obj_field_put_volatile</span><span class="params">(<span class="keyword">int</span> offset, oop value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Metadata* <span class="title">metadata_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">metadata_field_put</span><span class="params">(<span class="keyword">int</span> offset, Metadata* value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Metadata* <span class="title">metadata_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_metadata_field_put</span><span class="params">(<span class="keyword">int</span> offset, Metadata* value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jbyte <span class="title">byte_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">byte_field_put</span><span class="params">(<span class="keyword">int</span> offset, jbyte contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jchar <span class="title">char_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">char_field_put</span><span class="params">(<span class="keyword">int</span> offset, jchar contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jboolean <span class="title">bool_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bool_field_put</span><span class="params">(<span class="keyword">int</span> offset, jboolean contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jint <span class="title">int_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">int_field_put</span><span class="params">(<span class="keyword">int</span> offset, jint contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jshort <span class="title">short_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">short_field_put</span><span class="params">(<span class="keyword">int</span> offset, jshort contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jlong <span class="title">long_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">long_field_put</span><span class="params">(<span class="keyword">int</span> offset, jlong contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jfloat <span class="title">float_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">float_field_put</span><span class="params">(<span class="keyword">int</span> offset, jfloat contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jdouble <span class="title">double_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">double_field_put</span><span class="params">(<span class="keyword">int</span> offset, jdouble contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">address <span class="title">address_field</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">address_field_put</span><span class="params">(<span class="keyword">int</span> offset, address contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">oop <span class="title">obj_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_obj_field_put</span><span class="params">(<span class="keyword">int</span> offset, oop value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jbyte <span class="title">byte_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_byte_field_put</span><span class="params">(<span class="keyword">int</span> offset, jbyte contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jchar <span class="title">char_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_char_field_put</span><span class="params">(<span class="keyword">int</span> offset, jchar contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jboolean <span class="title">bool_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_bool_field_put</span><span class="params">(<span class="keyword">int</span> offset, jboolean contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jint <span class="title">int_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_int_field_put</span><span class="params">(<span class="keyword">int</span> offset, jint contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jshort <span class="title">short_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_short_field_put</span><span class="params">(<span class="keyword">int</span> offset, jshort contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jlong <span class="title">long_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_long_field_put</span><span class="params">(<span class="keyword">int</span> offset, jlong contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jfloat <span class="title">float_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_float_field_put</span><span class="params">(<span class="keyword">int</span> offset, jfloat contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">jdouble <span class="title">double_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_double_field_put</span><span class="params">(<span class="keyword">int</span> offset, jdouble contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">address <span class="title">address_field_acquire</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_address_field_put</span><span class="params">(<span class="keyword">int</span> offset, address contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printing functions for VM debugging</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_on</span><span class="params">(outputStream* st)</span> <span class="keyword">const</span></span>;         <span class="comment">// First level print</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_value_on</span><span class="params">(outputStream* st)</span> <span class="keyword">const</span></span>;   <span class="comment">// Second level print.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_address_on</span><span class="params">(outputStream* st)</span> <span class="keyword">const</span></span>; <span class="comment">// Address printing</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// printing on default output stream</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_value</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the print strings</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">print_string</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">print_value_string</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// verification operations</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify_on</span><span class="params">(outputStream* st)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// locking operations</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_locked</span><span class="params">()</span>   <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_unlocked</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">has_bias_pattern</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">has_bias_pattern_raw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// asserts and guarantees</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_oop</span><span class="params">(oop obj, <span class="keyword">bool</span> ignore_mark_word = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_oop_or_null</span><span class="params">(oop obj, <span class="keyword">bool</span> ignore_mark_word = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_unlocked_oop</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// garbage collection</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_gc_marked</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Forward pointer operations for scavenge</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_forwarded</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">forward_to</span><span class="params">(oop p)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cas_forward_to</span><span class="params">(oop p, markOop compare, atomic_memory_order order = memory_order_conservative)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like &quot;forward_to&quot;, but inserts the forwarding pointer atomically.</span></span><br><span class="line">  <span class="comment">// Exactly one thread succeeds in inserting the forwarding pointer, and</span></span><br><span class="line">  <span class="comment">// this call returns &quot;NULL&quot; for that thread; any other thread has the</span></span><br><span class="line">  <span class="comment">// value of the forwarding pointer returned and does not modify &quot;this&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> oop <span class="title">forward_to_atomic</span><span class="params">(oop p, atomic_memory_order order = memory_order_conservative)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> oop <span class="title">forwardee</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> oop <span class="title">forwardee_acquire</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Age of object during scavenge</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> uint <span class="title">age</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">incr_age</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mark-sweep support</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">follow_body</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Garbage Collection support</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INCLUDE_PARALLELGC</span></span><br><span class="line">  <span class="comment">// Parallel Compact</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc_follow_contents</span><span class="params">(ParCompactionManager* cm)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc_update_contents</span><span class="params">(ParCompactionManager* cm)</span></span>;</span><br><span class="line">  <span class="comment">// Parallel Scavenge</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ps_push_contents</span><span class="params">(PSPromotionManager* pm)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OopClosureType&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">oop_iterate</span><span class="params">(OopClosureType* cl)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OopClosureType&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">oop_iterate</span><span class="params">(OopClosureType* cl, MemRegion mr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OopClosureType&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">oop_iterate_size</span><span class="params">(OopClosureType* cl)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OopClosureType&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">oop_iterate_size</span><span class="params">(OopClosureType* cl, MemRegion mr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OopClosureType&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">oop_iterate_backwards</span><span class="params">(OopClosureType* cl)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_instanceof_or_null</span><span class="params">(oop obj, Klass* klass)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// identity hash; returns the identity hash key (computes it if necessary)</span></span><br><span class="line">  <span class="comment">// NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a</span></span><br><span class="line">  <span class="comment">// safepoint if called on a biased object. Calling code must be aware of that.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">identity_hash</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span> <span class="title">slow_identity_hash</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Alternate hashing code if string table is rehashed</span></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">new_hash</span><span class="params">(juint seed)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// marks are forwarded to stack when object is locked</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span>    <span class="title">has_displaced_mark_raw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> markOop <span class="title">displaced_mark_raw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>    <span class="title">set_displaced_mark_raw</span><span class="params">(markOop m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">has_klass_gap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for code generation</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mark_offset_in_bytes</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(oopDesc, _mark); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">klass_offset_in_bytes</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(oopDesc, _metadata._klass); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">klass_gap_offset_in_bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_klass_gap</span>(), <span class="string">&quot;only applicable to compressed klass pointers&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">klass_offset_in_bytes</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(narrowKlass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHARE_VM_OOPS_OOP_HPP</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在普通实例对象中，<strong>oopDesc</strong>的定义包含两个成员，分别是**<em>mark<strong>和</strong>_metadata<strong>。</strong>_mark**表示对象标记、属于markOop类型，也就是接下来要讲解的Mark Word，它记录了对象和锁的有关信息。</em><strong>metadata</strong>表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，<strong>其中Klass表示普通指针、compressed_klass表示压缩类指针。</strong></p>
<h2 id="2-Klass"><a href="#2-Klass" class="headerlink" title="2 Klass"></a>2 Klass</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Klass provides:</span></span><br><span class="line"><span class="comment">//  1: language level class object (method dictionary etc.)</span></span><br><span class="line"><span class="comment">//  2: provide vm dispatch behavior for the object</span></span><br><span class="line"><span class="comment">// Both functions are combined into one C++ class.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// One reason for the oop/klass dichotomy in the implementation is</span></span><br><span class="line"><span class="comment">// that we don&#x27;t want a C++ vtbl pointer in every object.  Thus,</span></span><br><span class="line"><span class="comment">// normal oops don&#x27;t have any virtual functions.  Instead, they</span></span><br><span class="line"><span class="comment">// forward all &quot;virtual&quot; functions to their klass, which does have</span></span><br><span class="line"><span class="comment">// a vtbl and does the C++ dispatch depending on the object&#x27;s</span></span><br><span class="line"><span class="comment">// actual type.  (See oop.inline.hpp for some of the forwarding code.)</span></span><br><span class="line"><span class="comment">// ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop_&quot;!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Klass layout:</span></span><br><span class="line"><span class="comment">//    [C++ vtbl ptr  ] (contained in Metadata)</span></span><br><span class="line"><span class="comment">//    [layout_helper ]</span></span><br><span class="line"><span class="comment">//    [super_check_offset   ] for fast subtype checks</span></span><br><span class="line"><span class="comment">//    [name          ]</span></span><br><span class="line"><span class="comment">//    [secondary_super_cache] for fast subtype checks</span></span><br><span class="line"><span class="comment">//    [secondary_supers     ] array of 2ndary supertypes</span></span><br><span class="line"><span class="comment">//    [primary_supers 0]</span></span><br><span class="line"><span class="comment">//    [primary_supers 1]</span></span><br><span class="line"><span class="comment">//    [primary_supers 2]</span></span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line"><span class="comment">//    [primary_supers 7]</span></span><br><span class="line"><span class="comment">//    [java_mirror   ]</span></span><br><span class="line"><span class="comment">//    [super         ]</span></span><br><span class="line"><span class="comment">//    [subklass      ] first subclass</span></span><br><span class="line"><span class="comment">//    [next_sibling  ] link to chain additional subklasses</span></span><br><span class="line"><span class="comment">//    [next_link     ]</span></span><br><span class="line"><span class="comment">//    [class_loader_data]</span></span><br><span class="line"><span class="comment">//    [modifier_flags]</span></span><br><span class="line"><span class="comment">//    [access_flags  ]</span></span><br><span class="line"><span class="comment">//    [last_biased_lock_bulk_revocation_time] (64 bits)</span></span><br><span class="line"><span class="comment">//    [prototype_header]//JVM中的每个类也有一个类似mark word的prototype_header</span></span><br><span class="line"><span class="comment">//    [biased_lock_revocation_count]</span></span><br><span class="line"><span class="comment">//    [_modified_oops]</span></span><br><span class="line"><span class="comment">//    [_accumulated_modified_oops]</span></span><br><span class="line"><span class="comment">//    [trace_id]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Biased locking support</span></span><br><span class="line">  <span class="comment">// Note: the prototype header is always set up to be at least the</span></span><br><span class="line">  <span class="comment">// prototype markOop. If biased locking is enabled it may further be</span></span><br><span class="line">  <span class="comment">// biasable and have an epoch.</span></span><br><span class="line">  <span class="function">markOop <span class="title">prototype_header</span><span class="params">()</span> <span class="keyword">const</span>      </span>&#123; <span class="keyword">return</span> _prototype_header; &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> once instances of this klass are floating around in the</span></span><br><span class="line">  <span class="comment">// system, this header must only be updated at a safepoint.</span></span><br><span class="line">  <span class="comment">// NOTE 2: currently we only ever set the prototype header to the</span></span><br><span class="line">  <span class="comment">// biasable prototype for instanceKlasses. There is no technical</span></span><br><span class="line">  <span class="comment">// reason why it could not be done for arrayKlasses aside from</span></span><br><span class="line">  <span class="comment">// wanting to reduce the initial scope of this optimization. There</span></span><br><span class="line">  <span class="comment">// are potential problems in setting the bias pattern for</span></span><br><span class="line">  <span class="comment">// JVM-internal oops.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_prototype_header</span><span class="params">(markOop header)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> ByteSize <span class="title">prototype_header_offset</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">in_ByteSize</span>(<span class="built_in">offset_of</span>(Klass, _prototype_header)); &#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-Mark-Word-markOop"><a href="#3-Mark-Word-markOop" class="headerlink" title="3 Mark Word-markOop"></a>3 Mark Word-markOop</h2><p>markOop官方称为Mark Word 在Hotspot中，markOop的定义在 markOop.hpp文件中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The markOop describes the header of an object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that the mark is not a real oop but just a word.</span></span><br><span class="line"><span class="comment">// It is placed in the oop hierarchy for historical reasons.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - hash contains the identity hash value: largest value is</span></span><br><span class="line"><span class="comment">//    31 bits, see os::random().  Also, 64-bit vm&#x27;s require</span></span><br><span class="line"><span class="comment">//    a hash value no bigger than 32 bits because they will not</span></span><br><span class="line"><span class="comment">//    properly generate a mask larger than that: see library_call.cpp</span></span><br><span class="line"><span class="comment">//    and c1_CodePatterns_sparc.cpp.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - the biased lock pattern is used to bias a lock toward a given</span></span><br><span class="line"><span class="comment">//    thread. When this pattern is set in the low three bits, the lock</span></span><br><span class="line"><span class="comment">//    is either biased toward a given thread or &quot;anonymously&quot; biased,</span></span><br><span class="line"><span class="comment">//    indicating that it is possible for it to be biased. </span></span><br><span class="line"><span class="comment">//		################################## When the ##################################</span></span><br><span class="line"><span class="comment">//    lock is biased toward a given thread, locking and unlocking can</span></span><br><span class="line"><span class="comment">//    be performed by that thread without using atomic operations.</span></span><br><span class="line"><span class="comment">//    When a lock&#x27;s bias is revoked, it reverts back to the normal</span></span><br><span class="line"><span class="comment">//    locking scheme described below.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    Note also that the biased state contains the age bits normally</span></span><br><span class="line"><span class="comment">//    contained in the object header. Large increases in scavenge</span></span><br><span class="line"><span class="comment">//    times were seen when these bits were absent and an arbitrary age</span></span><br><span class="line"><span class="comment">//    assigned to all biased objects, because they tended to consume a</span></span><br><span class="line"><span class="comment">//    significant fraction of the eden semispaces and were not</span></span><br><span class="line"><span class="comment">//    promoted promptly, causing an increase in the amount of copying</span></span><br><span class="line"><span class="comment">//    performed. The runtime system aligns all JavaThread* pointers to</span></span><br><span class="line"><span class="comment">//    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))</span></span><br><span class="line"><span class="comment">//    to make room for the age bits &amp; the epoch bits (used in support of</span></span><br><span class="line"><span class="comment">//    biased locking), and for the CMS &quot;freeness&quot; bit in the 64bVM (+COOPs).</span></span><br><span class="line"><span class="comment">//		#################################### 还有匿名锁呢 ###########################  </span></span><br><span class="line"><span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span></span><br><span class="line"><span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span></span><br><span class="line"><span class="comment">//当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式，那新创建对象的mark word将是可偏向状态，此时mark word中的thread id为0，表示未偏向任何线程，也叫做匿名偏向 anonymously biased</span></span><br><span class="line"><span class="comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></span><br><span class="line"><span class="comment">//		#################################### 对应的锁状态 ###########################  </span></span><br><span class="line"><span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></span><br><span class="line"><span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></span><br><span class="line"><span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></span><br><span class="line"><span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></span><br><span class="line"><span class="comment">//                                               not valid at any other time</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">markOopDesc</span>:</span> <span class="keyword">public</span> oopDesc &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Conversion</span></span><br><span class="line">  <span class="function"><span class="keyword">uintptr_t</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>) <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:<span class="comment">//markWord的存储结构：数字代表位数</span></span><br><span class="line">  <span class="comment">// Constants</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> age_bits                 = <span class="number">4</span>,<span class="comment">//对象分代年龄</span></span><br><span class="line">         lock_bits                = <span class="number">2</span>,<span class="comment">//锁标志位</span></span><br><span class="line">         biased_lock_bits         = <span class="number">1</span>,<span class="comment">//是否是偏向锁</span></span><br><span class="line">         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span><br><span class="line">         hash_bits                = max_hash_bits &gt; <span class="number">31</span> ? <span class="number">31</span> : max_hash_bits,<span class="comment">//hashcode</span></span><br><span class="line">         cms_bits                 = <span class="built_in">LP64_ONLY</span>(<span class="number">1</span>) <span class="built_in">NOT_LP64</span>(<span class="number">0</span>),<span class="comment">//GC 标记</span></span><br><span class="line">         epoch_bits               = <span class="number">2</span><span class="comment">//时间戳</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The biased locking code currently requires that the age bits be</span></span><br><span class="line">  <span class="comment">// contiguous to the lock bits.</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> lock_shift               = <span class="number">0</span>,</span><br><span class="line">         biased_lock_shift        = lock_bits,</span><br><span class="line">         age_shift                = lock_bits + biased_lock_bits,</span><br><span class="line">         cms_shift                = age_shift + age_bits,</span><br><span class="line">         hash_shift               = cms_shift + cms_bits,</span><br><span class="line">         epoch_shift              = hash_shift</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> lock_mask                = <span class="built_in">right_n_bits</span>(lock_bits),</span><br><span class="line">         lock_mask_in_place       = lock_mask &lt;&lt; lock_shift,</span><br><span class="line">         biased_lock_mask         = <span class="built_in">right_n_bits</span>(lock_bits + biased_lock_bits),</span><br><span class="line">         biased_lock_mask_in_place= biased_lock_mask &lt;&lt; lock_shift,</span><br><span class="line">         biased_lock_bit_in_place = <span class="number">1</span> &lt;&lt; biased_lock_shift,</span><br><span class="line">         age_mask                 = <span class="built_in">right_n_bits</span>(age_bits),</span><br><span class="line">         age_mask_in_place        = age_mask &lt;&lt; age_shift,</span><br><span class="line">         epoch_mask               = <span class="built_in">right_n_bits</span>(epoch_bits),</span><br><span class="line">         epoch_mask_in_place      = epoch_mask &lt;&lt; epoch_shift,</span><br><span class="line">         cms_mask                 = <span class="built_in">right_n_bits</span>(cms_bits),</span><br><span class="line">         cms_mask_in_place        = cms_mask &lt;&lt; cms_shift</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN64</span></span><br><span class="line">         ,hash_mask               = <span class="built_in">right_n_bits</span>(hash_bits),</span><br><span class="line">         hash_mask_in_place       = (address_word)hash_mask &lt;&lt; hash_shift</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Alignment of JavaThread pointers encoded in object header required by biased locking</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> biased_lock_alignment    = <span class="number">2</span> &lt;&lt; (epoch_shift + epoch_bits)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="comment">// These values are too big for Win64</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">uintptr_t</span> hash_mask = <span class="built_in">right_n_bits</span>(hash_bits);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">uintptr_t</span> hash_mask_in_place  =</span><br><span class="line">                            (address_word)hash_mask &lt;&lt; hash_shift;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> locked_value             = <span class="number">0</span>,<span class="comment">//锁的状态对应的十进制</span></span><br><span class="line">         unlocked_value           = <span class="number">1</span>,</span><br><span class="line">         monitor_value            = <span class="number">2</span>,</span><br><span class="line">         marked_value             = <span class="number">3</span>,</span><br><span class="line">         biased_lock_pattern      = <span class="number">5</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> no_hash                  = <span class="number">0</span> &#125;;  <span class="comment">// no hash value assigned</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> no_hash_in_place         = (address_word)no_hash &lt;&lt; hash_shift,</span><br><span class="line">         no_lock_in_place         = unlocked_value</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> max_age                  = age_mask &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> max_bias_epoch           = epoch_mask &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Biased Locking accessors.</span></span><br><span class="line">  <span class="comment">// These must be checked by all code which calls into the</span></span><br><span class="line">  <span class="comment">// ObjectSynchronizer and other code. The biasing is not understood</span></span><br><span class="line">  <span class="comment">// by the lower-level CAS-based locking code, although the runtime</span></span><br><span class="line">  <span class="comment">// fixes up biased locks to be compatible with it when a bias is</span></span><br><span class="line">  <span class="comment">// revoked.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">has_bias_pattern</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), biased_lock_mask_in_place) == biased_lock_pattern);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">JavaThread* <span class="title">biased_locker</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not call this otherwise&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (JavaThread*) ((<span class="keyword">intptr_t</span>) (<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Indicates that the mark has the bias bit set but that it has not</span></span><br><span class="line">  <span class="comment">// yet been biased toward a particular thread</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_biased_anonymously</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">has_bias_pattern</span>() &amp;&amp; (<span class="built_in">biased_locker</span>() == <span class="literal">NULL</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Indicates epoch in which this bias was acquired. If the epoch</span></span><br><span class="line">  <span class="comment">// changes due to too many bias revocations occurring, the biases</span></span><br><span class="line">  <span class="comment">// from the previous epochs are all considered invalid.</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">bias_epoch</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not call this otherwise&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), epoch_mask_in_place) &gt;&gt; epoch_shift);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">markOop <span class="title">set_bias_epoch</span><span class="params">(<span class="keyword">int</span> epoch)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not call this otherwise&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>((epoch &amp; (~epoch_mask)) == <span class="number">0</span>, <span class="string">&quot;epoch overflow&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">markOop</span>(<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), ~epoch_mask_in_place) | (epoch &lt;&lt; epoch_shift));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">markOop <span class="title">incr_bias_epoch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set_bias_epoch</span>((<span class="number">1</span> + <span class="built_in">bias_epoch</span>()) &amp; epoch_mask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Prototype mark for initialization</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">biased_locking_prototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">markOop</span>( biased_lock_pattern );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// lock accessors (note that these assume lock_shift == 0)</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_locked</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), lock_mask_in_place) != unlocked_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_unlocked</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), biased_lock_mask_in_place) == unlocked_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_marked</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), lock_mask_in_place) == marked_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_neutral</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">mask_bits</span>(<span class="built_in">value</span>(), biased_lock_mask_in_place) == unlocked_value); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Special temporary state of the markOop while being inflated.</span></span><br><span class="line">  <span class="comment">// Code that looks at mark outside a lock need to take this into account.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_being_inflated</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">value</span>() == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Distinguished markword value - used when inflating over</span></span><br><span class="line">  <span class="comment">// an existing stacklock.  0 indicates the markword is &quot;BUSY&quot;.</span></span><br><span class="line">  <span class="comment">// Lockword mutators that use a LD...CAS idiom should always</span></span><br><span class="line">  <span class="comment">// check for and avoid overwriting a 0 value installed by some</span></span><br><span class="line">  <span class="comment">// other thread.  (They should spin or block instead.  The 0 value</span></span><br><span class="line">  <span class="comment">// is transient and *should* be short-lived).</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">INFLATING</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (markOop) <span class="number">0</span>; &#125;    <span class="comment">// inflate-in-progress</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Should this header be preserved during GC?</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">must_be_preserved</span><span class="params">(oop obj_containing_mark)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">must_be_preserved_with_bias</span><span class="params">(oop obj_containing_mark)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Should this header (including its age bits) be preserved in the</span></span><br><span class="line">  <span class="comment">// case of a promotion failure during scavenge?</span></span><br><span class="line">  <span class="comment">// Note that we special case this situation. We want to avoid</span></span><br><span class="line">  <span class="comment">// calling BiasedLocking::preserve_marks()/restore_marks() (which</span></span><br><span class="line">  <span class="comment">// decrease the number of mark words that need to be preserved</span></span><br><span class="line">  <span class="comment">// during GC) during each scavenge. During scavenges in which there</span></span><br><span class="line">  <span class="comment">// is no promotion failure, we actually don&#x27;t need to call the above</span></span><br><span class="line">  <span class="comment">// routines at all, since we don&#x27;t mutate and re-initialize the</span></span><br><span class="line">  <span class="comment">// marks of promoted objects using init_mark(). However, during</span></span><br><span class="line">  <span class="comment">// scavenges which result in promotion failure, we do re-initialize</span></span><br><span class="line">  <span class="comment">// the mark words of objects, meaning that we should have called</span></span><br><span class="line">  <span class="comment">// these mark word preservation routines. Currently there&#x27;s no good</span></span><br><span class="line">  <span class="comment">// place in which to call them in any of the scavengers (although</span></span><br><span class="line">  <span class="comment">// guarded by appropriate locks we could make one), but the</span></span><br><span class="line">  <span class="comment">// observation is that promotion failures are quite rare and</span></span><br><span class="line">  <span class="comment">// reducing the number of mark words preserved during them isn&#x27;t a</span></span><br><span class="line">  <span class="comment">// high priority.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">must_be_preserved_for_promotion_failure</span><span class="params">(oop obj_containing_mark)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">must_be_preserved_with_bias_for_promotion_failure</span><span class="params">(oop obj_containing_mark)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Should this header be preserved during a scavenge where CMS is</span></span><br><span class="line">  <span class="comment">// the old generation?</span></span><br><span class="line">  <span class="comment">// (This is basically the same body as must_be_preserved_for_promotion_failure(),</span></span><br><span class="line">  <span class="comment">// but takes the Klass* as argument instead)</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">must_be_preserved_for_cms_scavenge</span><span class="params">(Klass* klass_of_obj_containing_mark)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">must_be_preserved_with_bias_for_cms_scavenge</span><span class="params">(Klass* klass_of_obj_containing_mark)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// WARNING: The following routines are used EXCLUSIVELY by</span></span><br><span class="line">  <span class="comment">// synchronization functions. They are not really gc safe.</span></span><br><span class="line">  <span class="comment">// They must get updated if markOop layout get changed.</span></span><br><span class="line">  <span class="function">markOop <span class="title">set_unlocked</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">markOop</span>(<span class="built_in">value</span>() | unlocked_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">has_locker</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">value</span>() &amp; lock_mask_in_place) == locked_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">BasicLock* <span class="title">locker</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_locker</span>(), <span class="string">&quot;check&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (BasicLock*) <span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">has_monitor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">value</span>() &amp; monitor_value) != <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//monitor相关的代码</span></span><br><span class="line">  <span class="function">ObjectMonitor* <span class="title">monitor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_monitor</span>(), <span class="string">&quot;check&quot;</span>);</span><br><span class="line">    <span class="comment">// Use xor instead of &amp;~ to provide one extra tag-bit check.</span></span><br><span class="line">    <span class="keyword">return</span> (ObjectMonitor*) (<span class="built_in">value</span>() ^ monitor_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">has_displaced_mark_helper</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">value</span>() &amp; unlocked_value) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">markOop <span class="title">displaced_mark_helper</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_displaced_mark_helper</span>(), <span class="string">&quot;check&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> ptr = (<span class="built_in">value</span>() &amp; ~monitor_value);</span><br><span class="line">    <span class="keyword">return</span> *(markOop*)ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_displaced_mark_helper</span><span class="params">(markOop m)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_displaced_mark_helper</span>(), <span class="string">&quot;check&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> ptr = (<span class="built_in">value</span>() &amp; ~monitor_value);</span><br><span class="line">    *(markOop*)ptr = m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">markOop <span class="title">copy_set_hash</span><span class="params">(<span class="keyword">intptr_t</span> hash)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> tmp = <span class="built_in">value</span>() &amp; (~hash_mask_in_place);</span><br><span class="line">    tmp |= ((hash &amp; hash_mask) &lt;&lt; hash_shift);</span><br><span class="line">    <span class="keyword">return</span> (markOop)tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// it is only used to be stored into BasicLock as the</span></span><br><span class="line">  <span class="comment">// indicator that the lock is using heavyweight monitor</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">unused_mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (markOop) marked_value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// the following two functions create the markOop to be</span></span><br><span class="line">  <span class="comment">// stored into object header, it encodes monitor info</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">encode</span><span class="params">(BasicLock* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (markOop) lock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">encode</span><span class="params">(ObjectMonitor* monitor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> tmp = (<span class="keyword">intptr_t</span>) monitor;</span><br><span class="line">    <span class="keyword">return</span> (markOop) (tmp | monitor_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">encode</span><span class="params">(JavaThread* thread, uint age, <span class="keyword">int</span> bias_epoch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> tmp = (<span class="keyword">intptr_t</span>) thread;</span><br><span class="line">    <span class="built_in">assert</span>(UseBiasedLocking &amp;&amp; ((tmp &amp; (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == <span class="number">0</span>), <span class="string">&quot;misaligned JavaThread pointer&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(age &lt;= max_age, <span class="string">&quot;age too large&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(bias_epoch &lt;= max_bias_epoch, <span class="string">&quot;bias epoch too large&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (markOop) (tmp | (bias_epoch &lt;&lt; epoch_shift) | (age &lt;&lt; age_shift) | biased_lock_pattern);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// used to encode pointers during GC</span></span><br><span class="line">  <span class="function">markOop <span class="title">clear_lock_bits</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">markOop</span>(<span class="built_in">value</span>() &amp; ~lock_mask_in_place); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// age operations</span></span><br><span class="line">  <span class="function">markOop <span class="title">set_marked</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> <span class="built_in">markOop</span>((<span class="built_in">value</span>() &amp; ~lock_mask_in_place) | marked_value); &#125;</span><br><span class="line">  <span class="function">markOop <span class="title">set_unmarked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">markOop</span>((<span class="built_in">value</span>() &amp; ~lock_mask_in_place) | unlocked_value); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">uint    <span class="title">age</span><span class="params">()</span>               <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mask_bits</span>(<span class="built_in">value</span>() &gt;&gt; age_shift, age_mask); &#125;</span><br><span class="line">  <span class="function">markOop <span class="title">set_age</span><span class="params">(uint v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>((v &amp; ~age_mask) == <span class="number">0</span>, <span class="string">&quot;shouldn&#x27;t overflow age field&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">markOop</span>((<span class="built_in">value</span>() &amp; ~age_mask_in_place) | (((<span class="keyword">uintptr_t</span>)v &amp; age_mask) &lt;&lt; age_shift));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">markOop <span class="title">incr_age</span><span class="params">()</span>          <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">age</span>() == max_age ? <span class="built_in">markOop</span>(<span class="keyword">this</span>) : <span class="built_in">set_age</span>(<span class="built_in">age</span>() + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hash operations</span></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span> <span class="title">hash</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mask_bits</span>(<span class="built_in">value</span>() &gt;&gt; hash_shift, hash_mask);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">has_no_hash</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>() == no_hash;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prototype mark for initialization</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">prototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">markOop</span>( no_hash_in_place | no_lock_in_place );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Helper function for restoration of unmarked mark oops during GC</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> markOop <span class="title">prototype_for_object</span><span class="params">(oop obj)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Debugging</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_on</span><span class="params">(outputStream* st)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prepare address of oop for placement into mark</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> markOop <span class="title">encode_pointer_as_mark</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">markOop</span>(p)-&gt;<span class="built_in">set_marked</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover address of oop from encoded form used in mark</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="title">decode_pointer</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (UseBiasedLocking &amp;&amp; <span class="built_in">has_bias_pattern</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="keyword">return</span> <span class="built_in">clear_lock_bits</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These markOops indicate cms free chunk blocks and not objects.</span></span><br><span class="line">  <span class="comment">// In 64 bit, the markOop is set to distinguish them from oops.</span></span><br><span class="line">  <span class="comment">// These are defined in 32 bit mode for vmStructs.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">uintptr_t</span> cms_free_chunk_pattern  = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constants for the size field.</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> size_shift                = cms_shift + cms_bits,</span><br><span class="line">         size_bits                 = <span class="number">35</span>    <span class="comment">// need for compressed oops 32G</span></span><br><span class="line">       &#125;;</span><br><span class="line">  <span class="comment">// These values are too big for Win64</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">uintptr_t</span> size_mask = <span class="built_in">LP64_ONLY</span>(<span class="built_in">right_n_bits</span>(size_bits))</span><br><span class="line">                                     <span class="built_in">NOT_LP64</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">uintptr_t</span> size_mask_in_place =</span><br><span class="line">                                     (address_word)size_mask &lt;&lt; size_shift;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">cms_free_prototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">markOop</span>(((<span class="keyword">intptr_t</span>)<span class="built_in">prototype</span>() &amp; ~cms_mask_in_place) |</span><br><span class="line">                   ((cms_free_chunk_pattern &amp; cms_mask) &lt;&lt; cms_shift));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uintptr_t</span> <span class="title">cms_encoding</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mask_bits</span>(<span class="built_in">value</span>() &gt;&gt; cms_shift, cms_mask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_cms_free_chunk</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_neutral</span>() &amp;&amp;</span><br><span class="line">           (<span class="built_in">cms_encoding</span>() &amp; cms_free_chunk_pattern) == cms_free_chunk_pattern;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">get_size</span><span class="params">()</span> <span class="keyword">const</span>       </span>&#123; <span class="keyword">return</span> (<span class="keyword">size_t</span>)(<span class="built_in">value</span>() &gt;&gt; size_shift); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">set_size_and_free</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>((size &amp; ~size_mask) == <span class="number">0</span>, <span class="string">&quot;shouldn&#x27;t overflow size field&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">markOop</span>(((<span class="keyword">intptr_t</span>)<span class="built_in">cms_free_prototype</span>() &amp; ~size_mask_in_place) |</span><br><span class="line">                   (((<span class="keyword">intptr_t</span>)size &amp; size_mask) &lt;&lt; size_shift));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _LP64</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHARE_VM_OOPS_MARKOOP_HPP</span></span></span><br></pre></td></tr></table></figure>

<p>锁标志位的表示意义：</p>
<ul>
<li>锁标识lock=00标识轻量级锁</li>
<li>锁标识lock=10标识重量级锁</li>
<li>偏向锁标识biased_lock=1标识偏向锁</li>
<li>偏向锁标识biased_lock=0标识无锁状态</li>
</ul>
<p><strong>综上所述，synchronized(lock)中的lock可以用Java中任何一个对象来表示，而锁标识的存储实际上就是在lock这个对象中的对象头内。</strong></p>
<h2 id="4-ObjectMonitor"><a href="#4-ObjectMonitor" class="headerlink" title="4 ObjectMonitor"></a>4 ObjectMonitor</h2><p><strong>其实前面只提到了锁标志位的存储，但是为什么任意一个Java对象都能成为锁对象呢？</strong><br> Java中的每个对象都派生自Object类，而每个Java Object在JVM内部都有一个native的C++对象oop/oopDesc进行对应。其次，线程在获取锁的时候，实际上就是获得一个监视器对象(monitor)，monitor可以认为是一个同步对象，所有的Java对象是天生携带monitor。在<strong>hotspot源码的markOop.hpp文件中</strong>，可以看到下面这段代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ObjectMonitor* <span class="title">monitor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">has_monitor</span>(), <span class="string">&quot;check&quot;</span>);</span><br><span class="line">    <span class="comment">// Use xor instead of &amp;~ to provide one extra tag-bit check.</span></span><br><span class="line">    <span class="keyword">return</span> (ObjectMonitor*) (<span class="built_in">value</span>() ^ monitor_value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ObjectMonitor.hpp</code>中，可以看到<code>ObjectMonitor</code>的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialize the monitor, exception the semaphore, all other fields</span></span><br><span class="line"><span class="comment">// are simple integers or pointers</span></span><br><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">  _header       = <span class="literal">NULL</span>;<span class="comment">//markOop对象头</span></span><br><span class="line">  _count        = <span class="number">0</span>;<span class="comment">//拥有该monitor之后count置1</span></span><br><span class="line">  _waiters      = <span class="number">0</span>,<span class="comment">//等待线程数</span></span><br><span class="line">  _recursions   = <span class="number">0</span>; <span class="comment">//线程的重入次数</span></span><br><span class="line">  _object       = <span class="literal">NULL</span>;</span><br><span class="line">  _owner        = <span class="literal">NULL</span>;<span class="comment">//标识拥有该monitor的线程</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//等待线程组成的双向循环链表，_WaitSet是第一个节点</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ;<span class="comment">//多线程竞争锁进入时的单向链表</span></span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//_owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  _previous_owner_tid = <span class="number">0</span>;<span class="comment">//监视器前一个拥有线程的ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>捎带看一下ObjectWaiter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node may be on the WaitSet, the EntryList (or cxq), or in transition</span></span><br><span class="line"><span class="comment">// from the WaitSet to the EntryList.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// ObjectWaiter serves as a &quot;proxy&quot; or surrogate thread.</span></span><br><span class="line">&gt;<span class="comment">// TODO-<span class="doctag">FIXME:</span> Eliminate ObjectWaiter and use the thread-specific</span></span><br><span class="line">&gt;<span class="comment">// ParkEvent instead.  Beware, however, that the JVMTI code</span></span><br><span class="line">&gt;<span class="comment">// knows about ObjectWaiters, so we&#x27;ll have to reconcile that code.</span></span><br><span class="line">&gt;<span class="comment">// See next_waiter(), first_waiter(), etc.</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span> :</span> <span class="keyword">public</span> StackObj &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">TStates</span> &#123;</span> TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ &#125; ;<span class="comment">//状态</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">Sorted</span>  &#123;</span> PREPEND, APPEND, SORTED &#125; ;<span class="comment">//List placement disposition</span></span><br><span class="line"> ObjectWaiter * <span class="keyword">volatile</span> _next;</span><br><span class="line"> ObjectWaiter * <span class="keyword">volatile</span> _prev;</span><br><span class="line"> Thread*       _thread;</span><br><span class="line"> jlong         _notifier_tid;</span><br><span class="line"> ParkEvent *   _event;</span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">int</span>  _notified ;</span><br><span class="line"> <span class="keyword">volatile</span> TStates TState ;</span><br><span class="line"> Sorted        _Sorted ;           <span class="comment">// List placement disposition</span></span><br><span class="line"> <span class="keyword">bool</span>          _active ;           <span class="comment">// Contention monitoring is enabled</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">ObjectWaiter</span>(Thread* thread);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_begin</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_end</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>所以同步块的实现使用 <strong>monitorenter</strong>和 <strong>monitorexit</strong>指令，而同步方法是依靠方法修饰符上的flag <strong>ACC_SYNCHRONIZED</strong>来完成。其<strong>本质是对一个对象监视器(monitor)进行获取</strong>，这个获取过程是<strong>排他</strong>的，也就是同一个时刻只能有一个线程获得由synchronized所保护对象的监视器。所谓的监视器，实际上可以理解为一个同步工具，它是由Java对象进行描述的。在Hotspot中，是通过ObjectMonitor来实现，<strong>每个对象中都会内置一个ObjectMonitor对象</strong>。如图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-2c15414bf1e0f5d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1040/format/webp" alt="img"></p>
<h2 id="5-偏向锁入口"><a href="#5-偏向锁入口" class="headerlink" title="5 偏向锁入口"></a>5 偏向锁入口</h2><p>要找锁的入口，肯定是要在源码中找到对<code>monitorenter</code>指令解析的地方。在HotSpot的中有两处地方对<code>monitorenter</code>指令进行解析：一个是在<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816">bytecodeInterpreter.cpp#1816</a> ，另一个是在<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/cpu/x86/vm/templateTable_x86_64.cpp#l3667">templateTable_x86_64.cpp#3667</a>。</p>
<p>前者是JVM中的字节码解释器(<code>bytecodeInterpreter</code>)，用C++实现了每条JVM指令（如<code>monitorenter</code>、<code>invokevirtual</code>等），其优点是实现相对简单且容易理解，缺点是执行慢。后者是模板解释器(<code>templateInterpreter</code>)，其对每个指令都写了一段对应的汇编代码，启动时将每个指令与对应汇编代码入口绑定，可以说是效率做到了极致。<a target="_blank" rel="noopener" href="https://book.douban.com/annotation/31407691/">参考1</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33886967">参考2</a></p>
<p>所以<code>montorenter</code>的解析入口在模板解释器中，其代码位于<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/cpu/x86/vm/templateTable_x86_64.cpp#l3667">templateTable_x86_64.cpp#3667</a>。通过调用路径：<code>templateTable_x86_64#monitorenter</code>-&gt;<code>interp_masm_x86_64#lock_object</code>进入到偏向锁入口<code>macroAssembler_x86#biased_locking_enter</code>，在这里大家可以看到会生成对应的汇编代码。需要注意的是，不是说每次解析<code>monitorenter</code>指令都会调用<code>biased_locking_enter</code>,而是只会在JVM启动的时候调用该方法生成汇编代码，之后对指令的解析是通过直接执行汇编代码。其实<code>bytecodeInterpreter</code>的逻辑和<code>templateInterpreter</code>的逻辑是大同小异的，因为<code>templateInterpreter</code>中都是汇编代码，比较晦涩，所以看<code>bytecodeInterpreter</code>的实现会便于理解一点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* monitorenter and monitorexit for locking/unlocking an object */</span></span><br><span class="line"><span class="built_in">CASE</span>(_monitorenter): &#123;</span><br><span class="line">  <span class="comment">// lockee 就是锁对象</span></span><br><span class="line">  oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// derefing&#x27;s lockee ought to provoke implicit null check</span></span><br><span class="line">  <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">  <span class="comment">// ############# code 1：找到一个空闲的Lock Record #############</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">  BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == <span class="literal">NULL</span>) entry = most_recent;<span class="comment">//获取entry？？</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == lockee) <span class="keyword">break</span>;</span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//entry不为null，代表还有空闲的Lock Record</span></span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// ############# code 2：将Lock Record的obj指针指向锁对象 #############</span></span><br><span class="line">    entry-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">    <span class="keyword">int</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> epoch_mask_in_place = (<span class="keyword">uintptr_t</span>)markOopDesc::epoch_mask_in_place;</span><br><span class="line">	<span class="comment">// markoop即对象头的mark word</span></span><br><span class="line">    markOop mark = lockee-&gt;<span class="built_in">mark</span>();</span><br><span class="line">    <span class="keyword">intptr_t</span> hash = (<span class="keyword">intptr_t</span>) markOopDesc::no_hash;</span><br><span class="line">    <span class="comment">// ############# code 3：如果锁对象的mark word的状态是偏向模式 #############</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      <span class="keyword">uintptr_t</span> thread_ident;</span><br><span class="line">      <span class="keyword">uintptr_t</span> anticipated_bias_locking_value;</span><br><span class="line">      thread_ident = (<span class="keyword">uintptr_t</span>)istate-&gt;<span class="built_in">thread</span>();</span><br><span class="line">     <span class="comment">// ############# code 4：这里有几步操作，下文分析 #############</span></span><br><span class="line">      anticipated_bias_locking_value =</span><br><span class="line">        (((<span class="keyword">uintptr_t</span>)lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | thread_ident) ^ (<span class="keyword">uintptr_t</span>)mark) &amp;</span><br><span class="line">        ~((<span class="keyword">uintptr_t</span>) markOopDesc::age_mask_in_place);</span><br><span class="line">	 <span class="comment">// ############# code 5：如果偏向的线程是自己且epoch等于class的epoch############# </span></span><br><span class="line">      <span class="keyword">if</span>  (anticipated_bias_locking_value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// already biased towards this thread, nothing to do</span></span><br><span class="line">        <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">          (* BiasedLocking::<span class="built_in">biased_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// ############# code 6：如果偏向模式关闭，则尝试撤销偏向锁 #############</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="number">0</span>) &#123;</span><br><span class="line">        markOop header = lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//############# 撤销偏向锁 #############</span></span><br><span class="line">        <span class="comment">// #############利用CAS操作将mark word替换为class中的mark word#############</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (*BiasedLocking::<span class="built_in">revoked_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="comment">// ############# code 7：如果epoch不等于class中的epoch，则尝试重偏向 #############</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构造一个偏向当前线程的mark word</span></span><br><span class="line">        markOop new_header = (markOop) ( (<span class="keyword">intptr_t</span>) lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | thread_ident);</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          new_header = new_header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS替换对象头的mark word  </span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="keyword">void</span>*)new_header, lockee-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::<span class="built_in">rebiased_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级</span></span><br><span class="line">          <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）</span></span><br><span class="line">       	<span class="comment">// ### code 8：下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word ## </span></span><br><span class="line">        markOop header = (markOop) ((<span class="keyword">uintptr_t</span>) mark &amp; ((<span class="keyword">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |(<span class="keyword">uintptr_t</span>)markOopDesc::age_mask_in_place |epoch_mask_in_place));</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        markOop new_header = (markOop) ((<span class="keyword">uintptr_t</span>) header | thread_ident);</span><br><span class="line">        <span class="comment">// debugging hint</span></span><br><span class="line">        <span class="built_in">DEBUG_ONLY</span>(entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>((markOop) (<span class="keyword">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="keyword">void</span>*)new_header, lockee-&gt;<span class="built_in">mark_addr</span>(), header) == header) &#123;</span><br><span class="line">           <span class="comment">// CAS修改成功</span></span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::<span class="built_in">anonymously_biased_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果修改失败说明存在多线程竞争，所以进入monitorenter方法</span></span><br><span class="line">          <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      <span class="comment">// 轻量级锁的逻辑</span></span><br><span class="line">      <span class="comment">//##### code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它 ######</span></span><br><span class="line">      markOop displaced = lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">set_unlocked</span>();</span><br><span class="line">      entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(displaced);</span><br><span class="line">      <span class="comment">//如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁。用重量级锁</span></span><br><span class="line">      <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">      <span class="comment">// 利用CAS将对象头的mark word替换为指向Lock Record的指针</span></span><br><span class="line">      <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(entry, lockee-&gt;<span class="built_in">mark_addr</span>(), displaced) != displaced) &#123;</span><br><span class="line">        <span class="comment">// 判断是不是锁重入</span></span><br><span class="line">        <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) displaced-&gt;<span class="built_in">clear_lock_bits</span>())) &#123;		</span><br><span class="line">		  <span class="comment">//####### code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null ######## </span></span><br><span class="line">          entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// lock record不够，重新执行</span></span><br><span class="line">    istate-&gt;<span class="built_in">set_msg</span>(more_monitors);</span><br><span class="line">    <span class="built_in">UPDATE_PC_AND_RETURN</span>(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM中的每个类也有一个类似mark word的prototype_header，用来标记该class的epoch和偏向开关等信息，见<strong>Klass类源码</strong>。上面的代码中<code>lockee-&gt;klass()-&gt;prototype_header()</code>即获取class的prototype_header。</p>
<p><strong>code 1</strong>，从当前线程的栈中找到一个空闲的<code>Lock Record</code>（<strong>即代码中的BasicObjectLock，下文都用Lock Record代指</strong>），判断<code>Lock Record</code>是否空闲的依据是其obj字段 是否为null。注意这里是按内存地址从低往高找到最后一个可用的<code>Lock Record</code>，换而言之，就是找到内存地址最高的可用<code>Lock Record</code>。</p>
<p><strong>code 2</strong>，获取到<code>Lock Record</code>后，首先要做的就是为其obj字段赋值。</p>
<p><strong>code 3</strong>，判断锁对象的<code>mark word</code>是否是偏向模式，即低3位是否为101。见markOop方法has_bias_pattern()</p>
<p><strong>code 4</strong>，这里有几步位运算的操作<code> anticipated_bias_locking_value = (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;  ~((uintptr_t) markOopDesc::age_mask_in_place);</code> 这个位运算可以分为3个部分。</p>
<blockquote>
<p>第一部分<code>((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident)</code> 将当前线程id和类的prototype_header相或，这样得到的值为（当前线程id + prototype_header中的（epoch + 分代年龄 + 偏向锁标志 + 锁标志位）），注意<strong>prototype_header的分代年龄那4个字节为0</strong></p>
<p>第二部分 <code>^ (uintptr_t)mark</code> 将上面计算得到的结果与锁对象的markOop进行异或，相等的位全部被置为0，只剩下不相等的位。</p>
<p>第三部分 <code>&amp; ~((uintptr_t) markOopDesc::age_mask_in_place)</code> markOopDesc::age_mask_in_place为…0001111000,取反后，变成了…1110000111,<strong>除了分代年龄那4位，其他位全为1</strong>；将取反后的结果再与上面的结果相与，将<strong>上面异或得到的结果中分代年龄给忽略掉</strong>。</p>
</blockquote>
<p><strong>code 5</strong>，<code>anticipated_bias_locking_value==0</code>代表偏向的线程是当前线程且<code>mark word</code>的epoch等于class的epoch，这种情况下什么都不用做。</p>
<p><strong>code 6</strong>，<code>(anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0</code>代表class的prototype_header或对象的<code>mark word</code>中偏向模式是关闭的，又因为能走到这已经通过了<code>mark-&gt;has_bias_pattern()</code>判断，即对象的<code>mark word</code>中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。然后利用CAS指令<code>Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark</code><strong>撤销偏向锁</strong>，我们知道CAS会有几个参数，1是预期的原值，2是预期修改后的值 ，3是要修改的对象，与之对应，cmpxchg_ptr方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值，方法返回实际原值，如果等于预期原值则说明修改成功。</p>
<p><strong>code 7</strong>，如果epoch已过期，则需要重偏向，利用CAS指令将锁对象的<code>mark word</code>替换为一个偏向当前线程且epoch为类的epoch的新的<code>mark word</code>。</p>
<p><strong>code 8</strong>，CAS将偏向线程改为当前线程，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。</p>
<p><strong>code 9</strong>，这一步已经是轻量级锁的逻辑了。从上图的<code>mark word</code>的格式可以看到，轻量级锁中<code>mark word</code>存的是指向<code>Lock Record</code>的指针。这里构造一个无锁状态的<code>mark word</code>，然后存储到<code>Lock Record</code>（<code>Lock Record</code>的格式可以看第一篇文章）。设置<code>mark word</code>是无锁状态的原因是：轻量级锁解锁时是将对象头的<code>mark word</code>设置为<code>Lock Record</code>中的<code>Displaced Mark Word</code>，所以创建时设置为无锁状态，解锁时直接用CAS替换就好了。</p>
<p><strong>code 10</strong>， 如果是锁重入，则将<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，起到一个锁重入计数的作用。</p>
<p>以上是偏向锁加锁的流程（包括部分轻量级锁的加锁流程），如果<strong>当前锁已偏向其他线程||epoch值过期||偏向模式关闭||获取偏向锁的过程中存在并发冲突</strong>，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会对<strong>偏向锁撤销和升级</strong>。</p>
<h2 id="6-偏向锁的撤销"><a href="#6-偏向锁的撤销" class="headerlink" title="6 偏向锁的撤销"></a>6 偏向锁的撤销</h2><p>这里说的<strong>撤销</strong>是指在<strong>获取偏向锁的过程因为不满足条件</strong>导致要将锁对象改为<strong>非偏向锁</strong>状态；释放是指退出同步块时的过程，释放锁的逻辑会在下一小节阐述。请读者注意本文中<strong>撤销与释放的区别</strong>。如果获取偏向锁失败会进入到<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/interpreterRuntime.cpp#l608">InterpreterRuntime::monitorenter</a>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Synchronization</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The interpreter&#x27;s synchronization code is factored out so that it can</span></span><br><span class="line"><span class="comment">// be shared by method invocation and synchronized blocks.</span></span><br><span class="line"><span class="comment">//%note synchronization_3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//%note monitor_1</span></span><br><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="keyword">void</span>, InterpreterRuntime::<span class="built_in">monitorenter</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::<span class="built_in">inc</span>(BiasedLocking::<span class="built_in">slow_path_entry_count_addr</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关键代码</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(elem-&gt;<span class="built_in">obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<p>可以看到如果开启了JVM偏向锁，那会进入到<code>ObjectSynchronizer::fast_enter</code>方法中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  Fast Monitor Enter/Exit</span></span><br><span class="line"><span class="comment">// This the fast monitor enter. The interpreter and compiler use</span></span><br><span class="line"><span class="comment">// some assembly copies of this code. Make sure update those code</span></span><br><span class="line"><span class="comment">// if the following function is changed. The implementation is</span></span><br><span class="line"><span class="comment">// extremely sensitive to race condition. Be careful.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;<span class="comment">//判断是否开启了偏向锁</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;<span class="comment">//如果不处于全局安全点</span></span><br><span class="line">        <span class="comment">//这里 通过`revoke_and_rebias`这个函数尝试获取偏向锁</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果在安全点，撤销偏向锁</span></span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!object-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line">  <span class="comment">// if displaced header is null, the previous enter is recursive enter, no-op</span></span><br><span class="line">  markOop dhw = lock-&gt;<span class="built_in">displaced_header</span>();<span class="comment">//获取锁对象中的对象头</span></span><br><span class="line">  markOop mark ;</span><br><span class="line">  <span class="keyword">if</span> (dhw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// Recursive stack-lock.</span></span><br><span class="line">     <span class="comment">// Diagnostics -- Could be: stack-locked, inflating, inflated.</span></span><br><span class="line">     mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line">     <span class="built_in">assert</span> (!mark-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; mark != markOopDesc::<span class="built_in">INFLATING</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>()), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>()) &#123;</span><br><span class="line">        ObjectMonitor * m = mark-&gt;<span class="built_in">monitor</span>() ;</span><br><span class="line">        <span class="built_in">assert</span>(((oop)(m-&gt;<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == mark, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span>(m-&gt;<span class="built_in">is_entered</span>(THREAD), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mark = object-&gt;<span class="built_in">mark</span>() ;<span class="comment">//获取线程栈帧中锁记录(LockRecord)中的markword</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the object is stack-locked by the current thread, try to</span></span><br><span class="line">  <span class="comment">// swing the displaced header from the box back to the mark.</span></span><br><span class="line">  <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (dhw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      <span class="comment">//通过CAS尝试将Displaced Mark Word替换回对象头，如果成功，表示锁释放成功。</span></span><br><span class="line">     <span class="keyword">if</span> ((markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (dhw, object-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">        <span class="built_in">TEVENT</span> (fast_exit: release stacklock) ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁膨胀，调用重量级锁的释放锁方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, object)-&gt;<span class="built_in">exit</span> (<span class="literal">true</span>, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是正常的Java线程，会走上面的逻辑进入到<code>BiasedLocking::revoke_and_rebias</code>方法，如果是VM线程则会走到下面的<code>BiasedLocking::revoke_at_safepoint</code>。我们主要看<code>BiasedLocking::revoke_and_rebias</code>方法。这个方法的主要作用像它的方法名：<strong>撤销或者重偏向</strong>，第一个和第三个参数封装了锁对象和当前线程，第二个参数代表是否允许重偏向，这里是true。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BiasedLocking::Condition <span class="title">BiasedLocking::revoke_and_rebias</span><span class="params">(Handle obj, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;must not be called while at safepoint&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_biased_anonymously</span>() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">     <span class="comment">//如果是匿名偏向且attempt_rebias==false会走到这里，如锁对象的hashcode方法被调用会出现这种情况，需要撤销偏向锁。</span></span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">    markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="comment">// 锁对象开启了偏向模式会走到这里</span></span><br><span class="line">    Klass* k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="comment">//code 1： 如果对应class关闭了偏向模式</span></span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(prototype_header, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">      <span class="built_in">assert</span>(!(*(obj-&gt;<span class="built_in">mark_addr</span>()))-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;even if we raced, should still be revoked&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    <span class="comment">//code2： 如果epoch过期</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;<span class="built_in">bias_epoch</span>() != mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attempt_rebias) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::<span class="built_in">encode</span>((JavaThread*) THREAD, mark-&gt;<span class="built_in">age</span>(), prototype_header-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(rebiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//code 3：批量重偏向与批量撤销的逻辑</span></span><br><span class="line">  HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(<span class="built_in">obj</span>(), attempt_rebias);</span><br><span class="line">  <span class="keyword">if</span> (heuristics == HR_NOT_BIASED) &#123;</span><br><span class="line">    <span class="keyword">return</span> NOT_BIASED;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heuristics == HR_SINGLE_REVOKE) &#123;</span><br><span class="line">    <span class="comment">//code 4：撤销单个线程</span></span><br><span class="line">    Klass *k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">biased_locker</span>() == THREAD &amp;&amp;</span><br><span class="line">        prototype_header-&gt;<span class="built_in">bias_epoch</span>() == mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      <span class="comment">// 走到这里说明需要撤销的是偏向当前线程的锁，当调用Object#hashcode方法时会走到这一步</span></span><br><span class="line">      <span class="comment">// 因为只要遍历当前线程的栈就好了，所以不需要等到safepoint再撤销。</span></span><br><span class="line">      ResourceMark rm;</span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias by walking my own stack:&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      BiasedLocking::Condition cond = <span class="built_in">revoke_bias</span>(<span class="built_in">obj</span>(), <span class="literal">false</span>, <span class="literal">false</span>, (JavaThread*) THREAD);</span><br><span class="line">      ((JavaThread*) THREAD)-&gt;<span class="built_in">set_cached_monitor_info</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">assert</span>(cond == BIAS_REVOKED, <span class="string">&quot;why not?&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cond;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 下面代码最终会在VM线程中的safepoint调用revoke_bias方法</span></span><br><span class="line">      VM_RevokeBias <span class="built_in">revoke</span>(&amp;obj, (JavaThread*) THREAD);</span><br><span class="line">      VMThread::<span class="built_in">execute</span>(&amp;revoke);</span><br><span class="line">      <span class="keyword">return</span> revoke.<span class="built_in">status_code</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="built_in">assert</span>((heuristics == HR_BULK_REVOKE) ||</span><br><span class="line">         (heuristics == HR_BULK_REBIAS), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">   <span class="comment">//code5：批量撤销、批量重偏向的逻辑</span></span><br><span class="line">  <span class="function">VM_BulkRevokeBias <span class="title">bulk_revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                (heuristics == HR_BULK_REBIAS),</span></span></span><br><span class="line"><span class="params"><span class="function">                                attempt_rebias)</span></span>;</span><br><span class="line">  VMThread::<span class="built_in">execute</span>(&amp;bulk_revoke);</span><br><span class="line">  <span class="keyword">return</span> bulk_revoke.<span class="built_in">status_code</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会走到该方法的逻辑有很多，我们只分析最常见的情况：假设锁已经偏向线程A，这时B线程尝试获得锁。</p>
<p>上面的<code>code 1</code>，<code>code 2</code>B线程都不会走到，最终会走到<code>code 4</code>处，如果要撤销的锁偏向的是当前线程则直接调用<code>revoke_bias</code>撤销偏向锁，否则会将该操作push到VM Thread中等到<code>safepoint</code>的时候再执行。</p>
<p>关于VM Thread这里介绍下：在JVM中有个专门的<strong>VM Thread</strong>，该线程会源源不断的从VMOperationQueue中取出请求，比如GC请求。对于需要<code>safepoint</code>的操作（VM_Operationevaluate_at_safepoint返回true）必须要等到所有的Java线程进入到<code>safepoint</code>才开始执行。</p>
<p>接下来我们着重分析下<code>revoke_bias</code>方法。第一个参数为锁对象，第2、3个参数为都为false</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BiasedLocking::Condition <span class="title">revoke_bias</span><span class="params">(oop obj, <span class="keyword">bool</span> allow_rebias, <span class="keyword">bool</span> is_bulk, JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="comment">// 如果没有开启偏向模式，则直接返回NOT_BIASED</span></span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint age = mark-&gt;<span class="built_in">age</span>();</span><br><span class="line">  <span class="comment">// 构建两个mark word，一个是匿名偏向模式（101），一个是无锁模式（001）</span></span><br><span class="line">  markOop   biased_prototype = markOopDesc::<span class="built_in">biased_locking_prototype</span>()-&gt;<span class="built_in">set_age</span>(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(age);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  JavaThread* biased_thread = mark-&gt;<span class="built_in">biased_locker</span>();</span><br><span class="line">  <span class="keyword">if</span> (biased_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// 匿名偏向。当调用锁对象的hashcode()方法可能会导致走到这个逻辑</span></span><br><span class="line">     <span class="comment">// 如果不允许重偏向，则将对象的mark word设置为无锁模式</span></span><br><span class="line">    <span class="keyword">if</span> (!allow_rebias) &#123;</span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// code 1：判断偏向线程是否还存活</span></span><br><span class="line">  <span class="keyword">bool</span> thread_is_alive = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 如果当前线程就是偏向线程 </span></span><br><span class="line">  <span class="keyword">if</span> (requesting_thread == biased_thread) &#123;</span><br><span class="line">    thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 遍历当前jvm的所有线程，如果能找到，则说明偏向的线程还存活</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* cur_thread = Threads::<span class="built_in">first</span>(); cur_thread != <span class="literal">NULL</span>; cur_thread = cur_thread-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_thread == biased_thread) &#123;</span><br><span class="line">        thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果偏向的线程已经不存活了</span></span><br><span class="line">  <span class="keyword">if</span> (!thread_is_alive) &#123;</span><br><span class="line">    <span class="comment">// 允许重偏向则将对象mark word设置为匿名偏向状态，否则设置为无锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程还存活则遍历线程栈中所有的Lock Record</span></span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = <span class="built_in">get_or_compute_monitor_info</span>(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;<span class="built_in">at</span>(i);</span><br><span class="line">    <span class="comment">// 如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码</span></span><br><span class="line">    <span class="keyword">if</span> (mon_info-&gt;<span class="built_in">owner</span>() == obj) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 需要升级为轻量级锁，直接修改偏向线程栈中的Lock Record。为了处理锁重入的case，在这里将Lock Record的Displaced Mark Word设置为null，第一个Lock Record会在下面的代码中再处理</span></span><br><span class="line">      markOop mark = markOopDesc::<span class="built_in">encode</span>((BasicLock*) <span class="literal">NULL</span>);</span><br><span class="line">      highest_lock = mon_info-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      highest_lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (highest_lock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改第一个Lock Record为无锁状态，然后将obj的mark word设置为指向该Lock Record的指针</span></span><br><span class="line">    highest_lock-&gt;<span class="built_in">set_displaced_header</span>(unbiased_prototype);</span><br><span class="line">    obj-&gt;<span class="built_in">release_set_mark</span>(markOopDesc::<span class="built_in">encode</span>(highest_lock));</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 走到这里说明偏向线程已经不在同步块中了</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">       <span class="comment">//设置为匿名偏向状态</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将mark word设置为无锁状态</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意下，当调用锁对象的<code>Object#hash</code>或<code>System.identityHashCode()</code>方法会导致该对象的偏向锁或轻量级锁升级。这是因为在Java中一个对象的hashcode是在调用这两个方法时才生成的，如果是无锁状态则存放在<code>mark word</code>中，如果是重量级锁则存放在对应的monitor中，而偏向锁是没有地方能存放该信息的，所以必须升级。 <code>revoke_bias</code><strong>方法逻辑</strong>：</p>
<ol>
<li>查看偏向的线程是否存活，如果已经不存活了，则直接撤销偏向锁。JVM维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。</li>
<li>偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁。我们回顾一下偏向锁的加锁流程：每次进入同步块（即执行<code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的<code>Lock Record</code>，将其obj字段指向锁对象。每次解锁（即执行<code>monitorexit</code>）的时候都会将最低的一个相关<code>Lock Record</code>移除掉。所以可以通过遍历线程栈中的<code>Lock Record</code>来判断线程是否还在同步块中。</li>
<li>将偏向线程所有相关<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，然后将最高位的<code>Lock Record</code>的<code>Displaced Mark Word</code> 设置为无锁状态，最高位的<code>Lock Record</code>也就是第一次获得锁时的<code>Lock Record</code>（这里的第一次是指重入获取锁时的第一次），然后将对象头指向最高位的<code>Lock Record</code>，这里不需要用CAS指令，因为是在<code>safepoint</code>。 执行完后，就升级成了轻量级锁。原偏向线程的所有Lock Record都已经变成轻量级锁的状态</li>
</ol>
<h2 id="7-偏向锁的释放"><a href="#7-偏向锁的释放" class="headerlink" title="7 偏向锁的释放"></a>7 偏向锁的释放</h2><p>偏向锁的释放入口在<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923">bytecodeInterpreter.cpp#1923</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_monitorexit): &#123;</span><br><span class="line">  oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">  <span class="comment">// derefing&#x27;s lockee ought to provoke implicit null check</span></span><br><span class="line">  <span class="comment">// find our monitor slot</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">  <span class="comment">// 从低往高遍历栈的Lock Record</span></span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">    <span class="comment">// 如果Lock Record关联的是该锁对象</span></span><br><span class="line">    <span class="keyword">if</span> ((most_recent)-&gt;<span class="built_in">obj</span>() == lockee) &#123;</span><br><span class="line">      BasicLock* lock = most_recent-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      markOop header = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">      <span class="comment">// 释放Lock Record</span></span><br><span class="line">      most_recent-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">// 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程</span></span><br><span class="line">      <span class="keyword">if</span> (!lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">        <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">        <span class="comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span></span><br><span class="line">        <span class="keyword">if</span> (header != <span class="literal">NULL</span> || call_vm) &#123;</span><br><span class="line">          <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), lock) != lock) &#123;</span><br><span class="line">            <span class="comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span></span><br><span class="line">            most_recent-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">            <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorexit</span>(THREAD, most_recent), handle_exception);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行下一条命令</span></span><br><span class="line">      <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理下一条Lock Record</span></span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Need to throw illegal monitor state exception</span></span><br><span class="line">  <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">throw_illegal_monitor_state_exception</span>(THREAD), handle_exception);</span><br><span class="line">  <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码结合注释理解起来应该不难，偏向锁的释放很简单，只要将对应<code>Lock Record</code>释放就好了，而轻量级锁则需要将<code>Displaced Mark Word</code>替换到对象头的mark word中。如果CAS失败或者是重量级锁则进入到<code>InterpreterRuntime::monitorexit</code>方法中。</p>
<h2 id="8-批量重偏向和批量撤销"><a href="#8-批量重偏向和批量撤销" class="headerlink" title="8 批量重偏向和批量撤销"></a>8 批量重偏向和批量撤销</h2><p>当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到<code>safe point</code>时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。<code>safe point</code>这个词我们在GC中经常会提到，其代表了一个状态，在该状态下所有线程都是暂停的（大概这么个意思） 。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p>
<p>存在如下两种情况：</p>
<p>**1.**一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p>
<p>**2.**存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p>
<p><strong>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</strong></p>
<p><strong>其做法是</strong>：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（<strong>默认20</strong>）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的<code>epoch</code>字段，每个处于偏向锁状态对象的<code>mark word中</code>也有该字段，其初始值为创建该对象时，class中的<code>epoch</code>的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其<code>epoch</code>字段改为新值。下次获得锁时，发现当前对象的<code>epoch</code>值和class的<code>epoch</code>不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其<code>mark word</code>的Thread Id 改成当前线程Id。</p>
<p>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（<strong>默认40</strong>），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑</p>
<p>相关实现在<code>BiasedLocking::revoke_and_rebias</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BiasedLocking::Condition <span class="title">BiasedLocking::revoke_and_rebias</span><span class="params">(Handle obj, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;must not be called while at safepoint&quot;</span>);</span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>(); <span class="comment">//获取锁对象的对象头</span></span><br><span class="line">  <span class="comment">//判断mark是否为可偏向状态，即mark的偏向锁标志位为1，锁标志位为 01，线程id为null</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_biased_anonymously</span>() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">    <span class="comment">//这个分支是进行对象的hashCode计算时会进入，在一个非全局安全点进行偏向锁撤销</span></span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    <span class="comment">//创建一个非偏向的markword</span></span><br><span class="line">    markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">    <span class="comment">//Atomic:cmpxchg_ptr是CAS操作，通过cas重新设置偏向锁状态</span></span><br><span class="line">    markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;<span class="comment">//如果CAS成功，返回偏向锁撤销状态</span></span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;<span class="comment">//如果锁对象为可偏向状态（biased_lock:1, lock:01，不管线程id是否为空）,尝试重新偏向</span></span><br><span class="line">    Klass* k = obj-&gt;<span class="built_in">klass</span>(); </span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="comment">//如果已经有线程对锁对象进行了全局锁定，则取消偏向锁操作</span></span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      <span class="comment">//CAS 更新对象头markword为非偏向锁</span></span><br><span class="line">      markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(prototype_header, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">      <span class="built_in">assert</span>(!(*(obj-&gt;<span class="built_in">mark_addr</span>()))-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;even if we raced, should still be revoked&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED; <span class="comment">//返回偏向锁撤销状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;<span class="built_in">bias_epoch</span>() != mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      <span class="comment">//如果偏向锁过期，则进入当前分支</span></span><br><span class="line">      <span class="keyword">if</span> (attempt_rebias) &#123;<span class="comment">//如果允许尝试获取偏向锁</span></span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::<span class="built_in">encode</span>((JavaThread*) THREAD, mark-&gt;<span class="built_in">age</span>(), prototype_header-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">        <span class="comment">//通过CAS 操作， 将本线程的 ThreadID 、时间错、分代年龄尝试写入对象头中</span></span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(rebiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123; <span class="comment">//CAS成功，则返回撤销和重新偏向状态</span></span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//不尝试获取偏向锁，则取消偏向锁</span></span><br><span class="line">        <span class="comment">//通过CAS操作更新分代年龄</span></span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123; <span class="comment">//如果CAS操作成功，返回偏向锁撤销状态</span></span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//code 1：重偏向的逻辑</span></span><br><span class="line">  HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(<span class="built_in">obj</span>(), attempt_rebias);</span><br><span class="line">  <span class="comment">// 非重偏向的逻辑</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="built_in">assert</span>((heuristics == HR_BULK_REVOKE) ||</span><br><span class="line">         (heuristics == HR_BULK_REBIAS), <span class="string">&quot;?&quot;</span>);	</span><br><span class="line">   <span class="comment">//code 2：批量撤销、批量重偏向的逻辑</span></span><br><span class="line">  <span class="function">VM_BulkRevokeBias <span class="title">bulk_revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                (heuristics == HR_BULK_REBIAS),</span></span></span><br><span class="line"><span class="params"><span class="function">                                attempt_rebias)</span></span>;</span><br><span class="line">  VMThread::<span class="built_in">execute</span>(&amp;bulk_revoke);</span><br><span class="line">  <span class="keyword">return</span> bulk_revoke.<span class="built_in">status_code</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次撤销偏向锁的时候都通过<code>update_heuristics</code>方法记录下来，以类为单位，当某个类的对象撤销偏向次数达到一定阈值的时候JVM就认为该类不适合偏向模式或者需要重新偏向另一个对象，<code>update_heuristics</code>就会返回<code>HR_BULK_REVOKE</code>或<code>HR_BULK_REBIAS</code>。进行批量撤销或批量重偏向。</p>
<p>先看<code>update_heuristics</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> HeuristicsResult <span class="title">update_heuristics</span><span class="params">(oop o, <span class="keyword">bool</span> allow_rebias)</span> </span>&#123;</span><br><span class="line">  markOop mark = o-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="comment">//如果不是偏向模式直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> HR_NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 锁对象的类</span></span><br><span class="line">  Klass* k = o-&gt;<span class="built_in">klass</span>();</span><br><span class="line">  <span class="comment">// 当前时间</span></span><br><span class="line">  jlong cur_time = os::<span class="built_in">javaTimeMillis</span>();</span><br><span class="line">  <span class="comment">// 该类上一次批量撤销的时间</span></span><br><span class="line">  jlong last_bulk_revocation_time = k-&gt;<span class="built_in">last_biased_lock_bulk_revocation_time</span>();</span><br><span class="line">  <span class="comment">// 该类偏向锁撤销的次数</span></span><br><span class="line">  <span class="keyword">int</span> revocation_count = k-&gt;<span class="built_in">biased_lock_revocation_count</span>();</span><br><span class="line">  <span class="comment">// BiasedLockingBulkRebiasThreshold是重偏向阈值（默认20），BiasedLockingBulkRevokeThreshold是批量撤销阈值（默认40），BiasedLockingDecayTime是开启一次新的批量重偏向距离上次批量重偏向的后的延迟时间，默认25000。也就是开启批量重偏向后，经过了一段较长的时间（&gt;=BiasedLockingDecayTime），撤销计数器才超过阈值，那我们会重置计数器。</span></span><br><span class="line">  <span class="keyword">if</span> ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;</span><br><span class="line">      (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;</span><br><span class="line">      (last_bulk_revocation_time != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">      (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) &#123;</span><br><span class="line">    <span class="comment">// This is the first revocation we&#x27;ve seen in a while of an</span></span><br><span class="line">    <span class="comment">// object of this type since the last time we performed a bulk</span></span><br><span class="line">    <span class="comment">// rebiasing operation. The application is allocating objects in</span></span><br><span class="line">    <span class="comment">// bulk which are biased toward a thread and then handing them</span></span><br><span class="line">    <span class="comment">// off to another thread. We can cope with this allocation</span></span><br><span class="line">    <span class="comment">// pattern via the bulk rebiasing mechanism so we reset the</span></span><br><span class="line">    <span class="comment">// klass&#x27;s revocation count rather than allow it to increase</span></span><br><span class="line">    <span class="comment">// monotonically. If we see the need to perform another bulk</span></span><br><span class="line">    <span class="comment">// rebias operation later, we will, and if subsequently we see</span></span><br><span class="line">    <span class="comment">// many more revocation operations in a short period of time we</span></span><br><span class="line">    <span class="comment">// will completely disable biasing for this type.</span></span><br><span class="line">    k-&gt;<span class="built_in">set_biased_lock_revocation_count</span>(<span class="number">0</span>);</span><br><span class="line">    revocation_count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自增撤销计数器</span></span><br><span class="line">  <span class="keyword">if</span> (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">    revocation_count = k-&gt;<span class="built_in">atomic_incr_biased_lock_revocation_count</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果达到批量撤销阈值则返回HR_BULK_REVOKE</span></span><br><span class="line">  <span class="keyword">if</span> (revocation_count == BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">    <span class="keyword">return</span> HR_BULK_REVOKE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果达到批量重偏向阈值则返回HR_BULK_REBIAS</span></span><br><span class="line">  <span class="keyword">if</span> (revocation_count == BiasedLockingBulkRebiasThreshold) &#123;</span><br><span class="line">    <span class="keyword">return</span> HR_BULK_REBIAS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有达到阈值则撤销单个对象的锁</span></span><br><span class="line">  <span class="keyword">return</span> HR_SINGLE_REVOKE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当达到阈值的时候就会通过VM 线程在<code>safepoint</code>调用<code>bulk_revoke_or_rebias_at_safepoint</code>, 参数<code>bulk_rebias</code>如果是true代表是批量重偏向否则为批量撤销。<code>attempt_rebias_of_object</code>代表对操作的锁对象<code>o</code>是否运行重偏向，这里是<code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BiasedLocking::Condition <span class="title">bulk_revoke_or_rebias_at_safepoint</span><span class="params">(oop o,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                   <span class="keyword">bool</span> bulk_rebias,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                   <span class="keyword">bool</span> attempt_rebias_of_object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                   JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  jlong cur_time = os::<span class="built_in">javaTimeMillis</span>();</span><br><span class="line">  o-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">set_last_biased_lock_bulk_revocation_time</span>(cur_time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Klass* k_o = o-&gt;<span class="built_in">klass</span>();</span><br><span class="line">  Klass* klass = k_o;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bulk_rebias) &#123;</span><br><span class="line">    <span class="comment">// 批量重偏向的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      <span class="comment">// 自增前类中的的epoch</span></span><br><span class="line">      <span class="keyword">int</span> prev_epoch = klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">bias_epoch</span>();</span><br><span class="line">      <span class="comment">// code 1：类中的epoch自增</span></span><br><span class="line">      klass-&gt;<span class="built_in">set_prototype_header</span>(klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">incr_bias_epoch</span>());</span><br><span class="line">      <span class="keyword">int</span> cur_epoch = klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">bias_epoch</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// code 2：遍历所有线程的栈，更新类型为该klass的所有锁实例的epoch</span></span><br><span class="line">      <span class="keyword">for</span> (JavaThread* thr = Threads::<span class="built_in">first</span>(); thr != <span class="literal">NULL</span>; thr = thr-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">        GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = <span class="built_in">get_or_compute_monitor_info</span>(thr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          MonitorInfo* mon_info = cached_monitor_info-&gt;<span class="built_in">at</span>(i);</span><br><span class="line">          oop owner = mon_info-&gt;<span class="built_in">owner</span>();</span><br><span class="line">          markOop mark = owner-&gt;<span class="built_in">mark</span>();</span><br><span class="line">          <span class="keyword">if</span> ((owner-&gt;<span class="built_in">klass</span>() == k_o) &amp;&amp; mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">            <span class="comment">// We might have encountered this object already in the case of recursive locking</span></span><br><span class="line">            <span class="built_in">assert</span>(mark-&gt;<span class="built_in">bias_epoch</span>() == prev_epoch || mark-&gt;<span class="built_in">bias_epoch</span>() == cur_epoch, <span class="string">&quot;error in bias epoch adjustment&quot;</span>);</span><br><span class="line">            owner-&gt;<span class="built_in">set_mark</span>(mark-&gt;<span class="built_in">set_bias_epoch</span>(cur_epoch));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来对当前锁对象进行重偏向</span></span><br><span class="line">    <span class="built_in">revoke_bias</span>(o, attempt_rebias_of_object &amp;&amp; klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="literal">true</span>, requesting_thread);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code 3：批量撤销的逻辑，将类中的偏向标记关闭，markOopDesc::prototype()返回的是一个关闭偏向模式的prototype</span></span><br><span class="line">    klass-&gt;<span class="built_in">set_prototype_header</span>(markOopDesc::<span class="built_in">prototype</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code 4：遍历所有线程的栈，撤销该类所有锁的偏向</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* thr = Threads::<span class="built_in">first</span>(); thr != <span class="literal">NULL</span>; thr = thr-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">      GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = <span class="built_in">get_or_compute_monitor_info</span>(thr);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        MonitorInfo* mon_info = cached_monitor_info-&gt;<span class="built_in">at</span>(i);</span><br><span class="line">        oop owner = mon_info-&gt;<span class="built_in">owner</span>();</span><br><span class="line">        markOop mark = owner-&gt;<span class="built_in">mark</span>();</span><br><span class="line">        <span class="keyword">if</span> ((owner-&gt;<span class="built_in">klass</span>() == k_o) &amp;&amp; mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">          <span class="built_in">revoke_bias</span>(owner, <span class="literal">false</span>, <span class="literal">true</span>, requesting_thread);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销当前锁对象的偏向模式</span></span><br><span class="line">    <span class="built_in">revoke_bias</span>(o, <span class="literal">false</span>, <span class="literal">true</span>, requesting_thread);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  BiasedLocking::Condition status_code = BiasedLocking::BIAS_REVOKED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attempt_rebias_of_object &amp;&amp;</span><br><span class="line">      o-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>() &amp;&amp;</span><br><span class="line">      klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="comment">// 构造一个偏向请求线程的mark word</span></span><br><span class="line">    markOop new_mark = markOopDesc::<span class="built_in">encode</span>(requesting_thread, o-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">age</span>(),</span><br><span class="line">                                           klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">    <span class="comment">// 更新当前锁对象的mark word</span></span><br><span class="line">    o-&gt;<span class="built_in">set_mark</span>(new_mark);</span><br><span class="line">    status_code = BiasedLocking::BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法分为两个逻辑：<strong>批量重偏向和批量撤销</strong>。</p>
<p><strong>先看批量重偏向，分为两步：</strong></p>
<p><strong>code 1</strong> 将类中的撤销计数器自增1，之后当该类已存在的实例获得锁时，就会尝试重偏向，相关逻辑在<code>偏向锁获取流程</code>小节中。</p>
<p><strong>code 2</strong> 处理当前正在被使用的锁对象，通过遍历所有存活线程的栈，找到所有正在使用的偏向锁对象，然后更新它们的epoch值。也就是说不会重偏向正在使用的锁，否则会破坏锁的线程安全性。</p>
<p><strong>批量撤销逻辑如下</strong>：</p>
<p><strong>code 3</strong>将类的偏向标记关闭，之后当该类已存在的实例获得锁时，就会升级为轻量级锁；该类新分配的对象的<code>mark word</code>则是无锁模式。</p>
<p><strong>code 4</strong>处理当前正在被使用的锁对象，通过遍历所有存活线程的栈，找到所有正在使用的偏向锁对象，然后撤销偏向锁。</p>
<h2 id="9-轻量级锁获取流程"><a href="#9-轻量级锁获取流程" class="headerlink" title="9 轻量级锁获取流程"></a>9 轻量级锁获取流程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_monitorenter): &#123;</span><br><span class="line">  oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 上面省略的代码中如果CAS操作失败也会调用到InterpreterRuntime::monitorenter</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false</span></span><br><span class="line">    <span class="comment">// traditional lightweight locking</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      <span class="comment">// 构建一个无锁状态的Displaced Mark Word</span></span><br><span class="line">      markOop displaced = lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">set_unlocked</span>();</span><br><span class="line">      <span class="comment">// 设置到Lock Record中去</span></span><br><span class="line">      entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(displaced);</span><br><span class="line">      <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">      <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(entry, lockee-&gt;<span class="built_in">mark_addr</span>(), displaced) != displaced) &#123;</span><br><span class="line">        <span class="comment">// 如果CAS替换不成功，代表锁对象不是无锁状态，这时候判断下是不是锁重入</span></span><br><span class="line">        <span class="comment">// Is it simple recursive case?</span></span><br><span class="line">        <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) displaced-&gt;<span class="built_in">clear_lock_bits</span>())) &#123;</span><br><span class="line">          entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// CAS操作失败则调用monitorenter</span></span><br><span class="line">          <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    istate-&gt;<span class="built_in">set_msg</span>(more_monitors);</span><br><span class="line">    <span class="built_in">UPDATE_PC_AND_RETURN</span>(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果锁对象不是偏向模式或已经偏向其他线程，则success为false。这时候会构建一个无锁状态的mark word设置到Lock Record中去，我们称Lock Record中存储对象mark word的字段叫<strong>Displaced Mark Word。</strong></p>
<p>如果当前锁的状态不是无锁状态，则CAS失败。如果这是一次锁重入，那直接将Lock Record的 Displaced Mark Word设置为null，起到重入计数的作用。</p>
<p>看个demo，在该demo中重复3次获得锁，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设锁的状态是轻量级锁，下图反应了<code>mark word</code>和线程栈中<code>Lock Record</code>的状态，可以看到右边线程栈中包含3个指向当前锁对象的<code>Lock Record</code>。其中栈中最高位的<code>Lock Record</code>为第一次获取锁时分配的。其<code>Displaced Mark word</code>的值为锁对象的加锁前的<code>mark word</code>，之后的锁重入会在线程栈中分配一个<code>Displaced Mark word</code>为<code>null</code>的<code>Lock Record</code>。</p>
<p><em>为什么JVM选择在线程栈中添加<code>Displaced Mark word</code>为null的<code>Lock Record</code>来表示重入计数呢</em>？首先锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，<strong>解锁次数等于加锁次数时，该锁才真正的被释放</strong>，也就是在解锁时需要用到锁重入次数的。一个简单的方案是将锁重入次数记录在对象头的<code>mark word</code>中，但<code>mark word</code>的大小是有限的，已经存放不下该信息了。另一个方案是只创建一个<code>Lock Record</code>并在其中记录重入次数，Hotspot没有这样做的原因我猜是考虑到效率有影响：每次重入获得锁都需要遍历该线程的栈找到对应的<code>Lock Record</code>，然后修改它的值。<strong>所以最终Hotspot选择每次获得锁都添加一个<code>Lock Record</code>来表示锁的重入。</strong></p>
<p><strong>看<code>slow_enter</code>的流程。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Interpreter/Compiler Slow Case</span></span><br><span class="line"><span class="comment">// This routine is used to handle interpreter/compiler slow case</span></span><br><span class="line"><span class="comment">// We don&#x27;t need to use fast path here, because it must have been</span></span><br><span class="line"><span class="comment">// failed in the interpreter/compiler code.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果是无锁状态</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    <span class="comment">//设置Displaced Mark Word并替换对象头的mark word</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">      <span class="comment">//通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁</span></span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(lock, <span class="built_in">obj</span>()-&gt;<span class="built_in">mark_addr</span>(), mark)) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span><span class="comment">// 如果是轻量级锁重入（//如果markword处于加锁状态、且markword中的ptr指针指向当前线程的栈帧）</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(lock != mark-&gt;<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果是重入，则设置Displaced Mark Word为null</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn&#x27;t particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>() &amp;&amp; mark-&gt;<span class="built_in">monitor</span>()-&gt;<span class="built_in">is_entered</span>(THREAD)) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  <span class="comment">// 走到这一步说明已经是存在多个线程竞争锁了 需要膨胀为重量级锁</span></span><br><span class="line">  <span class="comment">//膨胀前，设置Displaced Mark Word为一个特殊值，代表该锁正在用一个重量级锁的monitor</span></span><br><span class="line">  lock-&gt;<span class="built_in">set_displaced_header</span>(markOopDesc::<span class="built_in">unused_mark</span>());</span><br><span class="line">  <span class="comment">////先调用inflate膨胀为重量级锁，该方法返回一个ObjectMonitor对象，然后调用其enter方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">enter</span>(THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This routine is used to handle interpreter/compiler slow case</span></span><br><span class="line"><span class="comment">// We don&#x27;t need to use fast path here, because it must have</span></span><br><span class="line"><span class="comment">// failed in the interpreter/compiler code. Simply use the heavy</span></span><br><span class="line"><span class="comment">// weight monitor should be ok, unless someone find otherwise.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fast_exit</span> (object, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来看，轻量级锁的获取流程如下：</p>
<p><strong>（1）</strong>线程在执行同步块之前，如果此同步对象没有被锁定（锁标志位01），JVM会先在当前线程的栈桢中创建一个用于存储锁记录的空间Lock Record，并将锁对象头中的Mark Word复制到锁记录Lock Record中，官方称为Displaced Mark Word，这时候<strong>线程堆栈与锁对象的状态：</strong></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200317190859968.png" alt="image-20200317190859968"></p>
<p><strong>（2）</strong>然后JVM将尝试使用CAS将对象头中的Mark Word替换为指向锁记录Lock Record的指针。</p>
<p><strong>（3）</strong>如果这个更新动作成功了，当前线程获得锁，并且对象markWord的锁标志位变为“00”，即表示此锁对象处于轻量级锁定状态，这时候<strong>线程堆栈与锁对象的状态：</strong></p>
<p><img src="C:\Users\Administrator\Desktop\面试题总结\并发编程\image-20200317202916528.png" alt="image-20200317202916528"></p>
<p><strong>（4）</strong>如果这个更新操作失败了，JVM首先检查所对象的Mark Word是否指向当前线程的栈帧，如果当前线程已经拥有了这个对象的锁，那就可以直接进入同步块执行，否则说明这个锁对象已经被其他对象抢占了。</p>
<p><strong>（5）</strong>如果有两条以上的线程挣用同一个锁，那轻量级锁就不在有效，要膨胀为重量级锁，锁状态标志位变为“10”，MarkWord存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁。</p>
<h2 id="10-轻量级锁释放流程"><a href="#10-轻量级锁释放流程" class="headerlink" title="10 轻量级锁释放流程"></a>10 轻量级锁释放流程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_monitorexit): &#123;</span><br><span class="line">       oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">       <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">       <span class="comment">// derefing&#x27;s lockee ought to provoke implicit null check</span></span><br><span class="line">       <span class="comment">// find our monitor slot</span></span><br><span class="line">       BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">       BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">    	<span class="comment">// 从低往高遍历栈的Lock Record</span></span><br><span class="line">       <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">          <span class="comment">// 如果Lock Record关联的是该锁对象</span></span><br><span class="line">         <span class="keyword">if</span> ((most_recent)-&gt;<span class="built_in">obj</span>() == lockee) &#123;</span><br><span class="line">           BasicLock* lock = most_recent-&gt;<span class="built_in">lock</span>();</span><br><span class="line">           markOop header = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">           <span class="comment">// 释放Lock Record</span></span><br><span class="line">           most_recent-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line">           <span class="comment">// 如果是偏向模式，仅仅释放Lock Record就好了。</span></span><br><span class="line">           <span class="comment">//否则要走轻量级锁or重量级锁的释放流程</span></span><br><span class="line">           <span class="keyword">if</span> (!lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">             <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">             <span class="comment">// If it isn&#x27;t recursive we either must swap old header or call the runtime</span></span><br><span class="line">             <span class="comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span></span><br><span class="line">             <span class="keyword">if</span> (header != <span class="literal">NULL</span> || call_vm) &#123;</span><br><span class="line">               <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), lock) != lock) &#123;</span><br><span class="line">                 <span class="comment">// restore object for the slow case</span></span><br><span class="line">                 <span class="comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span></span><br><span class="line">                 most_recent-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">                 <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorexit</span>(THREAD, most_recent), handle_exception);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="comment">//执行下一条命令</span></span><br><span class="line">           <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//处理下一条Lock Record</span></span><br><span class="line">         most_recent++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Need to throw illegal monitor state exception</span></span><br><span class="line">       <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">throw_illegal_monitor_state_exception</span>(THREAD), handle_exception);</span><br><span class="line">       <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>轻量级锁释放时需要将<code>Displaced Mark Word</code>替换到对象头的<code>mark word</code>中</strong>。如果CAS失败或者是重量级锁则进入到<code>InterpreterRuntime::monitorexit</code>方法中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%note monitor_1</span></span><br><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="keyword">void</span>, InterpreterRuntime::<span class="built_in">monitorexit</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键代码</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (elem == <span class="literal">NULL</span> || <span class="built_in">h_obj</span>()-&gt;<span class="built_in">is_unlocked</span>()) &#123;</span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalMonitorStateException</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">slow_exit</span>(<span class="built_in">h_obj</span>(), elem-&gt;<span class="built_in">lock</span>(), thread);</span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">  <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">  <span class="comment">//释放Lock Record</span></span><br><span class="line">  elem-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<p><code>monitorexit</code>调用完<code>slow_exit</code>方法后,就释放<code>Lock Record</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fast_exit</span> (object, lock, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  markOop dhw = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">  markOop mark ;</span><br><span class="line">  <span class="keyword">if</span> (dhw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// 重入锁，什么也不做</span></span><br><span class="line">   	 ...</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是mark word==Displaced Mark Word即轻量级锁，CAS替换对象头的mark word</span></span><br><span class="line">  <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (dhw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> ((markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (dhw, object-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">        <span class="built_in">TEVENT</span> (fast_exit: release stacklock) ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//走到这里说明是重量级锁或者解锁时发生了竞争，膨胀后调用重量级锁的exit方法。</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, object)-&gt;<span class="built_in">exit</span> (<span class="literal">true</span>, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中先判断是不是轻量级锁，如果是轻量级锁则将替换<code>mark word</code>，否则膨胀为重量级锁并调用<code>exit</code>方法</p>
<p><strong>总体来看，轻量级锁的获取流程如下：</strong></p>
<p><strong>（1）</strong>如果对象的Mark Word仍然指向当前的Lock Record，那就用CAS操作把当前对象的Mark Word和线程中复制的Displaced Mark Word替换回来</p>
<p><strong>（2）</strong>如果替换成功，整个同步过程就完成了。</p>
<p><strong>（3）</strong>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已经膨胀），那就要在释放锁的同时唤醒被挂起的线程。</p>
<h2 id="11-重量级的膨胀和加锁流程"><a href="#11-重量级的膨胀和加锁流程" class="headerlink" title="11 重量级的膨胀和加锁流程"></a>11 重量级的膨胀和加锁流程</h2><p>当出现多个线程同时竞争锁时，会进入到<code>synchronizer.cpp#slow_enter</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Interpreter/Compiler Slow Case</span></span><br><span class="line"><span class="comment">// This routine is used to handle interpreter/compiler slow case</span></span><br><span class="line"><span class="comment">// We don&#x27;t need to use fast path here, because it must have been</span></span><br><span class="line"><span class="comment">// failed in the interpreter/compiler code.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果是无锁状态</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    <span class="comment">//设置Displaced Mark Word并替换对象头的mark word</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(lock, <span class="built_in">obj</span>()-&gt;<span class="built_in">mark_addr</span>(), mark)) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span><span class="comment">// 如果是轻量级锁重入</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(lock != mark-&gt;<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果是重入，则设置Displaced Mark Word为null</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn&#x27;t particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>() &amp;&amp; mark-&gt;<span class="built_in">monitor</span>()-&gt;<span class="built_in">is_entered</span>(THREAD)) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  <span class="comment">// 走到这一步说明已经是存在多个线程竞争锁了 需要膨胀为重量级锁</span></span><br><span class="line">  <span class="comment">//膨胀前，设置Displaced Mark Word为一个特殊值，代表该锁正在用一个重量级锁的monitor</span></span><br><span class="line">  lock-&gt;<span class="built_in">set_displaced_header</span>(markOopDesc::<span class="built_in">unused_mark</span>());</span><br><span class="line">  <span class="comment">////先调用inflate膨胀为重量级锁，该方法返回一个ObjectMonitor对象，然后调用其enter方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">enter</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>inflate</code>中完成膨胀过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note that we could encounter some performance loss through false-sharing as</span></span><br><span class="line"><span class="comment">// multiple locks occupy the same $ line.  Padding might be appropriate.</span></span><br><span class="line"></span><br><span class="line"><span class="function">ObjectMonitor * ATTR <span class="title">ObjectSynchronizer::inflate</span> <span class="params">(Thread * Self, oop object)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Inflate mutates the heap ...</span></span><br><span class="line">  <span class="comment">// Relaxing assertion for bug 6320749.</span></span><br><span class="line">  <span class="built_in">assert</span> (Universe::<span class="built_in">verify_in_progress</span>() ||</span><br><span class="line">          !SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123; <span class="comment">//通过无意义的循环实现自旋操作</span></span><br><span class="line">      <span class="keyword">const</span> markOop mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line">      <span class="built_in">assert</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The mark can be in one of the following states:</span></span><br><span class="line">      <span class="comment">// *  Inflated     - just return</span></span><br><span class="line">      <span class="comment">// *  Stack-locked - coerce it to inflated</span></span><br><span class="line">      <span class="comment">// *  INFLATING    - busy wait for conversion to complete</span></span><br><span class="line">      <span class="comment">// *  Neutral      - aggressively inflate the object.</span></span><br><span class="line">      <span class="comment">// *  BIASED       - Illegal.  We should never see this</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// mark是以下状态中的一种：</span></span><br><span class="line">      <span class="comment">// *  Inflated（重量级锁状态）     - 直接返回</span></span><br><span class="line">      <span class="comment">// *  Stack-locked（轻量级锁状态） - 膨胀</span></span><br><span class="line">      <span class="comment">// *  INFLATING（膨胀中）    - 忙等待直到膨胀完成</span></span><br><span class="line">      <span class="comment">// *  Neutral（无锁状态）      - 膨胀</span></span><br><span class="line">      <span class="comment">// *  BIASED（偏向锁）       - 非法状态，在这里不会出现</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// CASE: inflated</span></span><br><span class="line">      <span class="comment">//has_monitor是markOop.hpp中的方法，如果为true表示当前锁已经是重量级锁了</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>()) &#123;</span><br><span class="line">           <span class="comment">// 已经是重量级锁状态了，直接返回</span></span><br><span class="line">          ObjectMonitor * inf = mark-&gt;<span class="built_in">monitor</span>() ;</span><br><span class="line">          <span class="built_in">assert</span> (inf-&gt;<span class="built_in">header</span>()-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">          <span class="built_in">assert</span> (inf-&gt;<span class="built_in">object</span>() == object, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">assert</span> (ObjectSynchronizer::<span class="built_in">verify_objmon_isinpool</span>(inf), <span class="string">&quot;monitor is invalid&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> inf ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: inflation in progress - inflating over a stack-lock.</span></span><br><span class="line">      <span class="comment">// Some other thread is converting from stack-locked to inflated.</span></span><br><span class="line">      <span class="comment">// Only that thread can complete inflation -- other threads must wait.</span></span><br><span class="line">      <span class="comment">// The INFLATING value is transient.</span></span><br><span class="line">      <span class="comment">// Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.</span></span><br><span class="line">      <span class="comment">// We could always eliminate polling by parking the thread on some auxiliary list.</span></span><br><span class="line">      <span class="keyword">if</span> (mark == markOopDesc::<span class="built_in">INFLATING</span>()) &#123;</span><br><span class="line">          <span class="comment">// 正在膨胀中，说明另一个线程正在进行锁膨胀，continue重试</span></span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflate: spin <span class="keyword">while</span> INFLATING) ;</span><br><span class="line">          <span class="comment">// 在该方法中会进行spin/yield/park等操作完成自旋动作</span></span><br><span class="line">         <span class="built_in">ReadStableMark</span>(object) ;</span><br><span class="line">         <span class="keyword">continue</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: stack-locked</span></span><br><span class="line">      <span class="comment">// Could be stack-locked either by this thread or by some other thread.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Note that we allocate the objectmonitor speculatively, _before_ attempting</span></span><br><span class="line">      <span class="comment">// to install INFLATING into the mark word.  We originally installed INFLATING,</span></span><br><span class="line">      <span class="comment">// allocated the objectmonitor, and then finally STed the address of the</span></span><br><span class="line">      <span class="comment">// objectmonitor into the mark.  This was correct, but artificially lengthened</span></span><br><span class="line">      <span class="comment">// the interval in which INFLATED appeared in the mark, thus increasing</span></span><br><span class="line">      <span class="comment">// the odds of inflation contention.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We now use per-thread private objectmonitor free lists.</span></span><br><span class="line">      <span class="comment">// These list are reprovisioned from the global free list outside the</span></span><br><span class="line">      <span class="comment">// critical INFLATING...ST interval.  A thread can transfer</span></span><br><span class="line">      <span class="comment">// multiple objectmonitors en-mass from the global free list to its local free list.</span></span><br><span class="line">      <span class="comment">// This reduces coherency traffic and lock contention on the global free list.</span></span><br><span class="line">      <span class="comment">// Using such local free lists, it doesn&#x27;t matter if the omAlloc() call appears</span></span><br><span class="line">      <span class="comment">// before or after the CAS(INFLATING) operation.</span></span><br><span class="line">      <span class="comment">// See the comments in omAlloc().</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//表示当前锁为轻量级锁，以下是轻量级锁的膨胀逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>()) &#123;</span><br><span class="line">          <span class="comment">// 当前轻量级锁状态，先分配一个ObjectMonitor对象，并初始化值</span></span><br><span class="line">          ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">          <span class="comment">// Optimistically prepare the objectmonitor - anticipate successful CAS</span></span><br><span class="line">          <span class="comment">// We do this before the CAS in order to minimize the length of time</span></span><br><span class="line">          <span class="comment">// in which INFLATING appears in the mark.</span></span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">          m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;   <span class="comment">// Consider: maintain by type/class</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//将object-&gt;mark_addr()和mark比较，如果这两个值相等，则将object-&gt;mark_addr()</span></span><br><span class="line">          <span class="comment">//改成markOopDesc::INFLATING()</span></span><br><span class="line">          <span class="comment">//########## 相等返回是mark，不相等返回的是object-&gt;mark_addr() ##########</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 将锁对象的mark word设置为INFLATING (0)状态 </span></span><br><span class="line">          markOop cmp = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">INFLATING</span>(), object-&gt;<span class="built_in">mark_addr</span>(), mark) ;</span><br><span class="line">          <span class="keyword">if</span> (cmp != mark) &#123;<span class="comment">//CAS失败</span></span><br><span class="line">             <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;<span class="comment">//释放监视器</span></span><br><span class="line">             <span class="keyword">continue</span> ;       <span class="comment">// Interference -- just retry</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We&#x27;ve successfully installed INFLATING (0) into the mark-word.</span></span><br><span class="line">          <span class="comment">// This is the only case where 0 will appear in a mark-work.</span></span><br><span class="line">          <span class="comment">// Only the singular thread that successfully swings the mark-word</span></span><br><span class="line">          <span class="comment">// to 0 can perform (or more precisely, complete) inflation.</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// Why do we CAS a 0 into the mark-word instead of just CASing the</span></span><br><span class="line">          <span class="comment">// mark-word from the stack-locked value directly to the new inflated state?</span></span><br><span class="line">          <span class="comment">// Consider what happens when a thread unlocks a stack-locked object.</span></span><br><span class="line">          <span class="comment">// It attempts to use CAS to swing the displaced header value from the</span></span><br><span class="line">          <span class="comment">// on-stack basiclock back into the object header.  Recall also that the</span></span><br><span class="line">          <span class="comment">// header value (hashcode, etc) can reside in (a) the object header, or</span></span><br><span class="line">          <span class="comment">// (b) a displaced header associated with the stack-lock, or (c) a displaced</span></span><br><span class="line">          <span class="comment">// header in an objectMonitor.  The inflate() routine must copy the header</span></span><br><span class="line">          <span class="comment">// value from the basiclock on the owner&#x27;s stack to the objectMonitor, all</span></span><br><span class="line">          <span class="comment">// the while preserving the hashCode stability invariants.  If the owner</span></span><br><span class="line">          <span class="comment">// decides to release the lock while the value is 0, the unlock will fail</span></span><br><span class="line">          <span class="comment">// and control will eventually pass from slow_exit() to inflate.  The owner</span></span><br><span class="line">          <span class="comment">// will then spin, waiting for the 0 value to disappear.   Put another way,</span></span><br><span class="line">          <span class="comment">// the 0 causes the owner to stall if the owner happens to try to</span></span><br><span class="line">          <span class="comment">// drop the lock (restoring the header from the basiclock to the object)</span></span><br><span class="line">          <span class="comment">// while inflation is in-progress.  This protocol avoids races that might</span></span><br><span class="line">          <span class="comment">// would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.</span></span><br><span class="line">          <span class="comment">// Critically, while object-&gt;mark is 0 mark-&gt;displaced_mark_helper() is stable.</span></span><br><span class="line">          <span class="comment">// 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// fetch the displaced mark from the owner&#x27;s stack.</span></span><br><span class="line">          <span class="comment">// The owner can&#x27;t die or unwind past the lock while our INFLATING</span></span><br><span class="line">          <span class="comment">// object is in the mark.  Furthermore the owner can&#x27;t complete</span></span><br><span class="line">          <span class="comment">// an unlock on the object, either.</span></span><br><span class="line">          <span class="comment">// 栈中的displaced mark word</span></span><br><span class="line">          markOop dmw = mark-&gt;<span class="built_in">displaced_mark_helper</span>() ;</span><br><span class="line">          <span class="built_in">assert</span> (dmw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//######## CAS成功以后，设置ObjectMonitor相关属性 ########</span></span><br><span class="line">          <span class="comment">// Setup monitor fields to proper values -- prepare the monitor</span></span><br><span class="line">          <span class="comment">// 设置monitor的字段</span></span><br><span class="line">          m-&gt;<span class="built_in">set_header</span>(dmw) ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Optimization: if the mark-&gt;locker stack address is associated</span></span><br><span class="line">          <span class="comment">// with this thread we could simply set m-&gt;_owner = Self and</span></span><br><span class="line">          <span class="comment">// m-&gt;OwnerIsThread = 1. Note that a thread can inflate an object</span></span><br><span class="line">          <span class="comment">// that it has stack-locked -- as might happen in wait() -- directly</span></span><br><span class="line">          <span class="comment">// with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.</span></span><br><span class="line">          <span class="comment">// owner为Lock Record</span></span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>(mark-&gt;<span class="built_in">locker</span>());</span><br><span class="line">          m-&gt;<span class="built_in">set_object</span>(object);</span><br><span class="line">          <span class="comment">// TODO-<span class="doctag">FIXME:</span> assert BasicLock-&gt;dhw != 0.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Must preserve store ordering. The monitor state must</span></span><br><span class="line">          <span class="comment">// be stable at the time of publishing the monitor address.</span></span><br><span class="line">          <span class="built_in">guarantee</span> (object-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">INFLATING</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="comment">// 将锁对象头设置为重量级锁状态</span></span><br><span class="line">          object-&gt;<span class="built_in">release_set_mark</span>(markOopDesc::<span class="built_in">encode</span>(m));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Hopefully the performance counters are allocated on distinct cache lines</span></span><br><span class="line">          <span class="comment">// to avoid false sharing on MP systems ...</span></span><br><span class="line">          <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">          <span class="built_in">TEVENT</span>(Inflate: overwrite stacklock) ;</span><br><span class="line">          <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">              ResourceMark rm;</span><br><span class="line">              tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">                (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">                object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> m ;<span class="comment">//返回ObjectMonitor</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是无锁状态</span></span><br><span class="line">      <span class="comment">// CASE: neutral</span></span><br><span class="line">      <span class="comment">// TODO-<span class="doctag">FIXME:</span> for entry we currently inflate and then try to CAS _owner.</span></span><br><span class="line">      <span class="comment">// If we know we&#x27;re inflating for entry it&#x27;s better to inflate by swinging a</span></span><br><span class="line">      <span class="comment">// pre-locked objectMonitor pointer into the object header.   A successful</span></span><br><span class="line">      <span class="comment">// CAS inflates the object *and* confers ownership to the inflating thread.</span></span><br><span class="line">      <span class="comment">// In the current implementation we use a 2-step mechanism where we CAS()</span></span><br><span class="line">      <span class="comment">// to inflate and then CAS() again to try to swing _owner from NULL to Self.</span></span><br><span class="line">      <span class="comment">// An inflateTry() method that we could call from fast_enter() and slow_enter()</span></span><br><span class="line">      <span class="comment">// would be useful.</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span> (mark-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      <span class="comment">// 分配以及初始化ObjectMonitor对象</span></span><br><span class="line">      ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">      <span class="comment">// prepare m for installation - set monitor to initial state</span></span><br><span class="line">      m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">      m-&gt;<span class="built_in">set_header</span>(mark);</span><br><span class="line">      m-&gt;<span class="built_in">set_owner</span>(<span class="literal">NULL</span>);</span><br><span class="line">      m-&gt;<span class="built_in">set_object</span>(object);</span><br><span class="line">      m-&gt;OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">      m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">      m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       <span class="comment">// consider: keep metastats by type/class</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用CAS替换对象头的mark word为重量级锁状态</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">encode</span>(m), object-&gt;<span class="built_in">mark_addr</span>(), mark) != mark) &#123;</span><br><span class="line">          <span class="comment">// 不成功说明有另外一个线程在执行inflate，释放monitor对象</span></span><br><span class="line">          m-&gt;<span class="built_in">set_object</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>  (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>() ;</span><br><span class="line">          <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">          m = <span class="literal">NULL</span> ;</span><br><span class="line">          <span class="keyword">continue</span> ;</span><br><span class="line">          <span class="comment">// interference - the markword changed - just retry.</span></span><br><span class="line">          <span class="comment">// The state-transitions are one-way, so there&#x27;s no chance of</span></span><br><span class="line">          <span class="comment">// live-lock -- &quot;Inflated&quot; is an absorbing state.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Hopefully the performance counters are allocated on distinct</span></span><br><span class="line">      <span class="comment">// cache lines to avoid false sharing on MP systems ...</span></span><br><span class="line">      <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">      <span class="built_in">TEVENT</span>(Inflate: overwrite neutral) ;</span><br><span class="line">      <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">          ResourceMark rm;</span><br><span class="line">          tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">            object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> m <span class="comment">//返回ObjectMonitor对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inflate</code>中是一个<strong>for</strong>循环，主要是为了<strong>处理多线程同时调用inflate</strong>的情况。</p>
<p>然后<strong>inflate</strong>会根据锁对象的状态进行不同的处理：</p>
<blockquote>
<p>1.已经是重量级状态，说明膨胀已经完成，直接返</p>
<p>2.如果是轻量级锁则需要进行膨胀操作</p>
<p>3.如果是膨胀中状态，则进行忙等待</p>
<p>4.如果是无锁状态则需要进行膨胀操作</p>
</blockquote>
<p>其中轻量级锁和无锁状态需要进行膨胀操作，轻量级锁膨胀流程如下：</p>
<blockquote>
<p>1.调用<code>omAlloc</code>分配一个<code>ObjectMonitor</code>对象(以下简称monitor)，在<code>omAlloc</code>方法中会先从线程私有的<code>monitor</code>集合<code>omFreeList</code>中分配对象，如果<code>omFreeList</code>中已经没有<code>monitor</code>对象，则从JVM全局的<code>gFreeList</code>中分配一批<code>monitor</code>到<code>omFreeList</code>中。</p>
<p>2.初始化<code>monitor</code>对象</p>
<p>3.将状态设置为膨胀中（INFLATING）状态</p>
<p>4.设置<code>monitor</code>的header字段为<code>displaced mark word</code>，owner字段为<code>Lock Record</code>，obj字段为锁对象</p>
<p>5.设置锁对象头的<code>mark word</code>为重量级锁状态，指向第一步分配的<code>monitor</code>对象</p>
</blockquote>
<p>无锁状态下的膨胀流程如下：</p>
<blockquote>
<p>1.调用<code>omAlloc</code>分配一个<code>ObjectMonitor</code>对象(以下简称monitor)</p>
<p>2.初始化<code>monitor</code>对象</p>
<p>3.设置<code>monitor</code>的header字段为<code> mark word</code>，owner字段为<code>null</code>，obj字段为锁对象</p>
<p>4.设置锁对象头的<code>mark word</code>为重量级锁状态，指向第一步分配的<code>monitor</code>对象</p>
</blockquote>
<p><strong>膨胀完成之后，会调用<code>enter</code>方法获得锁</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">  <span class="keyword">void</span> * cur ;</span><br><span class="line">  <span class="comment">// owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁</span></span><br><span class="line">  cur = Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是重入的情况</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前线程是之前持有轻量级锁的线程。</span></span><br><span class="line">  <span class="comment">//由轻量级锁膨胀且第一次调用enter方法的过程可知，那此时cur是指向Lock Record的指针</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;<span class="built_in">is_lock_owned</span> ((address)cur)) &#123;</span><br><span class="line">    <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    <span class="comment">// 重入计数重置为1</span></span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// 设置owner字段为当前线程（之前owner是指向Lock Record的指针）</span></span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在调用系统的同步操作之前，先尝试自旋获得锁</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">//自旋的过程中获得了锁，则直接返回</span></span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line">      <span class="comment">// 在该方法中调用系统同步操作</span></span><br><span class="line">      <span class="built_in">EnterI</span> (THREAD) ;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>EnterI的流程：</strong></p>
<ol>
<li>如果当前是无锁状态、锁重入、当前线程是之前持有轻量级锁的线程则进行简单操作后返回。</li>
<li>先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销</li>
<li>调用<code>EnterI</code>方法获得锁或阻塞</li>
</ol>
<p><code>EnterI</code>方法比较长，在看之前，我们先阐述下其大致原理：一个<code>ObjectMonitor</code>对象包括这么几个关键字段：cxq（下图中的ContentionList），EntryList ，WaitSet，owner。其中cxq ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p>
<p><img src="https://camo.githubusercontent.com/c67e1e05cd18036d99db46063368d4d60fdae88f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162306164346662653f773d3131303126683d34303026663d7765627026733d3135363832" alt="img"></p>
<p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到cxq的队列的队首，然后调用<code>park</code>函数挂起当前线程。当线程释放锁时，会从cxq或EntryList中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>即假定继承人（应该是这样翻译），就是图中的<code>Ready Thread</code>，假定继承人被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁（这也是它叫”假定”继承人的原因）。</p>
<p>如果线程获得锁后调用<code>Object#wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object#notify</code>唤醒后，会将线程从WaitSet移动到cxq或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p>
<blockquote>
<p>当线程释放锁时，会从cxq或EntryList中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>即假定继承人（应该是这样翻译），就是图中的<code>Ready Thread</code>，假定继承人被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁（这也是它叫”假定”继承人的原因）。</p>
<p>如果线程获得锁后调用<code>Object#wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object#notify</code>唤醒后，会将线程从WaitSet移动到cxq或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p>
</blockquote>
<p><strong>开始分析<code>EnterI</code>方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 尝试获得锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将线程封装成node节点中</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将node节点插入到_cxq队列的头部，cxq是一个单向链表</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS失败的话 再尝试获得锁，这样可以降低插入到_cxq队列的频率</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SyncFlags默认为0，如果没有其他等待的线程，则将_Responsible设置为自己</span></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">TEVENT</span> (Inflated enter - Contention) ;</span><br><span class="line">    <span class="keyword">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 	<span class="comment">//node节点添加到_cxq队列之后，继续通过自旋尝试获取锁，如果在指定的阈值范围内没有获得锁，则通过park将当		前线程挂起，等待被唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="built_in">assert</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// park self//通过park挂起当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 当前线程是_Responsible时，调用的是带时间参数的park</span></span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则直接调用park挂起当前线程</span></span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;<span class="comment">//当线程被唤醒时，会从这里继续执行</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">       	...</span><br><span class="line">        <span class="comment">// 在释放锁时，_succ会被设置为EntryList或_cxq中的一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 走到这里说明已经获得锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span> (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (<span class="built_in">object</span>() != <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 将当前线程的node从cxq或EntryList中移除</span></span><br><span class="line">    <span class="built_in">UnlinkAfterAcquire</span> (Self, &amp;node) ;</span><br><span class="line">    <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">	<span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TryLock(self)的代码是在 ObjectMonitor::TryLock定义的，代码的实现原理很简单，通过自旋，CAS设置monitor的_owner字段为当前线程，如果成功，表示获取到了锁，如果失败，则继续被挂起。代码的实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">void</span> * own = _owner ;</span><br><span class="line">      <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">         <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The lock had been free momentarily, but we lost the race to the lock.</span></span><br><span class="line">      <span class="comment">// Interference -- the CAS failed.</span></span><br><span class="line">      <span class="comment">// We can either return -1 or retry.</span></span><br><span class="line">      <span class="comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>主要步骤有3步：</strong></p>
<ol>
<li>将当前线程插入到cxq队列的队首</li>
<li>然后park当前线程</li>
<li>当被唤醒后再尝试获得锁</li>
</ol>
<p>这里需要特别说明的是<code>_Responsible</code>和<code>_succ</code>两个字段的作用：</p>
<blockquote>
<p>当竞争发生时，选取一个线程作为<code>_Responsible</code>，<code>_Responsible</code>线程调用的是有时间限制的<code>park</code>方法，其目的是防止出现<code>搁浅</code>现象。</p>
<p><code>_succ</code>线程是在线程释放锁时被设置，其含义是<code>Heir presumptive</code>，也就是我们上面说的假定继承人。</p>
</blockquote>
<h2 id="12-重量级锁的释放"><a href="#12-重量级锁的释放" class="headerlink" title="12 重量级锁的释放"></a>12 重量级锁的释放</h2><p>重量级锁释放的代码在<code>ObjectMonitor::exit</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">   <span class="comment">// 如果_owner不是当前线程</span></span><br><span class="line">   <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">     <span class="comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀后还没调用过enter方法，_owner会是指向Lock Record的指针。</span></span><br><span class="line">     <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) _owner)) &#123;</span><br><span class="line">       <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">       _owner = THREAD ;</span><br><span class="line">       _recursions = <span class="number">0</span> ;</span><br><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 异常情况:当前不是持有锁的线程</span></span><br><span class="line">       <span class="built_in">TEVENT</span> (Exit - Throw IMSX) ;</span><br><span class="line">       <span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">&quot;Non-balanced monitor enter/exit!&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalMonitorStateException</span>());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果当前，线程重入锁的次数，不为0，那么就重新走ObjectMonitor::exit，直到重入锁次数为0为止</span></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">     _recursions--;        <span class="comment">// this is simple recursive enter 递归循环知道0？？？</span></span><br><span class="line">     <span class="built_in">TEVENT</span> (Inflated exit - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// _Responsible设置为null</span></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="built_in">assert</span> (THREAD == _owner, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Knob_ExitPolicy默认为0</span></span><br><span class="line">      <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// code 1：先释放锁，这时如果有其他线程进入同步块则能获得锁</span></span><br><span class="line">         OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">         OrderAccess::<span class="built_in">storeload</span>() ;                         <span class="comment">// See if we need to wake a successor</span></span><br><span class="line">         <span class="comment">// code 2：如果没有等待的线程或已经有假定继承人</span></span><br><span class="line">         <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// code 3：要执行之后的操作需要重新获得锁，即设置_owner为当前线程</span></span><br><span class="line">         <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Exit - Reacquired) ;</span><br><span class="line">      &#125; </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="comment">// code 4：根据QMode的不同会有不同的唤醒策略，默认为0</span></span><br><span class="line">      <span class="keyword">int</span> QMode = Knob_QMode ;</span><br><span class="line">	 </span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// QMode == 2 : cxq中的线程有更高优先级，直接唤醒cxq的队首线程</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 将cxq中的元素插入到EntryList的末尾</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Append the RATs to the EntryList</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span></span><br><span class="line">          ObjectWaiter * Tail ;</span><br><span class="line">          <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">          <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              _EntryList = w ;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Tail-&gt;_next = w ;</span><br><span class="line">              w-&gt;_prev = Tail ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 将cxq插入到EntryList的队首</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Prepend the RATs to the EntryList</span></span><br><span class="line">          <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              q-&gt;_next = _EntryList ;</span><br><span class="line">              _EntryList-&gt;_prev = q ;</span><br><span class="line">          &#125;</span><br><span class="line">          _EntryList = w ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果EntryList不为空，则直接唤醒EntryList的队首元素</span></span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// EntryList为null，则处理cxq中的元素</span></span><br><span class="line">      w = _cxq ;</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 因为之后要将cxq的元素移动到EntryList，所以这里将cxq字段设置为null</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">          <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">          w = u ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">TEVENT</span> (Inflated exit - drain cxq into EntryList) ;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      <span class="built_in">assert</span> (_EntryList  == <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// QMode == 1 : 将cxq中的元素转移到EntryList，并反转顺序</span></span><br><span class="line">         ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * t = w ;</span><br><span class="line">         ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">             t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             u = t-&gt;_next ;</span><br><span class="line">             t-&gt;_prev = u ;</span><br><span class="line">             t-&gt;_next = s ;</span><br><span class="line">             s = t;</span><br><span class="line">             t = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         _EntryList  = s ;</span><br><span class="line">         <span class="built_in">assert</span> (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// QMode == 0 or QMode == 2‘</span></span><br><span class="line">         <span class="comment">// 将cxq中的元素转移到EntryList</span></span><br><span class="line">         _EntryList = w ;</span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// _succ不为null，说明已经有个继承人了，所以不需要当前线程去唤醒，减少上下文切换的比率</span></span><br><span class="line">      <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="comment">// 唤醒EntryList第一个元素</span></span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="built_in">guarantee</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行必要的锁重入判断以及自旋优化后，进入到主要逻辑：</p>
<blockquote>
<p>code 1 设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化；</p>
<p>code 2 如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。或者如果说succ不为null，表当前已经有个”醒着的”继承人线程，那当前线程不需要唤醒任何线程；</p>
<p>code 3 当前线程重新获得锁，因为之后要操作cxq和EntryList队列以及唤醒线程；</p>
</blockquote>
<p>根据QMode的不同，有不同的处理方式：</p>
<blockquote>
<p>QMode = 2且cxq非空：取cxq队列队首的ObjectWaiter对象，调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回，后面的代码不会执行了；</p>
<p>QMode = 3且cxq非空：把cxq队列插入到EntryList的尾部；</p>
<p>QMode = 4且cxq非空：把cxq队列插入到EntryList的头部；</p>
<p>QMode = 0：暂时什么都不做，继续往下看；</p>
</blockquote>
<p>只有QMode=2的时候会提前返回，等于0、3、4的时候都会继续往下执行：</p>
<blockquote>
<p>1.如果EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回；<br>2.如果EntryList的首元素为空，就将cxq的所有元素放入到EntryList中，然后再从EntryList中取出来队首元素执行ExitEpilog方法，然后立即返回；</p>
</blockquote>
<h2 id="13-实例"><a href="#13-实例" class="headerlink" title="13 实例"></a>13 实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.test0317;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SyncDemo syncDemo1 = <span class="keyword">new</span> SyncDemo();</span><br><span class="line">        syncDemo1.startThreadA();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        syncDemo1.startThreadB();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        syncDemo1.startThreadC();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A get lock&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;A release lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-A&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;B get lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;C get lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">A get lock</span></span><br><span class="line"><span class="comment">A release lock</span></span><br><span class="line"><span class="comment">C get lock</span></span><br><span class="line"><span class="comment">B get lock</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>默认策略下，在A释放锁后一定是C线程先于B获得锁</strong>。因为在获取锁时，是将当前线程插入到cxq的<strong>头部</strong>，而释放锁时，默认策略是：如果EntryList为空，则将cxq中的元素按原有顺序插入到到EntryList，并唤醒第一个线程。也就是<strong>当EntryList为空时，是后来的线程先获取锁</strong>。这点JDK中的Lock机制是不一样的。</p>
<p>再看这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.test0317;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> sleepVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(sleepVal);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                log(<span class="string">&quot;get lock&quot;</span>);</span><br><span class="line">                startThreadB();</span><br><span class="line">                log(<span class="string">&quot;start wait&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                log(<span class="string">&quot;get lock after wait&quot;</span>);</span><br><span class="line">                log(<span class="string">&quot;release lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-A&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                log(<span class="string">&quot;get lock&quot;</span>);</span><br><span class="line">                startThreadC();</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                log(<span class="string">&quot;start notify&quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                log(<span class="string">&quot;release lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                log(<span class="string">&quot;get lock&quot;</span>);</span><br><span class="line">                log(<span class="string">&quot;release lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NotifyDemo().startThreadA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> thread-A : get lock</span></span><br><span class="line"><span class="comment"> thread-A : start wait</span></span><br><span class="line"><span class="comment"> thread-B : get lock</span></span><br><span class="line"><span class="comment"> thread-B : start notify</span></span><br><span class="line"><span class="comment"> thread-B : release lock</span></span><br><span class="line"><span class="comment"> thread-A : get lock after wait</span></span><br><span class="line"><span class="comment"> thread-A : release lock</span></span><br><span class="line"><span class="comment"> thread-C : get lock</span></span><br><span class="line"><span class="comment"> thread-C : release lock</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>比较复杂，结合wait/notify的底层原理可知：</p>
<blockquote>
<p>1 线程A在wait() 后被加入了_WaitSet队列中；<br>2 线程C被线程B启动后竞争锁失败，被加入到_cxq队列的首位；<br>3 线程B在notify()时，从_WaitSet中取出第一个，根据Policy的不同，将这个线程放入_EntryList或者_cxq队列中的起始或末尾位置；这个例子中Policy=2,将A放在EntryList首位（此时EntryList只有A）<br>4 线程B释放了锁之后根据QMode的不同，将ObjectWaiter从_cxq或者_EntryList中取出后唤醒；此例子QMode默认值0（如果_EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回；如果_EntryList的首元素为空，就取_cxq的首元素，放入_EntryList，然后再从_EntryList中取出来执行ExitEpilog方法，然后立即返回）</p>
</blockquote>
<p><strong>因此C必定抢不过A</strong></p>
<h1 id="二、synchronized的缺陷"><a href="#二、synchronized的缺陷" class="headerlink" title="二、synchronized的缺陷"></a>二、synchronized的缺陷</h1><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享变量（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，java程序是靠synchronized关键字实现锁功能的，java se5之后，并发包中新增了lock 接口以及相关实现类用来实现锁功能。它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式的的获取和释放锁。虽然它减少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断地获取锁以及超时获取锁等多种synchronized所不具备的同步特性。</p>
<p><strong>（1）</strong>只用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固定化了，也就是先获取再释放。当然这种方式简化了同步的管理，可是扩展性没有显式的锁获取和释放来得好。比如，针对一个场景，先获取锁A，然后获取B，当获得B后释放A同时获取C，再释放B同时获取D，以此类推。这种情景下，synchronized就不那么容易实现了，而lock就可以。</p>
<p><strong>（2）</strong>当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p>
<p><strong>（3）</strong>如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p>
<p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p>
<p>1）Java提供的内置锁机制，Java中的每个对象都可以用作一个实现同步的锁（内置锁或者监视器Monitor），线程在进入同步代码块之前需要获取这把锁，在退出同步代码块会释放锁。而synchronized这种内置锁实际上是互斥的，<strong>即1把锁最多只能由一个线程持有</strong>；</p>
<p>2）Lock接口提供了与synchronized相似的同步功能，和synchronized（隐式的获取和释放锁，主要体现在线程进入同步代码块之前需要获取锁退出同步代码块需要释放锁）不同的是，Lock在使用的时候是显示的获取和释放锁。虽然Lock接口缺少了synchronized隐式获取释放锁的便捷性，但是对于锁的操作具有更强的可操作性、可控制性以及提供可中断操作和超时获取锁等机制。</p>
<h1 id="三、锁优化技术"><a href="#三、锁优化技术" class="headerlink" title="三、锁优化技术"></a>三、锁优化技术</h1><p>参考周志明 《深入理解java虚拟机》第13章相关内容</p>
<h1 id="四、JUC-locks下的Lock接口"><a href="#四、JUC-locks下的Lock接口" class="headerlink" title="四、JUC.locks下的Lock接口"></a>四、JUC.locks下的Lock接口</h1><p><strong>相比于synchronized，Lock接口所具备的其他特性：</strong></p>
<p>①尝试非阻塞的获取锁tryLock()：当前线程尝试获取锁，如果该时刻锁没有被其他线程获取到，就能成功获取并持有锁</p>
<p>②能被中断的获取锁lockInterruptibly()：获取到锁的线程能够响应中断，当获取到锁的线程被中断的时候，会抛出中断异常同时释放持有的锁</p>
<p>③超时的获取锁tryLock(long time, TimeUnit unit)：在指定的截止时间获取锁，如果没有获取到锁返回false</p>
<p><strong>Lock接口的源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁，调用该方法的线程会获取锁，当获取到锁之后会从该方法但会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可响应中断。即在获取锁的过程中可以中断当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试非阻塞的获取锁，调用该方法之后会立即返回，如果获取到锁就返回true否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时的获取锁，下面的三种情况会返回</span></span><br><span class="line"><span class="comment">     * ①当前线程在超时时间内获取到了锁</span></span><br><span class="line"><span class="comment">     * ②当前线程在超时时间内被中断</span></span><br><span class="line"><span class="comment">     * ③超时时间结束，返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取等待通知组件，该组件和当前锁绑定，当前线程只有获取到了锁才能调用组件的wait方法，调用该方法之后会释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lock接口使用方法举例如下</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//不要将获取锁的过程写在try块中，防止获取锁抛出异常导致锁无故释放</span></span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁，预防死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhan729/p/8601108.html">相关用法见这篇文章</a>。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3923167.html">还有这篇</a></p>
<h1 id="五、锁的特性"><a href="#五、锁的特性" class="headerlink" title="五、锁的特性"></a>五、锁的特性</h1><p><code>synchronized</code>关键字在需要<strong>原子性、可见性和有序性</strong>这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。</p>
<h2 id="synchronized与原子性"><a href="#synchronized与原子性" class="headerlink" title="synchronized与原子性"></a>synchronized与原子性</h2><p>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</p>
<p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于<strong>时间片在线程间轮换</strong>，就会发生<strong>原子性问题</strong>。</p>
<p>通过<code>monitorenter</code>和<code>monitorexit</code>指令，可以保证<strong>被<code>synchronized</code>修饰的代码在同一时间只能被一个线程访问</strong>，在锁未释放之前，无法被其他线程访问到。线程1在执行<code>monitorenter</code>指令的时候，会对Monitor进行加锁，加锁后其他线程无法获得锁，除非线程1主动解锁。即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是，他并没有进行解锁。而由于<code>synchronized</code>的锁是可重入的，<strong>下一个时间片还是只能被他自己获取到</strong>，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p>
<h2 id="synchronized与可见性"><a href="#synchronized与可见性" class="headerlink" title="synchronized与可见性"></a>synchronized与可见性</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。</p>
<p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效。</strong>所以，synchronized关键字锁住的对象，其值是具有可见性的。</p>
<h2 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h2><p>有序性即程序执行的顺序按照代码的先后顺序执行。</p>
<p>除了引入了时间片以外，由于<strong>处理器优化和指令重排</strong>等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p>
<p>这里需要注意的是，**<code>synchronized</code>是无法禁止指令重排和处理器优化的**。也就是说，<code>synchronized</code>无法避免上述提到的问题。那么，为什么还说<code>synchronized</code>也提供了有序性保证呢？</p>
<p>这就要再把有序性的概念扩展一下了。Java程序中天然的有序性可以总结为一句话：<strong>如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</strong>简单扩展一下，这其实和<code>as-if-serial语义</code>有关。</p>
<p><code>as-if-serial</code>语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守<code>as-if-serial</code>语义。这里不对<code>as-if-serial语义</code>详细展开了，简单说就是，<code>as-if-serial语义</code>保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。</p>
<p>所以，由于<code>synchronized</code>修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。</p>
<h1 id="思考wait-notify-和-synchronized的联系"><a href="#思考wait-notify-和-synchronized的联系" class="headerlink" title="思考wait/notify 和 synchronized的联系"></a>思考wait/notify 和 synchronized的联系</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5029b8c55de0">深入剖析Java关键字之synchronized(源码篇)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f9b1159d4fde">深入剖析Java关键字之synchronized(原理篇)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现–概论</a></p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/view/5c25db87e4b016324f447c95">偏向锁轻量级锁获取流程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c13c0a80dbca">（六）synchronized的源码分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kundeg/p/8422557.html">从jvm源码看synchronized</a></p>
<p>​         </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%85%B3%E4%BA%8Esynchronized%E5%92%8CLock/">http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%85%B3%E4%BA%8Esynchronized%E5%92%8CLock/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">原子操作的实现原理</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/start%E5%92%8Crun/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关键字</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/18/template/" title="关键字"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">关键字</div></div></a></div><div><a href="/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="JVM类加载机制"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">JVM类加载机制</div></div></a></div><div><a href="/2021/12/18/Java/JVM/Java%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/" title="关键字"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">关键字</div></div></a></div><div><a href="/2021/12/18/Java/JVM/classLoader%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="双亲委派模型有啥好处？"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">双亲委派模型有啥好处？</div></div></a></div><div><a href="/2021/12/18/Java/JVM/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" title="class文件结构"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">class文件结构</div></div></a></div><div><a href="/2021/12/18/Java/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/" title="关键字"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">关键字</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-%E5%90%8C%E6%AD%A5%E5%85%B3%E9%94%AE%E5%AD%97synchronized"><span class="toc-number">1.</span> <span class="toc-text">一、Java 同步关键字synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">1 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%90%8C%E6%AD%A5%E7%9A%84%E6%83%85%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">3 同步的情景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">4 同步的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.1 Java对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.2 锁的升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3 偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.4 轻量级锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.</span> <span class="toc-text">5 锁的优缺点对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Monitor%E7%9B%91%E8%A7%86%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">6 Monitor监视器对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81synchronized%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">二、synchronized源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#00-%E7%81%B5%E9%AD%82%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">00 灵魂图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-cmpxchg-ptr"><span class="toc-number">2.2.</span> <span class="toc-text">0 cmpxchg_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-java%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B-OOP-Klass-%E6%BA%90%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">1 java对象实例-OOP-Klass(源码)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Klass"><span class="toc-number">2.4.</span> <span class="toc-text">2 Klass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Mark-Word-markOop"><span class="toc-number">2.5.</span> <span class="toc-text">3 Mark Word-markOop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ObjectMonitor"><span class="toc-number">2.6.</span> <span class="toc-text">4 ObjectMonitor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%81%8F%E5%90%91%E9%94%81%E5%85%A5%E5%8F%A3"><span class="toc-number">2.7.</span> <span class="toc-text">5 偏向锁入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">2.8.</span> <span class="toc-text">6 偏向锁的撤销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">2.9.</span> <span class="toc-text">7 偏向锁的释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E5%92%8C%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">2.10.</span> <span class="toc-text">8 批量重偏向和批量撤销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-number">2.11.</span> <span class="toc-text">9 轻量级锁获取流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E9%87%8A%E6%94%BE%E6%B5%81%E7%A8%8B"><span class="toc-number">2.12.</span> <span class="toc-text">10 轻量级锁释放流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E9%87%8D%E9%87%8F%E7%BA%A7%E7%9A%84%E8%86%A8%E8%83%80%E5%92%8C%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">2.13.</span> <span class="toc-text">11 重量级的膨胀和加锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">2.14.</span> <span class="toc-text">12 重量级锁的释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.15.</span> <span class="toc-text">13 实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81synchronized%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">3.</span> <span class="toc-text">二、synchronized的缺陷</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">三、锁优化技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JUC-locks%E4%B8%8B%E7%9A%84Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">四、JUC.locks下的Lock接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%94%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">五、锁的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">synchronized与原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">synchronized与可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">synchronized与有序性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%80%83wait-notify-%E5%92%8C-synchronized%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">思考wait&#x2F;notify 和 synchronized的联系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Sentinel/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Sentinel/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.161Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Replication/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Replication/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.155Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关键字"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字">关键字</a><time datetime="2021-12-18T14:44:09.151Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>