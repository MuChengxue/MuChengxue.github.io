<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>从ReentrantLock看AQS独占功能 | 暮成雪的博客</title><meta name="keywords" content="AQS"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Concurrent包的实现原理由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。 1）A线程写volatile变量，随后B线程读这个volatile变量。 2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。 3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个vo">
<meta property="og:type" content="article">
<meta property="og:title" content="从ReentrantLock看AQS独占功能">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8B%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="一、Concurrent包的实现原理由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。 1）A线程写volatile变量，随后B线程读这个volatile变量。 2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。 3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个vo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:26.020Z">
<meta property="article:modified_time" content="2020-04-15T12:13:13.560Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="AQS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8B%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从ReentrantLock看AQS独占功能',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-04-15 12:13:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从ReentrantLock看AQS独占功能</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:26.020Z" title="发表于 2021-12-18 14:42:26">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-04-15T12:13:13.560Z" title="更新于 2020-04-15 12:13:13">2020-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="从ReentrantLock看AQS独占功能"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8B%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8B%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Concurrent包的实现原理"><a href="#一、Concurrent包的实现原理" class="headerlink" title="一、Concurrent包的实现原理"></a>一、Concurrent包的实现原理</h1><p>由于Java的<code>CAS</code>同时具有<code>volatile</code>读和<code>volatile</code>写的内存语义，因此<code>Java</code>线程之间的通信现在有了下面4种方式。<br> 1）A线程写<code>volatile</code>变量，随后B线程读这个<code>volatile</code>变量。<br> 2）A线程写<code>volatile</code>变量，随后B线程用CAS更新这个<code>volatile</code>变量。<br> 3）A线程用<code>CAS</code>更新一个<code>volatile</code>变量，随后B线程用<code>CAS</code>更新这个volatile变量。<br> 4）A线程用<code>CAS</code>更新一个<code>volatile</code>变量，随后B线程读这个<code>volatile</code>变量。</p>
<p>Java的<code>CAS</code>会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，**<code>volatile</code>变量的读/写和<code>CAS</code>可以实现线程之间的通信<strong>。把这些特性整合在一起，再</strong>加上Unsafe类<strong>就形成了</strong>整个<code>concurrent</code>包得以实现的基石<strong>。如果我们仔细分析<code>concurrent</code>包的源代码实现，会发现一个</strong>通用化的实现模式**。</p>
<ul>
<li><strong>首先，声明共享变量为<code>volatile</code>。</strong></li>
<li><strong>然后，使用<code>CAS</code>的原子条件更新来实现线程之间的同步。</strong></li>
<li><strong>同时，配合以<code>volatile</code>的读/写和<code>CAS</code>所具有的<code>volatile</code>读和写的内存语义来实现线程之间的通信。</strong></li>
</ul>
<p><code>AQS</code>，非阻塞数据结构和原子变量类（<code>java.util.concurrent.atomic</code>包中的类），这些<code>concurrent</code>包中的基础类都是使用这种模式来实现的，而<code>concurrent</code>包中的高层类又是依赖于这些基础类来实现的。从整体来看，<code>concurrent</code>包的实现示意图如下所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-6cd861cb7b7c3128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/502/format/webp" alt="img"></p>
<h1 id="二、Lock简介"><a href="#二、Lock简介" class="headerlink" title="二、Lock简介"></a>二、Lock简介</h1><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在<code>Lock</code>接口出现之前，<code>java</code>程序主要是靠<code>synchronized</code>关键字实现锁功能的，而java5之后，并发包中增加了<code>Lock</code>接口，它提供了与synchronized一样的锁功能。虽然它失去了像<code>synchronize</code>关键字隐式加锁解锁的<strong>便捷性</strong>，但是却拥有了锁获取和释放的<strong>可操作性</strong>，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。具体如下：</p>
<p>①<strong>尝试非阻塞的获取锁</strong>tryLock()：当前线程尝试获取锁，如果该时刻锁没有被其他线程获取到，就能成功获取并持有锁</p>
<p>②<strong>能被中断的获取锁</strong>lockInterruptibly()：获取到锁的线程能够响应中断，当获取到锁的线程被中断的时候，会抛出中断异常同时释放持有的锁</p>
<p>③<strong>超时的获取锁</strong>tryLock(long time, TimeUnit unit)：在指定的截止时间获取锁，如果没有获取到锁返回false</p>
<p><strong>Lock接口的源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁，调用该方法的线程会获取锁，当获取到锁之后会从该方法但会返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可响应中断。即在获取锁的过程中可以中断当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试非阻塞的获取锁，调用该方法之后会立即返回，如果获取到锁就返回true否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时的获取锁，下面的三种情况会返回</span></span><br><span class="line"><span class="comment">     * ①当前线程在超时时间内获取到了锁</span></span><br><span class="line"><span class="comment">     * ②当前线程在超时时间内被中断</span></span><br><span class="line"><span class="comment">     * ③超时时间结束，返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取等待通知组件，该组件和当前锁绑定，当前线程只有获取到了锁才能调用组件的wait方法，调用该方法之后会释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lock接口使用方法举例如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//不要将获取锁的过程写在try块中，防止获取锁抛出异常导致锁无故释放</span></span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁，预防死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最熟悉的<code>ReentrantLock</code>就是实现了<code>Lock</code>接口：<code>ReentrantLock</code>基本上所有的方法的实现实际上都是调用了其静态内存类<code>Sync</code>中的方法，而<code>Sync</code>类继承了<code>AbstractQueuedSynchronizer（AQS）</code>。可以看出要想理解<code>ReentrantLock</code>关键核心在于对队列同步器<code>AbstractQueuedSynchronizer</code>（简称队列同步器）的理解。</p>
<h1 id="三、AQS概述"><a href="#三、AQS概述" class="headerlink" title="三、AQS概述"></a>三、AQS概述</h1><p>AbstractQueuedSynchronizer抽象类（以下简称AQS）是整个<code>java.util.concurrent</code>包的核心。在JDK1.5时，<a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">Doug Lea</a>引入了J.U.C包，该包中的大多数同步器都是基于AQS来构建的。AQS框架提供了一套通用的机制来管理同步状态（synchronization state）、阻塞/唤醒线程、管理【同步队列】。关于AQS在源码中有十分具体的解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Provides a framework for implementing blocking locks and related</span></span><br><span class="line"><span class="comment">* synchronizers (semaphores, events, etc) that rely on</span></span><br><span class="line"><span class="comment">* first-in-first-out (FIFO) wait queues.  This class is designed to</span></span><br><span class="line"><span class="comment">* be a useful basis for most kinds of synchronizers that rely on a</span></span><br><span class="line"><span class="comment">* single atomic &#123;<span class="doctag">@code</span> int&#125; value to represent state. Subclasses</span></span><br><span class="line"><span class="comment">* must define the protected methods that change this state, and which</span></span><br><span class="line"><span class="comment">* define what that state means in terms of this object being acquired</span></span><br><span class="line"><span class="comment">* or released.  Given these, the other methods in this class carry</span></span><br><span class="line"><span class="comment">* out all queuing and blocking mechanics. Subclasses can maintain</span></span><br><span class="line"><span class="comment">* other state fields, but only the atomically updated &#123;<span class="doctag">@code</span> int&#125;</span></span><br><span class="line"><span class="comment">* value manipulated using methods &#123;<span class="doctag">@link</span> #getState&#125;, &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #setState&#125; and &#123;<span class="doctag">@link</span> #compareAndSetState&#125; is tracked with respect</span></span><br><span class="line"><span class="comment">* to synchronization.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Subclasses should be defined as non-public internal helper</span></span><br><span class="line"><span class="comment">* classes that are used to implement the synchronization properties</span></span><br><span class="line"><span class="comment">* of their enclosing class.  Class</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; does not implement any</span></span><br><span class="line"><span class="comment">* synchronization interface.  Instead it defines methods such as</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #acquireInterruptibly&#125; that can be invoked as</span></span><br><span class="line"><span class="comment">* appropriate by concrete locks and related synchronizers to</span></span><br><span class="line"><span class="comment">* implement their public methods.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This class supports either or both a default &lt;em&gt;exclusive&lt;/em&gt;</span></span><br><span class="line"><span class="comment">* mode and a &lt;em&gt;shared&lt;/em&gt; mode. When acquired in exclusive mode,</span></span><br><span class="line"><span class="comment">* attempted acquires by other threads cannot succeed. Shared mode</span></span><br><span class="line"><span class="comment">* acquires by multiple threads may (but need not) succeed. This class</span></span><br><span class="line"><span class="comment">* does not &amp;quot;understand&amp;quot; these differences except in the</span></span><br><span class="line"><span class="comment">* mechanical sense that when a shared mode acquire succeeds, the next</span></span><br><span class="line"><span class="comment">* waiting thread (if one exists) must also determine whether it can</span></span><br><span class="line"><span class="comment">* acquire as well. Threads waiting in the different modes share the</span></span><br><span class="line"><span class="comment">* same FIFO queue. Usually, implementation subclasses support only</span></span><br><span class="line"><span class="comment">* one of these modes, but both can come into play for example in a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> ReadWriteLock&#125;. Subclasses that support only exclusive or</span></span><br><span class="line"><span class="comment">* only shared modes need not define the methods supporting the unused mode.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This class defines a nested &#123;<span class="doctag">@link</span> ConditionObject&#125; class that</span></span><br><span class="line"><span class="comment">* can be used as a &#123;<span class="doctag">@link</span> Condition&#125; implementation by subclasses</span></span><br><span class="line"><span class="comment">* supporting exclusive mode for which method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #isHeldExclusively&#125; reports whether synchronization is exclusively</span></span><br><span class="line"><span class="comment">* held with respect to the current thread, method &#123;<span class="doctag">@link</span> #release&#125;</span></span><br><span class="line"><span class="comment">* invoked with the current &#123;<span class="doctag">@link</span> #getState&#125; value fully releases</span></span><br><span class="line"><span class="comment">* this object, and &#123;<span class="doctag">@link</span> #acquire&#125;, given this saved state value,</span></span><br><span class="line"><span class="comment">* eventually restores this object to its previous acquired state.  No</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; method otherwise creates such a</span></span><br><span class="line"><span class="comment">* condition, so if this constraint cannot be met, do not use it.  The</span></span><br><span class="line"><span class="comment">* behavior of &#123;<span class="doctag">@link</span> ConditionObject&#125; depends of course on the</span></span><br><span class="line"><span class="comment">* semantics of its synchronizer implementation.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This class provides inspection, instrumentation, and monitoring</span></span><br><span class="line"><span class="comment">* methods for the internal queue, as well as similar methods for</span></span><br><span class="line"><span class="comment">* condition objects. These can be exported as desired into classes</span></span><br><span class="line"><span class="comment">* using an &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; for their</span></span><br><span class="line"><span class="comment">* synchronization mechanics.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Serialization of this class stores only the underlying atomic</span></span><br><span class="line"><span class="comment">* integer maintaining state, so deserialized objects have empty</span></span><br><span class="line"><span class="comment">* thread queues. Typical subclasses requiring serializability will</span></span><br><span class="line"><span class="comment">* define a &#123;<span class="doctag">@code</span> readObject&#125; method that restores this to a known</span></span><br><span class="line"><span class="comment">* initial state upon deserialization.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;h3&gt;Usage&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;To use this class as the basis of a synchronizer, redefine the</span></span><br><span class="line"><span class="comment">* following methods, as applicable, by inspecting and/or modifying</span></span><br><span class="line"><span class="comment">* the synchronization state using &#123;<span class="doctag">@link</span> #getState&#125;, &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #setState&#125; and/or &#123;<span class="doctag">@link</span> #compareAndSetState&#125;:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;ul&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt; &#123;<span class="doctag">@link</span> #tryAcquire&#125;</span></span><br><span class="line"><span class="comment">* &lt;li&gt; &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">* &lt;li&gt; &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;</span></span><br><span class="line"><span class="comment">* &lt;li&gt; &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">* &lt;li&gt; &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">* &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Each of these methods by default throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* UnsupportedOperationException&#125;.  Implementations of these methods</span></span><br><span class="line"><span class="comment">* must be internally thread-safe, and should in general be short and</span></span><br><span class="line"><span class="comment">* not block. Defining these methods is the &lt;em&gt;only&lt;/em&gt; supported</span></span><br><span class="line"><span class="comment">* means of using this class. All other methods are declared</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> final&#125; because they cannot be independently varied.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;You may also find the inherited methods from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* AbstractOwnableSynchronizer&#125; useful to keep track of the thread</span></span><br><span class="line"><span class="comment">* owning an exclusive synchronizer.  You are encouraged to use them</span></span><br><span class="line"><span class="comment">* -- this enables monitoring and diagnostic tools to assist users in</span></span><br><span class="line"><span class="comment">* determining which threads hold locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Even though this class is based on an internal FIFO queue, it</span></span><br><span class="line"><span class="comment">* does not automatically enforce FIFO acquisition policies.  The core</span></span><br><span class="line"><span class="comment">* of exclusive synchronization takes the form:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* Acquire:</span></span><br><span class="line"><span class="comment">*     while (!tryAcquire(arg)) &#123;</span></span><br><span class="line"><span class="comment">*        &lt;em&gt;enqueue thread if it is not already queued&lt;/em&gt;;</span></span><br><span class="line"><span class="comment">*        &lt;em&gt;possibly block current thread&lt;/em&gt;;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Release:</span></span><br><span class="line"><span class="comment">*     if (tryRelease(arg))</span></span><br><span class="line"><span class="comment">*        &lt;em&gt;unblock the first queued thread&lt;/em&gt;;</span></span><br><span class="line"><span class="comment">* &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* (Shared mode is similar but may involve cascading signals.)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p id=&quot;barging&quot;&gt;Because checks in acquire are invoked before</span></span><br><span class="line"><span class="comment">* enqueuing, a newly acquiring thread may &lt;em&gt;barge&lt;/em&gt; ahead of</span></span><br><span class="line"><span class="comment">* others that are blocked and queued.  However, you can, if desired,</span></span><br><span class="line"><span class="comment">* define &#123;<span class="doctag">@code</span> tryAcquire&#125; and/or &#123;<span class="doctag">@code</span> tryAcquireShared&#125; to</span></span><br><span class="line"><span class="comment">* disable barging by internally invoking one or more of the inspection</span></span><br><span class="line"><span class="comment">* methods, thereby providing a &lt;em&gt;fair&lt;/em&gt; FIFO acquisition order.</span></span><br><span class="line"><span class="comment">* In particular, most fair synchronizers can define &#123;<span class="doctag">@code</span> tryAcquire&#125;</span></span><br><span class="line"><span class="comment">* to return &#123;<span class="doctag">@code</span> false&#125; if &#123;<span class="doctag">@link</span> #hasQueuedPredecessors&#125; (a method</span></span><br><span class="line"><span class="comment">* specifically designed to be used by fair synchronizers) returns</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> true&#125;.  Other variations are possible.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Throughput and scalability are generally highest for the</span></span><br><span class="line"><span class="comment">* default barging (also known as &lt;em&gt;greedy&lt;/em&gt;,</span></span><br><span class="line"><span class="comment">* &lt;em&gt;renouncement&lt;/em&gt;, and &lt;em&gt;convoy-avoidance&lt;/em&gt;) strategy.</span></span><br><span class="line"><span class="comment">* While this is not guaranteed to be fair or starvation-free, earlier</span></span><br><span class="line"><span class="comment">* queued threads are allowed to recontend before later queued</span></span><br><span class="line"><span class="comment">* threads, and each recontention has an unbiased chance to succeed</span></span><br><span class="line"><span class="comment">* against incoming threads.  Also, while acquires do not</span></span><br><span class="line"><span class="comment">* &amp;quot;spin&amp;quot; in the usual sense, they may perform multiple</span></span><br><span class="line"><span class="comment">* invocations of &#123;<span class="doctag">@code</span> tryAcquire&#125; interspersed with other</span></span><br><span class="line"><span class="comment">* computations before blocking.  This gives most of the benefits of</span></span><br><span class="line"><span class="comment">* spins when exclusive synchronization is only briefly held, without</span></span><br><span class="line"><span class="comment">* most of the liabilities when it isn&#x27;t. If so desired, you can</span></span><br><span class="line"><span class="comment">* augment this by preceding calls to acquire methods with</span></span><br><span class="line"><span class="comment">* &quot;fast-path&quot; checks, possibly prechecking &#123;<span class="doctag">@link</span> #hasContended&#125;</span></span><br><span class="line"><span class="comment">* and/or &#123;<span class="doctag">@link</span> #hasQueuedThreads&#125; to only do so if the synchronizer</span></span><br><span class="line"><span class="comment">* is likely not to be contended.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This class provides an efficient and scalable basis for</span></span><br><span class="line"><span class="comment">* synchronization in part by specializing its range of use to</span></span><br><span class="line"><span class="comment">* synchronizers that can rely on &#123;<span class="doctag">@code</span> int&#125; state, acquire, and</span></span><br><span class="line"><span class="comment">* release parameters, and an internal FIFO wait queue. When this does</span></span><br><span class="line"><span class="comment">* not suffice, you can build synchronizers from a lower level using</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> java.util.concurrent.atomic atomic&#125; classes, your own custom</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> java.util.Queue&#125; classes, and &#123;<span class="doctag">@link</span> LockSupport&#125; blocking</span></span><br><span class="line"><span class="comment">* support.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;h3&gt;Usage Examples&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Here is a non-reentrant mutual exclusion lock class that uses</span></span><br><span class="line"><span class="comment">* the value zero to represent the unlocked state, and one to</span></span><br><span class="line"><span class="comment">* represent the locked state. While a non-reentrant lock</span></span><br><span class="line"><span class="comment">* does not strictly require recording of the current owner</span></span><br><span class="line"><span class="comment">* thread, this class does so anyway to make usage easier to monitor.</span></span><br><span class="line"><span class="comment">* It also supports conditions and exposes</span></span><br><span class="line"><span class="comment">* one of the instrumentation methods:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* class Mutex implements Lock, java.io.Serializable &#123;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   // Our internal helper class</span></span><br><span class="line"><span class="comment">*   private static class Sync extends AbstractQueuedSynchronizer &#123;</span></span><br><span class="line"><span class="comment">*     // Reports whether in locked state</span></span><br><span class="line"><span class="comment">*     protected boolean isHeldExclusively() &#123;</span></span><br><span class="line"><span class="comment">*       return getState() == 1;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     // Acquires the lock if state is zero</span></span><br><span class="line"><span class="comment">*     public boolean tryAcquire(int acquires) &#123;</span></span><br><span class="line"><span class="comment">*       assert acquires == 1; // Otherwise unused</span></span><br><span class="line"><span class="comment">*       if (compareAndSetState(0, 1)) &#123;</span></span><br><span class="line"><span class="comment">*         setExclusiveOwnerThread(Thread.currentThread());</span></span><br><span class="line"><span class="comment">*         return true;</span></span><br><span class="line"><span class="comment">*       &#125;</span></span><br><span class="line"><span class="comment">*       return false;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     // Releases the lock by setting state to zero</span></span><br><span class="line"><span class="comment">*     protected boolean tryRelease(int releases) &#123;</span></span><br><span class="line"><span class="comment">*       assert releases == 1; // Otherwise unused</span></span><br><span class="line"><span class="comment">*       if (getState() == 0) throw new IllegalMonitorStateException();</span></span><br><span class="line"><span class="comment">*       setExclusiveOwnerThread(null);</span></span><br><span class="line"><span class="comment">*       setState(0);</span></span><br><span class="line"><span class="comment">*       return true;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     // Provides a Condition</span></span><br><span class="line"><span class="comment">*     Condition newCondition() &#123; return new ConditionObject(); &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     // Deserializes properly</span></span><br><span class="line"><span class="comment">*     private void readObject(ObjectInputStream s)</span></span><br><span class="line"><span class="comment">*         throws IOException, ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">*       s.defaultReadObject();</span></span><br><span class="line"><span class="comment">*       setState(0); // reset to unlocked state</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   // The sync object does all the hard work. We just forward to it.</span></span><br><span class="line"><span class="comment">*   private final Sync sync = new Sync();</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   public void lock()                &#123; sync.acquire(1); &#125;</span></span><br><span class="line"><span class="comment">*   public boolean tryLock()          &#123; return sync.tryAcquire(1); &#125;</span></span><br><span class="line"><span class="comment">*   public void unlock()              &#123; sync.release(1); &#125;</span></span><br><span class="line"><span class="comment">*   public Condition newCondition()   &#123; return sync.newCondition(); &#125;</span></span><br><span class="line"><span class="comment">*   public boolean isLocked()         &#123; return sync.isHeldExclusively(); &#125;</span></span><br><span class="line"><span class="comment">*   public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125;</span></span><br><span class="line"><span class="comment">*   public void lockInterruptibly() throws InterruptedException &#123;</span></span><br><span class="line"><span class="comment">*     sync.acquireInterruptibly(1);</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*   public boolean tryLock(long timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment">*       throws InterruptedException &#123;</span></span><br><span class="line"><span class="comment">*     return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Here is a latch class that is like a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> java.util.concurrent.CountDownLatch CountDownLatch&#125;</span></span><br><span class="line"><span class="comment">* except that it only requires a single &#123;<span class="doctag">@code</span> signal&#125; to</span></span><br><span class="line"><span class="comment">* fire. Because a latch is non-exclusive, it uses the &#123;<span class="doctag">@code</span> shared&#125;</span></span><br><span class="line"><span class="comment">* acquire and release methods.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* class BooleanLatch &#123;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   private static class Sync extends AbstractQueuedSynchronizer &#123;</span></span><br><span class="line"><span class="comment">*     boolean isSignalled() &#123; return getState() != 0; &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     protected int tryAcquireShared(int ignore) &#123;</span></span><br><span class="line"><span class="comment">*       return isSignalled() ? 1 : -1;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     protected boolean tryReleaseShared(int ignore) &#123;</span></span><br><span class="line"><span class="comment">*       setState(1);</span></span><br><span class="line"><span class="comment">*       return true;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   private final Sync sync = new Sync();</span></span><br><span class="line"><span class="comment">*   public boolean isSignalled() &#123; return sync.isSignalled(); &#125;</span></span><br><span class="line"><span class="comment">*   public void signal()         &#123; sync.releaseShared(1); &#125;</span></span><br><span class="line"><span class="comment">*   public void await() throws InterruptedException &#123;</span></span><br><span class="line"><span class="comment">*     sync.acquireSharedInterruptibly(1);</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注释介绍的很清楚了。<strong>同步器是用来构建锁和其他同步组件的基础框架</strong>，它的实现<strong>主要依赖一个volatile类型的int成员变量来表示同步状态以及通过一个volatile<code>FIFO</code>队列构成【同步队列】</strong>。它的<strong>子类必须重写<code>AQS</code>的几个<code>protected</code>修饰的用来改变同步状态的方法</strong>，其他方法主要是实现了<strong>排队和阻塞</strong>机制。<strong>状态的更新使用<code>getState,setState</code>以及<code>compareAndSetState</code>这三个方法</strong>。</p>
<p><strong>子类</strong>被<strong>推荐定义为自定义同步组件的静态内部类</strong>，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：<strong>锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作</strong>。锁和同步器很好的隔离了使用者和实现者所需关注的领域。</p>
<p>我们所熟知的<strong>ReentrantLock、CountDownLatch、CyclicBarrier</strong>等同步器，其实都是通过内部类实现了AQS框架暴露的API，以此实现各类同步器功能。这些同步器的主要区别其实就是对同步状态（<strong>synchronization state</strong>）的定义不同。</p>
<p><strong>AQS框架</strong>，分离了构建同步器时的一系列关注点，它的所有操作都围绕着<strong>资源——同步状态（synchronization state）</strong>来展开，并替用户解决了如下问题：</p>
<ol>
<li><u>资源是可以被同时访问？还是在同一时间只能被一个线程访问？（<strong>共享/独占功能</strong>）</u></li>
<li><u>访问资源的线程如何进行并发管理？（<strong>【同步队列】</strong>）</u></li>
<li><u>如果线程等不及资源了，如何从【同步队列】退出？（<strong>超时/中断</strong>）</u></li>
</ol>
<p>这其实是一种典型的<strong>模板方法设计模式</strong>：父类（AQS框架）定义好骨架和内部操作细节，具体规则由子类去实现。<br>AQS框架将剩下的一个问题留给用户：<br><strong>什么是资源？如何定义资源是否可以被访问？</strong></p>
<p>几个常见的同步器对<strong>资源</strong>这一问题的定义：</p>
<table>
<thead>
<tr>
<th>同步器</th>
<th>资源的定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ReentrantLock</strong></td>
<td>资源表示独占锁。State为0表示锁可用；为1表示被占用；为N表示重入的次数</td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>资源表示倒数计数器。State为0表示计数器归零，所有线程都可以访问资源；为N表示计数器未归零，所有线程都需要阻塞。</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>资源表示信号量或者令牌。State≤0表示没有令牌可用，所有线程都需要阻塞；大于0表示由令牌可用，线程每获取一个令牌，State减1，线程没释放一个令牌，State加1。</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>资源表示共享的读锁和独占的写锁。state逻辑上被分成两个16位的unsigned short，分别记录读锁被多少线程使用和写锁被重入的次数。</td>
</tr>
</tbody></table>
<p>综上所述，AQS框架提供了以下功能：</p>
<h2 id="1-提供一套模板框架"><a href="#1-提供一套模板框架" class="headerlink" title="1 提供一套模板框架"></a>1 提供一套模板框架</h2><p>由于并发的存在，需要考虑的情况非常多，因此能否以一种相对简单的方法来完成这两个目标就非常重要，因为对于用户（AQS框架的使用者来说），很多时候并不关心内部复杂的细节。而AQS其实就是利用模板方法模式来实现这一点，AQS中大多数方法都是<strong>final或是private</strong>的，也就是说<strong>Doug Lea并不希望用户直接使用这些方法</strong>，而是只<strong>重写</strong>部分模板规定的方法。<br>AQS通过暴露以下API来让让用户自己解决上面提到的“<strong>如何定义资源是否可以被访问</strong>”的问题：</p>
<table>
<thead>
<tr>
<th>钩子方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tryAcquire</td>
<td>排它获取（资源数），一般是1</td>
</tr>
<tr>
<td>tryRelease</td>
<td>排它释放（资源数），一般是1</td>
</tr>
<tr>
<td>tryAcquireShared</td>
<td>共享获取（资源数）</td>
</tr>
<tr>
<td>tryReleaseShared</td>
<td>共享获取（资源数）</td>
</tr>
<tr>
<td>isHeldExclusively</td>
<td>是否排它状态</td>
</tr>
</tbody></table>
<p><strong>另一方面，同步器给同步组件所提供的模板方法又会重新调用被子类所重写的方法</strong>。举个例子，<code>AQS</code>中需要重写方法<code>tryAcquire</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code>中<code>NonfairSync</code>类（继承Sync，而Sync又继承自<code>AQS</code>）会重写该方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Sync中的nonfairTryAcquire(int acquires)方法如下</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>而<code>AQS</code>中的模板方法<code>acquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;<span class="comment">//调用子类被重写的tryAcquire-&gt;nonfairTryAcquire</span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用<code>tryAcquire</code>方法，而此时当间接继承<code>AQS</code>的<code>NonfairSync</code>调用lock()方法时就会调用模板方法<code>acquire</code>，进一步就会调用已经被<code>NonfairSync</code>重写的<code>tryAcquire</code>方法，这就是使用<code>AQS</code>的方式。可以归纳总结为这么几点：</p>
<ol>
<li>同步组件（这里不仅仅值锁，还包括<code>CountDownLatch</code>等）的实现依赖于同步器<code>AQS</code>，在同步组件实现中，使用<code>AQS</code>的方式被推荐定义<strong>继承AQS的静态内存类</strong>；</li>
<li><code>AQS</code>采用模板方法进行设计，<code>AQS</code>的<code>protected</code>修饰的方法需要由继承<code>AQS</code>的子类进行重写实现，当调用<code>AQS</code>的模板方法时就会调用被重写的方法；</li>
<li><code>AQS</code>负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而<code>Lock</code>等同步组件主要专注于实现同步语义；</li>
<li>在重写<code>AQS</code>的方式时，使用<code>AQS</code>提供的<code>getState(),setState(),compareAndSetState()</code>方法进行修改同步状态</li>
</ol>
<p>  在实现同步组件时AQS提供的<strong>模板方法</strong>如下图：</p>
<p><img src="D:\学习资料\面试题总结\并发编程\AQS模板方法.png" alt="img"></p>
<p>同步组件通过<code>AQS</code>提供的模板方法实现自己的同步语义。<code>AQS</code>提供的模板方法可以分为3类：</p>
<ol>
<li><strong>独占式获取与释放同步状态；</strong></li>
<li><strong>共享式获取与释放同步状态；</strong></li>
<li><strong>查询【同步队列】中等待线程情况；</strong></li>
</ol>
<h2 id="2-AQS核心方法"><a href="#2-AQS核心方法" class="headerlink" title="2 AQS核心方法"></a>2 AQS核心方法</h2><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>CAS，即<code>CompareAndSet</code>，在Java中CAS操作的实现都委托给一个名为UnSafe类，通过该类可以实现对字段的原子操作。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>compareAndSetState</td>
<td>protected final</td>
<td>CAS修改同步状态值</td>
</tr>
<tr>
<td>compareAndSetHead</td>
<td>private final</td>
<td>CAS修改【同步队列】的头指针</td>
</tr>
<tr>
<td>compareAndSetTail</td>
<td>private final</td>
<td>CAS修改【同步队列】的尾指针</td>
</tr>
<tr>
<td>compareAndSetWaitStatus</td>
<td>private static final</td>
<td>CAS修改结点的等待状态</td>
</tr>
<tr>
<td>compareAndSetNext</td>
<td>private static final</td>
<td>CAS修改结点的next指针</td>
</tr>
</tbody></table>
<h3 id="【同步队列】的核心操作"><a href="#【同步队列】的核心操作" class="headerlink" title="【同步队列】的核心操作"></a>【同步队列】的核心操作</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>enq</td>
<td>private</td>
<td>入队操作</td>
</tr>
<tr>
<td>addWaiter</td>
<td>private</td>
<td>入队操作</td>
</tr>
<tr>
<td>setHead</td>
<td>private</td>
<td>设置头结点</td>
</tr>
<tr>
<td>unparkSuccessor</td>
<td>private</td>
<td>唤醒后继结点</td>
</tr>
<tr>
<td>doReleaseShared</td>
<td>private</td>
<td>释放共享结点</td>
</tr>
<tr>
<td>setHeadAndPropagate</td>
<td>private</td>
<td>设置头结点并传播唤醒</td>
</tr>
</tbody></table>
<h3 id="资源的获取操作"><a href="#资源的获取操作" class="headerlink" title="资源的获取操作"></a>资源的获取操作</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cancelAcquire</td>
<td>private</td>
<td>取消获取资源</td>
</tr>
<tr>
<td>shouldParkAfterFailedAcquire</td>
<td>private static</td>
<td>判断是否阻塞当前调用线程</td>
</tr>
<tr>
<td>acquireQueued</td>
<td>final</td>
<td>尝试获取资源,获取失败尝试阻塞线程</td>
</tr>
<tr>
<td>doAcquireInterruptibly</td>
<td>private</td>
<td>独占地获取资源（响应中断）</td>
</tr>
<tr>
<td>doAcquireNanos</td>
<td>private</td>
<td>独占地获取资源（限时等待）</td>
</tr>
<tr>
<td>doAcquireShared</td>
<td>private</td>
<td>共享地获取资源</td>
</tr>
<tr>
<td>doAcquireSharedInterruptibly</td>
<td>private</td>
<td>共享地获取资源（响应中断）</td>
</tr>
<tr>
<td>doAcquireSharedNanos</td>
<td>private</td>
<td>共享地获取资源（限时等待）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>acquire</td>
<td>public final</td>
<td>独占地获取资源</td>
</tr>
<tr>
<td>acquireInterruptibly</td>
<td>public final</td>
<td>独占地获取资源（响应中断）</td>
</tr>
<tr>
<td>acquireInterruptibly</td>
<td>public final</td>
<td>独占地获取资源（限时等待）</td>
</tr>
<tr>
<td>acquireShared</td>
<td>public final</td>
<td>共享地获取资源</td>
</tr>
<tr>
<td>acquireSharedInterruptibly</td>
<td>public final</td>
<td>共享地获取资源（响应中断）</td>
</tr>
<tr>
<td>tryAcquireSharedNanos</td>
<td>public final</td>
<td>共享地获取资源（限时等待）</td>
</tr>
</tbody></table>
<h3 id="资源的释放操作"><a href="#资源的释放操作" class="headerlink" title="资源的释放操作"></a>资源的释放操作</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>release</td>
<td>public final</td>
<td>释放独占资源</td>
</tr>
<tr>
<td>releaseShared</td>
<td>public final</td>
<td>释放共享资源</td>
</tr>
</tbody></table>
<h2 id="3-原理简述"><a href="#3-原理简述" class="headerlink" title="3 原理简述"></a>3 原理简述</h2><p>AQS的所有操作都围绕着<strong>资源——同步状态（synchronization state）</strong>来展开，因此，围绕着资源，衍生出三个基本问题：</p>
<ol>
<li><strong>同步状态（synchronization state）的管理</strong></li>
<li><strong>阻塞/唤醒线程的操作</strong></li>
<li><strong>线程【同步队列】的管理</strong></li>
</ol>
<h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>同步状态，其实就是资源。AQS使用<strong>单个volatile 类型的int（32位）来保存同步状态</strong>，并暴露出<code>getState</code>、<code>setState</code>以及<code>compareAndSetState</code>操作来读取和更新这个状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; instance</span></span><br><span class="line"><span class="comment">     * with initial synchronization state of zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.  同步状态.</span></span><br><span class="line"><span class="comment">     单个volatile 类型的int 来保存同步状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">     * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">     * and write.</span></span><br><span class="line"><span class="comment">     *以原子的方式更新同步状态，利用Unsafe类实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">     *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的阻塞-唤醒"><a href="#线程的阻塞-唤醒" class="headerlink" title="线程的阻塞/唤醒"></a>线程的阻塞/唤醒</h3><p>在JDK1.5之前，除了内置的监视器机制<code>synchronized</code>外，没有其它方法可以安全且便捷得阻塞和唤醒当前线程。<br>JDK1.5以后，<code>java.util.concurrent.locks</code>包提供了<code>LockSupport</code>类来作为线程阻塞和唤醒的工具。<code>LockSupport</code>类，是JUC包中的一个工具类，是用来创建锁和其他同步类的基本线程阻塞原语。（Basic thread blocking primitives for creating locks and other synchronization classes）主要有两类方法：<code>park</code>和<code>unpark</code>：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void park()</td>
<td>阻塞当前线程，如果调用unpark(Thread thread)方法或者当前现场那个被中断，才从park()返回</td>
</tr>
<tr>
<td>void parkNanos(long nanos)</td>
<td>阻塞当前线程，最长不超过nanos秒，返回条件在park()的基础上增加了超时返回</td>
</tr>
<tr>
<td>void parkUntil(long deadline)</td>
<td>阻塞当前线程，知道deadline时间（从1970年开始到deadline时间的毫秒数）</td>
</tr>
<tr>
<td>void unpark(Thread thread)</td>
<td>唤醒处于阻塞状态的线程thread</td>
</tr>
</tbody></table>
<h3 id="【同步队列】"><a href="#【同步队列】" class="headerlink" title="【同步队列】"></a>【同步队列】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Wait queue node class.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span></span><br><span class="line"><span class="comment">    * Hagersten) lock queue. CLH locks are normally used for</span></span><br><span class="line"><span class="comment">    * spinlocks.  We instead use them for blocking synchronizers, but</span></span><br><span class="line"><span class="comment">    * use the same basic tactic of holding some of the control</span></span><br><span class="line"><span class="comment">    * information about a thread in the predecessor of its node.  A</span></span><br><span class="line"><span class="comment">    * &quot;status&quot; field in each node keeps track of whether a thread</span></span><br><span class="line"><span class="comment">    * should block.  A node is signalled when its predecessor</span></span><br><span class="line"><span class="comment">    * releases.  Each node of the queue otherwise serves as a</span></span><br><span class="line"><span class="comment">    * specific-notification-style monitor holding a single waiting</span></span><br><span class="line"><span class="comment">    * thread. The status field does NOT control whether threads are</span></span><br><span class="line"><span class="comment">    * granted locks etc though.  A thread may try to acquire if it is</span></span><br><span class="line"><span class="comment">    * first in the queue. But being first does not guarantee success;</span></span><br><span class="line"><span class="comment">    * it only gives the right to contend.  So the currently released</span></span><br><span class="line"><span class="comment">    * contender thread may need to rewait.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span></span><br><span class="line"><span class="comment">    * tail. To dequeue, you just set the head field.</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">    *      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">    * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">    *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Insertion into a CLH queue requires only a single atomic</span></span><br><span class="line"><span class="comment">    * operation on &quot;tail&quot;, so there is a simple atomic point of</span></span><br><span class="line"><span class="comment">    * demarcation from unqueued to queued. Similarly, dequeuing</span></span><br><span class="line"><span class="comment">    * involves only updating the &quot;head&quot;. However, it takes a bit</span></span><br><span class="line"><span class="comment">    * more work for nodes to determine who their successors are,</span></span><br><span class="line"><span class="comment">    * in part to deal with possible cancellation due to timeouts</span></span><br><span class="line"><span class="comment">    * and interrupts.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly</span></span><br><span class="line"><span class="comment">    * needed to handle cancellation. If a node is cancelled, its</span></span><br><span class="line"><span class="comment">    * successor is (normally) relinked to a non-cancelled</span></span><br><span class="line"><span class="comment">    * predecessor. For explanation of similar mechanics in the case</span></span><br><span class="line"><span class="comment">    * of spin locks, see the papers by Scott and Scherer at</span></span><br><span class="line"><span class="comment">    * http://www.cs.rochester.edu/u/scott/synchronization/</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.</span></span><br><span class="line"><span class="comment">    * The thread id for each node is kept in its own node, so a</span></span><br><span class="line"><span class="comment">    * predecessor signals the next node to wake up by traversing</span></span><br><span class="line"><span class="comment">    * next link to determine which thread it is.  Determination of</span></span><br><span class="line"><span class="comment">    * successor must avoid races with newly queued nodes to set</span></span><br><span class="line"><span class="comment">    * the &quot;next&quot; fields of their predecessors.  This is solved</span></span><br><span class="line"><span class="comment">    * when necessary by checking backwards from the atomically</span></span><br><span class="line"><span class="comment">    * updated &quot;tail&quot; when a node&#x27;s successor appears to be null.</span></span><br><span class="line"><span class="comment">    * (Or, said differently, the next-links are an optimization</span></span><br><span class="line"><span class="comment">    * so that we don&#x27;t usually need a backward scan.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Cancellation introduces some conservatism to the basic</span></span><br><span class="line"><span class="comment">    * algorithms.  Since we must poll for cancellation of other</span></span><br><span class="line"><span class="comment">    * nodes, we can miss noticing whether a cancelled node is</span></span><br><span class="line"><span class="comment">    * ahead or behind us. This is dealt with by always unparking</span></span><br><span class="line"><span class="comment">    * successors upon cancellation, allowing them to stabilize on</span></span><br><span class="line"><span class="comment">    * a new predecessor, unless we can identify an uncancelled</span></span><br><span class="line"><span class="comment">    * predecessor who will carry this responsibility.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;CLH queues need a dummy header node to get started. But</span></span><br><span class="line"><span class="comment">    * we don&#x27;t create them on construction, because it would be wasted</span></span><br><span class="line"><span class="comment">    * effort if there is never contention. Instead, the node</span></span><br><span class="line"><span class="comment">    * is constructed and head and tail pointers are set upon first</span></span><br><span class="line"><span class="comment">    * contention.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Threads waiting on Conditions use the same nodes, but</span></span><br><span class="line"><span class="comment">    * use an additional link. Conditions only need to link nodes</span></span><br><span class="line"><span class="comment">    * in simple (non-concurrent) linked queues because they are</span></span><br><span class="line"><span class="comment">    * only accessed when exclusively held.  Upon await, a node is</span></span><br><span class="line"><span class="comment">    * inserted into a condition queue.  Upon signal, the node is</span></span><br><span class="line"><span class="comment">    * transferred to the main queue.  A special value of status</span></span><br><span class="line"><span class="comment">    * field is used to mark which queue a node is on.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span></span><br><span class="line"><span class="comment">    * Scherer and Michael Scott, along with members of JSR-166</span></span><br><span class="line"><span class="comment">    * expert group, for helpful ideas, discussions, and critiques</span></span><br><span class="line"><span class="comment">    * on the design of this class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">       <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">       <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">        * unconditionally propagate</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">        *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">        *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">        *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">        *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">        *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">        *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">        *               on failure, block.</span></span><br><span class="line"><span class="comment">        *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">        *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">        *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">        *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">        *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">        *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">        *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">        *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">        *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">        *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">        *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">        *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">        *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">        *               since intervened.</span></span><br><span class="line"><span class="comment">        *   0:          None of the above</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">        * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">        * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">        * values, just for sign.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">        * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">        * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">        * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">        * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">        * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">        * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">        * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">        * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">        * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">        * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">        * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">        * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">        * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">        * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">        * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">        * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">        * to be null, we can scan prev&#x27;s from the tail to</span></span><br><span class="line"><span class="comment">        * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">        * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">        * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">        * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">        * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">        * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">        * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">        * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">        * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">        * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">        * mode.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Node nextWaiter;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">        * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">        * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">           Node p = prev;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">           <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">           <span class="keyword">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">           <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">           <span class="keyword">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>【同步队列】，是AQS框架的核心，整个框架的关键其实就是如何在并发状态下管理被阻塞的线程。注释介绍的很清楚了。【同步队列】是严格的FIFO队列，是<strong>Craig，Landin和Hagersten锁（CLH锁）</strong>的一种变种，采用双向链表实现，因此也叫CLH队列。CLH队列中的结点是对线程的包装，结点一共有两种类型：<strong>独占（EXCLUSIVE）和共享（SHARED）</strong>。每种类型的结点都有一些状态，其中<strong>独占</strong>结点使用其中的CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)，<strong>共享</strong>结点使用其中的CANCELLED(1)、SIGNAL(-1)、PROPAGATE(-3)。<strong>默认</strong>状态是INITIAL（0）</p>
<table>
<thead>
<tr>
<th>结点状态</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CANCELLED</td>
<td>1</td>
<td>当前节点中的线程由于在【同步队列】中等待超时或者被中断，需要从【同步队列】取消等待（移出队列），节点进入该状态将不会变化</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>-1</td>
<td>当前节点的后续节点next中的线程处于阻塞状态（blocked via park），因此当前节点的线程如果释放了同步状态或者被取消必须要unpark它的后续节点，使后续节点能够继续运行。（当前结点在<strong>入队后、阻塞前</strong>，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。）</td>
</tr>
<tr>
<td>CONDITION</td>
<td>-2</td>
<td>表示当前结点在Condition队列中，当其他线程对Condition调用了signal（）方法后，该节点将会从【同步队列】转移到【同步队列】中，加入到对同步状态的获取中</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>-3</td>
<td>适用于共享模式，表示下一次共享式同步状态获取将会无条件地被传播下去（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。）</td>
</tr>
<tr>
<td>INITIAL</td>
<td>0</td>
<td>默认。新结点会处于这种状态</td>
</tr>
</tbody></table>
<p>对于CLH队列，当线程请求资源时，如果请求不到，会将线程包装成结点，将其挂载在队列尾部。<br><strong>CLH队列的示意图如下：</strong></p>
<p><img src="C:\Users\Administrator\Desktop\面试题总结\并发编程\AQS_CLH.png"></p>
<p>①初始状态，队列<code>head</code>和<code>tail</code>都指向空</p>
<p><img src="https://segmentfault.com/img/bVbetIi?w=168&h=166" alt="clipboard.png"></p>
<p>②首个线程入队，先创建一个空的头结点（dummy节点，thread为null，不关联任何thread），然后以自旋的方式不断尝试插入一个包含当前线程的新结点</p>
<p><img src="https://segmentfault.com/img/bVbetIk?w=192&h=263" alt="clipboard.png"></p>
<p><img src="https://segmentfault.com/img/bVbetIm?w=523&h=302" alt="clipboard.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以自旋的方式不断尝试插入结点至队列尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前结点的前驱结点pre</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//2</span></span><br><span class="line">                t.next = node;<span class="comment">//3</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-注释中的Mutex例子"><a href="#4-注释中的Mutex例子" class="headerlink" title="4 注释中的Mutex例子"></a>4 注释中的Mutex例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Our internal helper class</span></span><br><span class="line">    <span class="comment">// 继承AQS的静态内存类</span></span><br><span class="line">    <span class="comment">// 重写方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Reports whether in locked state</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Provides a Condition</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserializes properly</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="comment">//使用同步器的模板方法实现自己的同步语义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、ReentrantLock"><a href="#四、ReentrantLock" class="headerlink" title="四、ReentrantLock"></a>四、ReentrantLock</h1><p><code>ReentrantLock</code>实现了接口<code>Lock</code>，基本上所有方法的实现实际上都是调用了其静态内存类<code>Sync</code>中的方法，而<code>Sync</code>类继承了<code>AbstractQueuedSynchronizer（AQS）</code>。<code>Sync</code>又有两个子类<code>NonfairSync</code>和<code>FairSync</code>，实现不同的公平策略。看一下<code>ReentrantLock</code>的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">            <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">     * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;<span class="comment">//默认构造的是非公平锁</span></span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;<span class="comment">//可根据要求构建公平或者非公平锁</span></span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步器是实现锁的关键，在锁的实现中聚合同步器，<strong>利用同步器实现锁的语义</strong>。可以这样理解二者的关系：<strong>锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作</strong>。锁和同步器很好的隔离了使用者和实现者所需关注的领域。</p>
<h2 id="ReentrantLock的公平策略原理"><a href="#ReentrantLock的公平策略原理" class="headerlink" title="ReentrantLock的公平策略原理"></a>ReentrantLock的公平策略原理</h2><p>对<code>ReentrantLock</code>公平策略的分析基于以下示例：</p>
<blockquote>
<p>假设现在有3个线程：ThreadA、ThreadB、ThreadC，一个<strong>公平的独占锁</strong>，3个线程会依次尝试去获取锁：<code>ReentrantLock lock=new ReentrantLock(true);</code></p>
</blockquote>
<p>线程的操作时序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadA    lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadB    lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadC    lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadA    release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadB    release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadC    release</span></span><br></pre></td></tr></table></figure>

<h3 id="1-ThreadA首先获取到锁"><a href="#1-ThreadA首先获取到锁" class="headerlink" title="1 ThreadA首先获取到锁"></a>1 ThreadA首先获取到锁</h3><p>ThreadA首先调用<code>ReentrantLock</code>的<code>lock()</code>方法，我们看下该方法的内部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires the lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires the lock if it is not held by another thread and returns</span></span><br><span class="line"><span class="comment"> * immediately, setting the lock hold count to one.</span></span><br><span class="line"><span class="comment"> *  ######################## 注释仔细看就不翻译了 ########################</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread already holds the lock then the hold</span></span><br><span class="line"><span class="comment"> * count is incremented by one and the method returns immediately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the lock is held by another thread then the</span></span><br><span class="line"><span class="comment"> * current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment"> * purposes and lies dormant until the lock has been acquired,</span></span><br><span class="line"><span class="comment"> * at which time the lock hold count is set to one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中最终其实调用了<code>FairSync</code>的<code>lock()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">//AQS模板方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;<span class="comment">//子类重写AQS方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**重点来了！！！！！！！！<code>acquire()</code>**方法来自<code>AQS</code>的模板方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>tryAcquire()</code>方法需要AQS的子类FairSync自己去实现，我们来看下<code>ReentrantLock</code>中<code>FairSync</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     	获取成功返回true，失败false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;<span class="comment">//入参为acquires==1</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//当前线程</span></span><br><span class="line">        <span class="comment">//获取同步状态，AQS的方法，因为同步状态state是AQS维护的（private volatile int state;）</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//锁未被占用</span></span><br><span class="line">            <span class="comment">//如果【同步队列】中当前线程前没有其他线程等待，则以CAS方式更新同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">//更新成功，设置当前线程独占</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否属于重入的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//属于重入</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//重入时，同步状态+1</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)<span class="comment">//重入次数过多，溢出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>稍微看下<code>hasQueuedPredecessors()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Queries whether any threads have been waiting to acquire longer</span></span><br><span class="line"><span class="comment">    * than the current thread.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;An invocation of this method is equivalent to (but may be</span></span><br><span class="line"><span class="comment">    * more efficient than):</span></span><br><span class="line"><span class="comment">    *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * getFirstQueuedThread() != Thread.currentThread() &amp;&amp;</span></span><br><span class="line"><span class="comment">    * hasQueuedThreads()&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that because cancellations due to interrupts and</span></span><br><span class="line"><span class="comment">    * timeouts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not</span></span><br><span class="line"><span class="comment">    * guarantee that some other thread will acquire before the current</span></span><br><span class="line"><span class="comment">    * thread.  Likewise, it is possible for another thread to win a</span></span><br><span class="line"><span class="comment">    * race to enqueue after this method has returned &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment">    * due to the queue being empty.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method is designed to be used by a fair synchronizer to</span></span><br><span class="line"><span class="comment">    * avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">    * Such a synchronizer&#x27;s &#123;<span class="doctag">@link</span> #tryAcquire&#125; method should return</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125;, and its &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; method should</span></span><br><span class="line"><span class="comment">    * return a negative value, if this method returns &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * (unless this is a reentrant acquire).  For example, the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * tryAcquire&#125; method for a fair, reentrant, exclusive mode</span></span><br><span class="line"><span class="comment">    * synchronizer might look like this:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">    *   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment">    *     // A reentrant acquire; increment hold count</span></span><br><span class="line"><span class="comment">    *     return true;</span></span><br><span class="line"><span class="comment">    *   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment">    *     return false;</span></span><br><span class="line"><span class="comment">    *   &#125; else &#123;</span></span><br><span class="line"><span class="comment">    *     // try to acquire normally</span></span><br><span class="line"><span class="comment">    *   &#125;</span></span><br><span class="line"><span class="comment">    * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment">    *         current thread, and &#123;<span class="doctag">@code</span> false&#125; if the current thread</span></span><br><span class="line"><span class="comment">    *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">       <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">       <span class="comment">// thread is first in queue.</span></span><br><span class="line">       Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">       Node h = head;</span><br><span class="line">       Node s;</span><br><span class="line">       <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">//h.next == null：考虑enq时先建立一个dummy节点的操作</span></span><br><span class="line">           ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**An invocation of this method is equivalent to (but may be</span></span><br><span class="line"><span class="comment">    * more efficient than):效率上边的方式更高</span></span><br><span class="line"><span class="comment">    * getFirstQueuedThread() != Thread.currentThread() &amp;&amp; hasQueuedThreads()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> head != tail;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Thread <span class="title">getFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// handle only fast path, else relay</span></span><br><span class="line">       <span class="keyword">return</span> (head == tail) ? <span class="keyword">null</span> : fullGetFirstQueuedThread();<span class="comment">//不往下看了，比较好理解</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，在<code>ReentrantLock</code>中，同步状态<code>State</code>的含义如下：</p>
<table>
<thead>
<tr>
<th>State</th>
<th>资源的定义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>表示锁可用</td>
</tr>
<tr>
<td>1</td>
<td>表示锁被占用</td>
</tr>
<tr>
<td>大于1</td>
<td>表示锁被占用，且值表示同一线程的重入次数</td>
</tr>
</tbody></table>
<p><strong>ThreadA是首个获取锁的线程，所以上述方法会返回true，ThreadA就可以继续执行自己的程序了，第一阶段结束。（ThreadA一直保持占有锁，AQS的同步状态是1）</strong></p>
<p>此时，AQS中的【同步队列】还是空：</p>
<p><img src="https://segmentfault.com/img/bVbetLZ?w=120&h=176" alt="img"></p>
<h3 id="2-ThreadB开始获取锁"><a href="#2-ThreadB开始获取锁" class="headerlink" title="2 ThreadB开始获取锁"></a>2 ThreadB开始获取锁</h3><p>一样，ThreadB先去调用<code>lock()</code>方法，最终调用AQS的<code>acquire()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="comment">//获取失败则将当前线程包装成独占EXCLUSIVE节点后加入【同步队列】</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryAcquire()</code>方法肯定是返回false。因为此时ThreadA占有着锁，<code>c = getState()</code>为1，并且<code>Thread.currentThread()！=getExclusiveOwnerThread()</code>（当前是B线程，独占的是A线程）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;<span class="comment">//入参为acquires==1</span></span><br><span class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//当前线程</span></span><br><span class="line">          <span class="comment">//获取同步状态，AQS的方法，因为同步状态state是AQS维护的（private volatile int state;）</span></span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//锁未被占用</span></span><br><span class="line">              <span class="comment">//如果【同步队列】中当前线程前没有其他线程等待，则以CAS方式更新同步状态</span></span><br><span class="line">              <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  <span class="comment">//更新成功，设置当前线程独占</span></span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//判断是否属于重入的情况</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//属于重入</span></span><br><span class="line">              <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//重入时，同步状态+1</span></span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)<span class="comment">//重入次数过多，溢出</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>接下来看下<code>addWaiter()</code>方法，这个方法其实就是将当前调用线程B包装成一个【<code>EXCLUSIVE</code>独占结点】，添加到【同步队列】尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Creates node for current thread and given mode</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;<span class="comment">//双向链表一个方向</span></span><br><span class="line">        <span class="comment">//先尝试一次添加到尾部，如果添加成功，就不用再enq(算是一个小优化吧)</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//并发情况CAS</span></span><br><span class="line">            pred.next = node;<span class="comment">//双向链表另一个方向</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ############### tail为空说明当前线程是第一个加入【同步队列】进行等待的线程 ###############</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键是<code>enq()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">               <span class="comment">//如果尾结点为空，说明当前线程是第一个加入【同步队列】进行等待的线程</span></span><br><span class="line">               <span class="comment">//此时必须初始化：本来tail和head都是null--&gt;&gt;二者都指向同一个dummy Node</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;<span class="comment">//1  双向链表的第一个方向</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//2</span></span><br><span class="line">                   t.next = node;<span class="comment">//3  双向链表的第二个方向</span></span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>因为<strong>并发插入</strong>的情况存在，所以该方法设计成了自旋操作，<strong>将并发添加节点的操作通过CAS之<code>compareAndSetTail()</code>串行化了</strong>，保证结点能成功插入，具体步骤如下：<br><strong>①当队列为空的时候，先创建一个dummy头结点；</strong></p>
<p><img src="https://segmentfault.com/img/bVbetL7?w=352&h=369" alt="img"></p>
<p>②进入下一次循环，插入队尾结点。</p>
<p><img src="https://segmentfault.com/img/bVbetL9?w=680&h=392" alt="img"></p>
<p>ThreadB已经被包装成结点插入队尾了，接下来会调用<code>acquireQueued()</code>方法，这也是<strong>AQS中最重要的方法之一</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//该节点死循环审视自己尝试获得同步状态，可以想象每个节点都是如此在自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//pre</span></span><br><span class="line">            <span class="comment">// 如果上一个节点是 head ，就尝试获取锁</span></span><br><span class="line">        	<span class="comment">// 如果 获取成功，就将当前节点设置为 head，注意 head 节点是永远不会唤醒的。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//注意：此时首节点已经获取到同步状态了</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//将自己设置为 head，断开和 next 的连接。以便p被GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">//经过一番操作，head节点此时还是相当于一个dummy节点（此时原来的首节点获得锁了，并且在setHead(node);和p.next = null;操作之后原来的首节点不存储线程信息了，被改成了dummy）</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在获取锁失败后，就需要阻塞了。</span></span><br><span class="line">       		<span class="comment">// shouldParkAfterFailedAcquire ---&gt; 检查上一个节点的状态，如果是 SIGNAL 就阻塞，否则就改成 SIGNAL。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)<span class="comment">//正常来说，难道会发生什么意外吗？？？</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;<span class="comment">//################## 注意 ##################</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AQS中，【同步队列】中的线程都是阻塞的，当前线程（可以想象每个线程都在自旋）在自省地尝试获取同步状态。当某个线程被唤醒时，只有该线程是首结点（线程）时（<strong>我们称head是头结点，它是一个dummy节点。head是永远不会被唤醒的</strong>），才有权去尝试获取锁 <code>if (p == head &amp;&amp; tryAcquire(arg))</code> 。</p>
<p>上述方法中，将ThreadB包装成结点插入队尾后，先判断ThreadB是否是首结点（<strong>注意不是头结点，头结点是个dummy结点</strong>），发现确实是首结点（<code>node.predecessor==head</code>），于是调用<code>tryAcquire()</code>尝试获取锁，但是获取失败了（此时ThreadA占有着锁），就要<strong>判断是否需要阻塞当前线程</strong>。</p>
<p>判断是否需要阻塞线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//前驱节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//这个状态说明当前节点的前驱结点将来会唤醒我，我可以安心的被阻塞</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// ##################### I should PARK! #####################</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//CANCELED：当前节点的前驱结点因意外被取消或者中断，需要将其从【同步队列】中移除</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;<span class="comment">//// 将前任的前任 赋值给 当前的前任</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node; <span class="comment">// 将前任的前任的 next 赋值为 当前节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 如果没有取消 || 0 || CONDITION || PROPAGATE，那么就将前任的 ws 设置成 SIGNAL.</span></span><br><span class="line">        <span class="comment">//挂起自己之前，需要将前置节点的 ws 状态设置成 SIGNAL，告诉前任：你释放锁的时候记得唤醒我，让我好尝试获得锁。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时，当前线程还不应该被挂起，重来acquireQueued里的自旋</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于在【同步队列】中的线程，如果要阻塞它，需要确保将来有线程可以唤醒它，AQS中通过将前驱结点的状态置为SIGNAL:-1来表示将来会唤醒当前线程，当前线程可以安心的阻塞。</strong></p>
<p><strong>如何阻塞当前线程呢：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//####### 会一直阻塞在这里，当当前线程被LockSupport.park(thread)的时候才从这里返回 #######</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，【同步队列】的状态如下：</p>
<p>①插入完ThreadB后，队列的初始状态如下：</p>
<p><img src="https://segmentfault.com/img/bVbetM7?w=427&h=271" alt="clipboard.png"></p>
<p>②虽然ThreadB是队首结点，但是它拿不到锁（被ThreadA占有着），所以<strong>ThreadB会阻塞</strong>，但在阻塞前需要设置下前驱的状态，以便将来可以唤醒我：</p>
<p><img src="https://segmentfault.com/img/bVbetM3?w=427&h=271" alt="clipboard.png"></p>
<p>至此，ThreadB的执行也暂告一段落了（安心得在【同步队列】中睡觉）。</p>
<blockquote>
<p>注意：在<code>acquireQueued</code>方法中，如果ThreadB在阻塞过程中被中断，其实是不会抛出异常的，只会在<code>acquireQueued()</code>方法返回时，告诉调用者在阻塞期间有没被中断过，具体如果处理，要不要抛出异常，取决于调用者，这其实是一种<strong>延时中断机制</strong>。</p>
</blockquote>
<h3 id="3-dummy节点"><a href="#3-dummy节点" class="headerlink" title="3 dummy节点"></a>3 dummy节点</h3><p>为什么要创建一个虚拟节点呢？</p>
<p>事情要从 <code>Node</code> 类的 <code>waitStatus</code> 变量说起，简称 ws。每个节点都有一个 ws 变量，用于这个节点状态的一些标志。初始状态是 0。如果被取消了，节点就是 CANCELED （1），那么他就会被 AQS 清理。还有一个重要的状态：SIGNAL（-1），表示：当当前节点释放锁的时候，需要唤醒下一个节点。</p>
<p>所以，每个节点在休眠前，都需要将前置节点的 ws 设置成 SIGNAL。<strong>否则自己永远无法被唤醒</strong>。每个节点都必须设置前置节点的 ws 状态为 SIGNAL，所以必须要一个前置节点，而这个前置节点，实际上就是当前持有锁的节点。</p>
<p>问题在于有个边界问题：<strong>第一个节点怎么办？</strong>他是没有前置节点的。</p>
<blockquote>
<p>那就创建一个假的。</p>
</blockquote>
<p>总结下来就是：<strong>每个节点都需要设置前置节点的 ws 状态（这个状态为是为了保证数据一致性），而第一个节点是没有前置节点的，所以需要创建一个虚拟节点</strong>。</p>
<h3 id="4-独占式锁的获取图解"><a href="#4-独占式锁的获取图解" class="headerlink" title="4 独占式锁的获取图解"></a>4 独占式锁的获取图解</h3><p>独占式锁的获取过程也就是<code>acquire()</code>方法的执行流程如下图所示</p>
<img src="C:\Users\Administrator\Desktop\面试题总结\并发编程\EXCLUSIVE_acquire.png" alt="EXCLUSIVE_acquire" style="zoom:67%;" />

<h3 id="5-ThreadC开始获取锁"><a href="#5-ThreadC开始获取锁" class="headerlink" title="5 ThreadC开始获取锁"></a>5 ThreadC开始获取锁</h3><p>ThreadC的调用过程和ThreadB完全一样，同样拿不到锁，然后加入到【同步队列】队尾：</p>
<p><img src="https://segmentfault.com/img/bVbetNf?w=686&h=267" alt="img"></p>
<p>然后，ThreadC在阻塞前需要把前驱结点的状态置为SIGNAL：-1，以确保将来可以被唤醒：</p>
<p><img src="https://segmentfault.com/img/bVbetNh?w=686&h=267" alt="img"></p>
<p>至此，ThreadC的执行也暂告一段落了（安心得在【同步队列】中阻塞）。</p>
<h3 id="6-ThreadA释放锁"><a href="#6-ThreadA释放锁" class="headerlink" title="6 ThreadA释放锁"></a>6 ThreadA释放锁</h3><p>ThreadA终于使用完了临界资源，要释放锁了，来看下<code>ReentrantLock</code>的<code>unlock()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock.unlock()</code>内部调用了AQS的模板方法<code>release()</code>方法，传参1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;<span class="comment">//传参 1</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//尝试释放锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 所有的节点在将自己挂起之前，都会将前置节点设置成 SIGNAL，希望前置节点释放的时候，唤醒自己。 如果前置节点是 0 ，说明前置节点已经释放过了。不能重复释放了，后面将会看到释放后会将 ws 修改成0.</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//释放成功，则唤醒首节点（头结点的后继节点）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试释放锁的操作<code>tryRelease()</code>是由AQS的子类<code>Sync</code>重写的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;<span class="comment">//传参 1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;<span class="comment">//同步状态-1</span></span><br><span class="line">    <span class="comment">//持有锁和释放锁的线程必须是同一个，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果释放后没有线程占用了，就释放成功</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//清楚占有线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);<span class="comment">//更新状态</span></span><br><span class="line">    <span class="keyword">return</span> free;<span class="comment">//返回释放结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边<code>release()</code>和<code>tryRelease()</code>两个方法的逻辑可以看出，<code>release()</code>过程中head 必须不等于 0。为什么呢？当一个节点尝试挂起自己之前，都会将前置节点设置成 SIGNAL -1，就算是第一个加入队列的节点，在获取锁失败后，也会将虚拟节点设置的 ws 设置成 SIGNAL。这个判断也是防止并发下重复释放。</p>
<p>那么肯定，在释放锁之后，肯定会将 ws 状态设置成 0，防止重复操作。释放成功后，调用<code>AQS.unparkSuccessor()</code>方法，唤醒队列中的首结点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//SIGNAL:-1</span></span><br><span class="line">        <span class="comment">//理解1 预置当前节点状态为0，表示后继节点即将被唤醒</span></span><br><span class="line">        <span class="comment">//理解2 将首节点的 ws 改成 0，清除信号。表示已经释放过了。不能重复释放。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;<span class="comment">//当前节点的后继节点</span></span><br><span class="line">    <span class="comment">//如果后继节点处于CANCELD状态（说明被取消了）或者null，会从队尾开始向前找到最后一个未被CANCELED的节点（也就是从前往后第一个未被CANCELED的节点）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从tail开始向前找是为了考虑并发入队enq的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常情况下会直接唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//阻塞在parkAndCheckInterrupt() &#123; LockSupport.park(this);...&#125;处的对应线程被唤醒</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbetNz?w=686&h=263" alt="img"></p>
<h3 id="7-ThreadB唤醒后继续执行"><a href="#7-ThreadB唤醒后继续执行" class="headerlink" title="7 ThreadB唤醒后继续执行"></a>7 ThreadB唤醒后继续执行</h3><p>好了，队首结点（ThreadB）被唤醒了。ThreadB会继续从以下位置开始执行，先返回一个中断标识，用于表示ThreadB在<strong>阻塞期间有没被中断过</strong>(<strong>延时中断</strong>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后ThreadB又开始了自旋操作，被唤醒的是队首结点，所以可以尝试<code>tryAcquire()</code>获取锁，此时获取成功（ThreadA已经释放了锁）。获取成功后会调用setHead方法，将头结点置为当前结点，并清除线程信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//该节点死循环审视自己尝试获得同步状态，可以想象每个节点都是如此在自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//pre</span></span><br><span class="line">            <span class="comment">// 如果上一个节点是 head ，就尝试获取锁</span></span><br><span class="line">        	<span class="comment">// 如果 获取成功，就将当前节点设置为 head，注意 head 节点是永远不会唤醒的。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//注意：此时首节点已经获取到同步状态了</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//将自己设置为 head，断开和 next 的连接。以便p被GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">//经过一番操作，head节点此时还是相当于一个dummy节点（此时原来的首节点获得锁了，并且在setHead(node);和p.next = null;操作之后原来的首节点不存储线程信息了，被改成了dummy）</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在获取锁失败后，就需要阻塞了。</span></span><br><span class="line">       		<span class="comment">// shouldParkAfterFailedAcquire ---&gt; 检查上一个节点的状态，如果是 SIGNAL 就阻塞，否则就改成 SIGNAL。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;<span class="comment">//################## 注意 ##################</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbetNR?w=427&h=263" alt="img"></p>
<h3 id="8-ThreadB释放锁"><a href="#8-ThreadB释放锁" class="headerlink" title="8 ThreadB释放锁"></a>8 ThreadB释放锁</h3><p>ThreadB也终于使用完了临界资源，要释放锁了，过程和ThreadA释放时一样，释放成功后，会调用**<code>unparkSuccessor()</code>**方法，唤醒队列中的首结点：</p>
<p><img src="https://segmentfault.com/img/bVbetNZ?w=427&h=263" alt="img"></p>
<p>队首结点（ThreadC）被唤醒后，继续从原来的阻塞处向下执行，并尝试获取锁，获取成功，最终队列状态如下：</p>
<p><img src="https://segmentfault.com/img/bVbetN7?w=167&h=255" alt="img"></p>
<h3 id="9-ThreadC释放锁"><a href="#9-ThreadC释放锁" class="headerlink" title="9 ThreadC释放锁"></a>9 ThreadC释放锁</h3><p>ThreadC也终于使用完了临界资源，要释放锁了。释放成功后，调用unparkSuccessor方法，唤醒队列中的首结点：此时队列中只剩下一个头结点（dummy），所以<strong>这个<code>unparkSuccessor()</code>方法其实什么都不做</strong>。最终队列的状态就是只有一个dummy头结点。</p>
<h2 id="ReentrantLock的非公平策略原理"><a href="#ReentrantLock的非公平策略原理" class="headerlink" title="ReentrantLock的非公平策略原理"></a>ReentrantLock的非公平策略原理</h2><p><code>ReenrantLock</code>非公平策略的内部实现和公平策略没啥太大区别，非公平策略和公平策略的最主要区别在于：</p>
<p><strong>公平锁获取锁时</strong>，会<strong>判断【同步队列】中是否有线程排在当前线程前面</strong>。只有没有情况下，才去获取锁，这是公平的含义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">      * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<span class="comment">//判断【同步队列】中是否有线程排在当前线程前面</span></span><br><span class="line">                 compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                 setExclusiveOwnerThread(current);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">             <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">             <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">             setState(nextc);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>非公平锁获取锁时</strong>，会立即尝试修改同步状态，失败后再调用AQS的<code>acquire()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//公平和非公平策略获取锁的tryAcquire逻辑，只有这一个判断是不一样的</span></span><br><span class="line">        <span class="comment">//非公平锁少了“队列中是否有其它线程排在当前线程前”这一判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h1 id="五、AQS对中断的支持"><a href="#五、AQS对中断的支持" class="headerlink" title="五、AQS对中断的支持"></a>五、AQS对中断的支持</h1><p>以<code>ReentrantLock</code>为例，来看下AQS是如何实现锁中断和超时的。<code>ReentrantLock</code>的<code>lockInterruptibly()</code>方法是会响应中断的。（线程如果在阻塞过程中被中断，会抛出<code>InterruptedException</code>异常）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//当前线程中断标志位true 直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))<span class="comment">//尝试获取锁</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会先去尝试获取锁，如果失败，则调用<code>doAcquireInterruptibly()</code>方法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很眼熟有木有？看下和acquireQueued()方法的对比，唯一的区别就是：当调用线程获取锁失败，进入阻塞后，如果中途被中断，<code>acquireQueued()</code>只是用一个标识记录线程被中断过，而<code>doAcquireInterruptibly()</code>则是直接抛出异常(延时中断机制)。</p>
<h1 id="六、AQS对限时等待的支持"><a href="#六、AQS对限时等待的支持" class="headerlink" title="六、AQS对限时等待的支持"></a>六、AQS对限时等待的支持</h1><p>Lock接口中有一个方法：<code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</code>，用于在指定的时间内尝试获取锁，获取不到就返回。<code>ReentrantLock</code>实现了该方法，可以看到，该方法内部调用了AQS的<strong>tryAcquireNanos</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryAcquireNanos()</code>方法是响应中断的，先尝试获取一次锁，失败则调用<code>doAcquireNanos()</code>方法进行超时等待。<code>doAcquireNano()</code>方法很关键，和<code>acquireQuqued()</code>方法类似，又是一个自旋操作，在超时前不断尝试获取锁，获取不到则阻塞（加上了等待时间的判断）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive timed mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//截止等待时间点=当前时间+timeout</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="comment">//将线程加入【同步队列】</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标识在等待时间内是否获取到锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//如果当前节点到了首节点了，可以立即尝试获取锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)<span class="comment">//超过了截止等待时间点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)<span class="comment">//剩余等待时间时间超过阈值（默认1000ns）</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);<span class="comment">//阻塞线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);<span class="comment">//等待时间内依旧没有获取到所，则取消获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行逻辑如下（没有考虑 <code>cancelAcquire(node)</code>）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-172c7b895b5e9ad5?imageMogr2/auto-orient/strip%7CimageView2/2/w/704/format/webp" alt="img"></p>
<p>该方法内部，调用了<code>LockSupport.parkNanos</code>来超时阻塞线程，<code>LockSupport.parkNanos</code>内部其实通过Unsafe这个类来操作线程的阻塞，底层是一个native方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程在指定时间内获取不到锁，除了返回false外，最终还会执行<strong>cancelAcquire</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳过当前节点之前的已经取消的节点</span></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)<span class="comment">//CANCELED：1</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;<span class="comment">//将当前节点标记为CANCELLED</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//那就是有了尾部的并发操作</span></span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015562787">Java多线程进阶（六）—— J.U.C之locks框架：AQS综述(1)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c066b061c280">AbstractQueuedSynchronizer(AQS)初探</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015804888">Java多线程进阶（七）—— J.U.C之locks框架：AQS独占功能剖析(2)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6babeba3bf2f">AbstractQueuedSynchronizer(AQS)深入剖析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4682a6b0802d">并发编程——详解 AQS CLH 锁</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/claram/article/details/83828768">算法：CLH锁的原理及实现</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8B%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/">http://muchengxue.github.io/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8B%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AQS/">AQS</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8Bcollections%E6%A1%86%E6%9E%B6%EF%BC%9AArrayBlockingQueue/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC之collections框架：ArrayBlockingQueue</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8BCondition%E6%8E%A5%E5%8F%A3/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AQS之Condition</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8EReentrantLock%E7%9C%8BCondition%E6%8E%A5%E5%8F%A3/" title="AQS之Condition"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">AQS之Condition</div></div></a></div><div><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%BB%8ECountDownLatch%E7%9C%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" title="AQS之从CountDownLatch看共享模式"><img class="cover" src="https://w.wallhaven.cc/full/dg/wallhaven-dgzj9o.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">AQS之从CountDownLatch看共享模式</div></div></a></div><div><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9AReentrantReadWriteLock/" title="AQS之ReentrantReadWriteLock"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">AQS之ReentrantReadWriteLock</div></div></a></div><div><a href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-03</div><div class="title">AQS的设计思路</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Concurrent%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">一、Concurrent包的实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Lock%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">二、Lock简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81AQS%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">三、AQS概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8F%90%E4%BE%9B%E4%B8%80%E5%A5%97%E6%A8%A1%E6%9D%BF%E6%A1%86%E6%9E%B6"><span class="toc-number">3.1.</span> <span class="toc-text">1 提供一套模板框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AQS%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2 AQS核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.1.</span> <span class="toc-text">CAS操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E3%80%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.2.</span> <span class="toc-text">【同步队列】的核心操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.3.</span> <span class="toc-text">资源的获取操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.</span> <span class="toc-text">资源的释放操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3 原理简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">同步状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E-%E5%94%A4%E9%86%92"><span class="toc-number">3.3.2.</span> <span class="toc-text">线程的阻塞&#x2F;唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E3%80%91"><span class="toc-number">3.3.3.</span> <span class="toc-text">【同步队列】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B3%A8%E9%87%8A%E4%B8%AD%E7%9A%84Mutex%E4%BE%8B%E5%AD%90"><span class="toc-number">3.4.</span> <span class="toc-text">4 注释中的Mutex例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ReentrantLock"><span class="toc-number">4.</span> <span class="toc-text">四、ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%85%AC%E5%B9%B3%E7%AD%96%E7%95%A5%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">ReentrantLock的公平策略原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ThreadA%E9%A6%96%E5%85%88%E8%8E%B7%E5%8F%96%E5%88%B0%E9%94%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">1 ThreadA首先获取到锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ThreadB%E5%BC%80%E5%A7%8B%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">4.1.2.</span> <span class="toc-text">2 ThreadB开始获取锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-dummy%E8%8A%82%E7%82%B9"><span class="toc-number">4.1.3.</span> <span class="toc-text">3 dummy节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%8B%AC%E5%8D%A0%E5%BC%8F%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E5%9B%BE%E8%A7%A3"><span class="toc-number">4.1.4.</span> <span class="toc-text">4 独占式锁的获取图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ThreadC%E5%BC%80%E5%A7%8B%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">4.1.5.</span> <span class="toc-text">5 ThreadC开始获取锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ThreadA%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">4.1.6.</span> <span class="toc-text">6 ThreadA释放锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-ThreadB%E5%94%A4%E9%86%92%E5%90%8E%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C"><span class="toc-number">4.1.7.</span> <span class="toc-text">7 ThreadB唤醒后继续执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ThreadB%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">4.1.8.</span> <span class="toc-text">8 ThreadB释放锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-ThreadC%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">4.1.9.</span> <span class="toc-text">9 ThreadC释放锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%AD%96%E7%95%A5%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">ReentrantLock的非公平策略原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81AQS%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">5.</span> <span class="toc-text">五、AQS对中断的支持</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81AQS%E5%AF%B9%E9%99%90%E6%97%B6%E7%AD%89%E5%BE%85%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">6.</span> <span class="toc-text">六、AQS对限时等待的支持</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS的设计思路"/></a><div class="content"><a class="title" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路">AQS的设计思路</a><time datetime="2022-02-03T13:10:28.437Z" title="发表于 2022-02-03 13:10:28">2022-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="float的范围和精度"/></a><div class="content"><a class="title" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度">float的范围和精度</a><time datetime="2022-01-21T14:18:25.869Z" title="发表于 2022-01-21 14:18:25">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="随想1"/></a><div class="content"><a class="title" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1">随想1</a><time datetime="2021-12-18T16:15:22.363Z" title="发表于 2021-12-18 16:15:22">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 吊打面试官"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官">Redis 吊打面试官</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis中的事务"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务">Redis中的事务</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>