<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>暮成雪的博客 | 暮成雪的博客</title><meta name="keywords" content="JAVA"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、网路基础在讨论IO的时候，参与者通常有两个角色：系统内核和用户进程。用户进程发送 IO请求过后，系统内核在准备好IO数据后，会通过内存拷贝的方式，将准备好的缓存IO数据共享给用户进程缓存。 网络I&#x2F;O模型简介 根据UNIX网络编程对I&#x2F;O模型的分类，提供了阻塞I&#x2F;O模型、非阻塞I&#x2F;O模型、I&#x2F;O复用模型、信号驱动I&#x2F;O模型、异步I&#x2F;O这5种I&#x2F;O模型。 阻塞I&#x2F;O模型最常用的模型，所有文件操作">
<meta property="og:type" content="article">
<meta property="og:title" content="暮成雪的博客">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/java%20%E4%B9%8BIO/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="一、网路基础在讨论IO的时候，参与者通常有两个角色：系统内核和用户进程。用户进程发送 IO请求过后，系统内核在准备好IO数据后，会通过内存拷贝的方式，将准备好的缓存IO数据共享给用户进程缓存。 网络I&#x2F;O模型简介 根据UNIX网络编程对I&#x2F;O模型的分类，提供了阻塞I&#x2F;O模型、非阻塞I&#x2F;O模型、I&#x2F;O复用模型、信号驱动I&#x2F;O模型、异步I&#x2F;O这5种I&#x2F;O模型。 阻塞I&#x2F;O模型最常用的模型，所有文件操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:43.727Z">
<meta property="article:modified_time" content="2020-04-07T11:29:46.980Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/java%20%E4%B9%8BIO/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '暮成雪的博客',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-04-07 11:29:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-books"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad-alt"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-books"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad-alt"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:43.727Z" title="发表于 2021-12-18 14:42:43">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-04-07T11:29:46.980Z" title="更新于 2020-04-07 11:29:46">2020-04-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/java%20%E4%B9%8BIO/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/java%20%E4%B9%8BIO/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、网路基础"><a href="#一、网路基础" class="headerlink" title="一、网路基础"></a>一、网路基础</h1><p>在讨论IO的时候，参与者通常有两个角色：系统内核和用户进程。用户进程发送 IO请求过后，系统内核在准备好IO数据后，会通过内存拷贝的方式，将准备好的缓存IO数据共享给用户进程缓存。</p>
<p><strong>网络I/O模型简介</strong></p>
<p>根据UNIX网络编程对I/O模型的分类，提供了阻塞I/O模型、非阻塞I/O模型、I/O复用模型、信号驱动I/O模型、异步I/O这5种I/O模型。</p>
<h2 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h2><p>最常用的模型，所有文件操作都是阻塞的。套接字socket在进程空间中调用recvfrom，其系统调用直到数据包到达，且被复制到应用进程的缓冲区或者发生错误的时候才返回，在此期间一直会等待，<strong>进程从调用recvfrom开始到它返回的整段时间内都是被阻塞的</strong>，因此被称为阻塞I/O模型。常用IO模型交互图如图所示。</p>
<p><img src="https://www.alicharles.com/images/2016/08/20160828114646_65954.png" alt="img"></p>
<p>首先应用程序调用recvfrom()转入内核，注意内核有2个过程，等待数据就绪和拷贝内核数据到用户空间，直到最后复制完成后，recvfrom()才返回，此过程一直是阻塞的。</p>
<h2 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a><strong>非阻塞I/O模型</strong></h2><p>recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来，如图所示。</p>
<p><img src="https://www.alicharles.com/images/2016/08/20160828114658_50315.png" alt="20160828114658 50315"></p>
<h2 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h2><p>Linux提供select/poll，进程通过将一个或者多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个文件描述符fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到一些限制。Linux还提供了一个epoll系统调用，epoll基于事件驱动方式代替顺序扫描，性能更高，当有fd就绪时，立即回调函数rollback，如图所示。</p>
<p><img src="https://www.alicharles.com/images/2016/08/20160828114712_55853.png" alt="20160828114712 55853"></p>
<p>select先阻塞，有活动套接字才返回。与blocking I/O相比，select会有两次系统调用，但是select能处理多个套接字。</p>
<h2 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h2><p>首先开启套接字信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据，如图所示。</p>
<p><img src="https://www.alicharles.com/images/2016/08/20160828114723_67587.png" alt="20160828114723 67587"></p>
<p>只有Unix系统支持，与I/O multiplexing (select and poll)相比，它的优势是，免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>告知内核启动某个操作，并让内核在整个操作完成之后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别就是：信号驱动I/O由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成。</p>
<p><img src="https://www.alicharles.com/images/2016/08/20160828114734_83283.png" alt="20160828114734 83283"></p>
<p>很少有Linux/Unix系统支持，Windows的IOCP则是此模型，完全异步的I/O复用机制，纵观上面其它四种模型，至少都会在由kernel copy data to appliction时阻塞。而该模型是当copy完成后才通知application，可见是纯异步的，好像只有Windows的完成端口是这个模型，效率也很出色。</p>
<h2 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h2><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还在准备数据的情况下会立刻返回。</p>
<h2 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h2><p>Stevens给出的定义（其实是POSIX的定义）是这样子的：</p>
<blockquote>
<p> A synchronous I/O operation <strong>causes</strong> the <strong>requesting process</strong> to be <strong>blocked</strong> until that I/O operation completes;<br>  An asynchronous I/O operation <strong>does not</strong> cause the requesting process to be blocked</p>
</blockquote>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的**<code>recvfrom</code><strong>这个系统调用。</strong>non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。<strong>而asynchronous IO则不一样，当进程发起IO操作之后，</strong>就直接返回再也不理睬**了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<h2 id="各种IO模型的比较"><a href="#各种IO模型的比较" class="headerlink" title="各种IO模型的比较"></a>各种IO模型的比较</h2><p><img src="C:\Users\Administrator\Desktop\面试题总结\计算机网络\IO5.png" alt="img"></p>
<h1 id="二、Java的I-O的演进"><a href="#二、Java的I-O的演进" class="headerlink" title="二、Java的I/O的演进"></a>二、Java的I/O的演进</h1><p>从JDK1.0到JDK1.3，Java的I/O类库都非常原始，基于Java的所有Socket通信都采用了同步阻塞模式（BIO），在性能和可靠性方面存在着巨大的瓶颈。</p>
<p>2002年JDK1.4发布，NIO以JSR-51的身份随JDK发布，增加了java.nio包，提供了很多非阻塞I/O开发的类库，在JDK1.4和1.5 update 10版本之前，JDK的selector基于select/poll模型，基于I/O复用的非阻塞I/O，不是异步I/O。在JDK1.5 update 10 和Linux core2.6以上版本，优化了selector的实现，在底层使用epoll替换了select/poll，上层API没有变化，可认为是JDK NIO的一次性能优化。</p>
<p>2011年JDK1.7发布，将原来的NIO进行了升级，通过JSR-203演进而来，称为NIO2.0，提供异步I/O开发类库。</p>
<h3 id="Java同步阻塞I-O"><a href="#Java同步阻塞I-O" class="headerlink" title="Java同步阻塞I/O"></a>Java同步阻塞I/O</h3><p>在java中调用InputStream.read()或者OutputStream.write()时，用户进程会阻塞住直到数据就绪，相当于一个线程一个连接的方式。所以在采用Java IO时，<strong>在Server端通常会采用对于每个新连接，起一个新的线程去处理</strong>，这样后来的连接就不用等到之前的完成才能操作。但也带来了问题，<strong>毕竟线程是系统的稀缺资源，数量上会有瓶颈，达到一定数量后，性能急剧下降，内存崩溃</strong>。不能应对大量连接的情况，而且线程切换很耗费系统资源。</p>
<h3 id="Java-NIO同步非阻塞IO"><a href="#Java-NIO同步非阻塞IO" class="headerlink" title="Java NIO同步非阻塞IO"></a>Java NIO同步非阻塞IO</h3><p>基于Java IO的缺点，NIO采用了新的设计方式，核心在ServerSocketChannel, SocketChannel, FileChannel, ByteBuffer, Pipe, Selector。非阻塞主要依靠<strong>Selector</strong>，Channel在Selector上注册自己感兴趣的事件，然后<strong>Selector线程会轮询注册在自己身上的Channel，当有数据准备就绪时，就通知相应的Channel</strong>。这样一个Selector可以管理多个Channel，但<strong>实际上还是阻塞的，现在不阻塞IO层面了，阻塞在Selector线程上了</strong>。而且<strong>采用轮询的方式，效率比较低</strong>。</p>
<h3 id="Java-AIO异步非阻塞IO"><a href="#Java-AIO异步非阻塞IO" class="headerlink" title="Java AIO异步非阻塞IO"></a>Java AIO异步非阻塞IO</h3><p>在Java NIO的基础上，增加了AsynchronousServerSocketChannel, AsynchronousSocketChannel, AsynchronousChannelGroup, CompletionHandler，其中AsynchronousChannelGroup起到了事件收集和任务分发的作用，而CompletionHandler是绑定在事件上回调机制，从而达到异步。能否真正实现异步，关键还要看系统底层的实现，当前来看只有window的iocp实现了真正的异步，linux上还是通过epoll来模拟，是一种伪异步。</p>
<p>是否异步主要在<strong>系统内核数据拷贝到用户进程这个步骤来区分</strong>，<strong>同步的话是通知用户进程数据准备好了，可以拷贝了，然后用户进程阻塞去拷贝数据；异步的话是操作系统帮你把数据拷贝后，然后通知你数据好了，可以直接用了。</strong></p>
<h1 id="二、BIO"><a href="#二、BIO" class="headerlink" title="二、BIO"></a>二、BIO</h1><p>Blocking I/O：同步阻塞式IO，服务器实现模式为<strong>一个连接一个线程</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过<strong>线程池</strong>机制改善。</p>
<p>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。BIO通信（一请求一应答）模型图如下</p>
<p><img src="https://img-blog.csdnimg.cn/2019042212100021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA5MDQ2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>采用 <strong>BIO 通信模型</strong> 的服务端，通常由一个独立的 <code>Acceptor</code> 线程负责监听客户端的连接。我们一般通过在 <code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，<strong>只能等待同当前连接的客户端的操作执行完成</strong>， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) 接收新连接线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// (1) 阻塞方法获取新的连接</span></span><br><span class="line">                    Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// (2) 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">                    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                            InputStream inputStream = socket.getInputStream();</span><br><span class="line">                            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                <span class="keyword">int</span> len;</span><br><span class="line">                                <span class="comment">// (3) 按字节流方式读取数据</span></span><br><span class="line">                                <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.getOutputStream().write((<span class="keyword">new</span> Date() + <span class="string">&quot;: hello world&quot;</span>).getBytes());</span><br><span class="line">                        socket.getOutputStream().flush();</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要让 <strong>BIO 通信模型</strong> 能够同时处理多个客户端请求，就必须使用多线程（主要原因是 <code>socket.accept()</code>、 <code>socket.read()</code>、 <code>socket.write()</code> 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 <strong>一请求一应答通信模型</strong> 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 <strong>线程池机制</strong> 改善，线程池还可以让线程的创建和回收成本相对较低。使用<code>FixedThreadPool</code> 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了<strong>N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型</strong>（N 可以远远大于 M）。使用线程池机制改善后的 <em>BIO</em> 模型图如下*:* </p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200326152907349.png" alt="image-20200326152907349"></p>
<p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p><strong>设想一下当客户端并发访问量增加后这种模型会出现什么问题？</strong></p>
<p>在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p>
<h1 id="三、NIO-的多路复用"><a href="#三、NIO-的多路复用" class="headerlink" title="三、NIO 的多路复用"></a>三、NIO 的多路复用</h1><p> <strong>NIO</strong>是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 <strong>java.nio</strong> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code>等抽象。</p>
<p><code>NIO</code>中的N可以理解为<code>Non-blocking</code>。它支持<code>面向缓冲</code>的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。<strong>对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</strong>。</p>
<p>NIO 是利用了<strong>单线程轮询事件</strong>的机制，通过高效地<strong>定位就绪的 Channel</strong>，来决定做什么，仅仅 <strong>select 阶段是阻塞</strong>的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。NIO 复用的流程：</p>
<p><img src="http://icdn.apigo.cn/blog/javacore-io-006.png" alt="img"></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">package</span> nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CancelledKeyException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 多路复用器， 选择器。 用于注册通道的。</span></span><br><span class="line">	<span class="keyword">private</span> Selector selector;</span><br><span class="line">	<span class="comment">// 定义了两个缓存。分别用于读和写。 初始化空间大小单位为字节。</span></span><br><span class="line">	<span class="keyword">private</span> ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">private</span> ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer(<span class="number">9999</span>)).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">		init(port);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;server starting at port &quot;</span> + port + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">			<span class="comment">// 开启多路复用器</span></span><br><span class="line">			<span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">			<span class="comment">// 开启服务通道</span></span><br><span class="line">			ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">			<span class="comment">// 非阻塞， 如果传递参数true，为阻塞模式。</span></span><br><span class="line">			serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">// 绑定端口</span></span><br><span class="line">			serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">			<span class="comment">// 注册，并标记当前服务通道状态</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * register(Selector, int)</span></span><br><span class="line"><span class="comment">			 * int - 状态编码</span></span><br><span class="line"><span class="comment">			 *  OP_ACCEPT ： 连接成功的标记位。</span></span><br><span class="line"><span class="comment">			 *  OP_READ ： 可以读取数据的标记</span></span><br><span class="line"><span class="comment">			 *  OP_WRITE ： 可以写入数据的标记</span></span><br><span class="line"><span class="comment">			 *  OP_CONNECT ： 连接建立后的标记</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			serverChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">			System.out.println(<span class="string">&quot;server started.&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 阻塞方法，当至少一个通道被选中，此方法返回。</span></span><br><span class="line">				<span class="comment">// 通道是否选择，由注册到多路复用器中的通道标记决定。</span></span><br><span class="line">				<span class="keyword">this</span>.selector.select();</span><br><span class="line">				<span class="comment">// 返回以选中的通道标记集合， 集合中保存的是通道的标记。相当于是通道的ID。</span></span><br><span class="line">				Iterator&lt;SelectionKey&gt; keys = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">				<span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">					SelectionKey key = keys.next();</span><br><span class="line">					<span class="comment">// 将本次要处理的通道从集合中删除，下次循环根据新的通道列表再次执行必要的业务逻辑</span></span><br><span class="line">					keys.remove();</span><br><span class="line">					<span class="comment">// 通道是否有效</span></span><br><span class="line">					<span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">						<span class="comment">// 阻塞状态</span></span><br><span class="line">						<span class="keyword">try</span>&#123;</span><br><span class="line">							<span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">								accept(key);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;<span class="keyword">catch</span>(CancelledKeyException cke)&#123;</span><br><span class="line">							<span class="comment">// 断开连接。 出现异常。</span></span><br><span class="line">							key.cancel();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 可读状态</span></span><br><span class="line">						<span class="keyword">try</span>&#123;</span><br><span class="line">							<span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">								read(key);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;<span class="keyword">catch</span>(CancelledKeyException cke)&#123;</span><br><span class="line">							key.cancel();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 可写状态</span></span><br><span class="line">						<span class="keyword">try</span>&#123;</span><br><span class="line">							<span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">								write(key);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;<span class="keyword">catch</span>(CancelledKeyException cke)&#123;</span><br><span class="line">							key.cancel();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.writeBuffer.clear();</span><br><span class="line">		SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">		Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.print(<span class="string">&quot;put message for send to client &gt; &quot;</span>);</span><br><span class="line">			String line = reader.nextLine();</span><br><span class="line">			<span class="comment">// 将控制台输入的字符串写入Buffer中。 写入的数据是一个字节数组。</span></span><br><span class="line">			writeBuffer.put(line.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">			writeBuffer.flip();</span><br><span class="line">			channel.write(writeBuffer);</span><br><span class="line">			</span><br><span class="line">			channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 清空读缓存。</span></span><br><span class="line">			<span class="keyword">this</span>.readBuffer.clear();</span><br><span class="line">			<span class="comment">// 获取通道</span></span><br><span class="line">			SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">			<span class="comment">// 将通道中的数据读取到缓存中。通道中的数据，就是客户端发送给服务器的数据。</span></span><br><span class="line">			<span class="keyword">int</span> readLength = channel.read(readBuffer);</span><br><span class="line">			<span class="comment">// 检查客户端是否写入数据。</span></span><br><span class="line">			<span class="keyword">if</span>(readLength == -<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="comment">// 没有数据， 关闭通道</span></span><br><span class="line">				key.channel().close();</span><br><span class="line">				<span class="comment">// 关闭连接</span></span><br><span class="line">				key.cancel();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * flip， NIO中最复杂的操作就是Buffer的控制。</span></span><br><span class="line"><span class="comment">			 * Buffer中有一个游标。游标信息在操作后不会归零，如果直接访问Buffer的话，数据有不一致的可能。</span></span><br><span class="line"><span class="comment">			 * flip是重置游标的方法。NIO编程中，flip方法是常用方法。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">this</span>.readBuffer.flip();</span><br><span class="line">			<span class="comment">// 字节数组，保存具体数据的。 Buffer.remaining() -&gt; 是获取Buffer中有效数据长度的方法。</span></span><br><span class="line">			<span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[readBuffer.remaining()];</span><br><span class="line">			<span class="comment">// 是将Buffer中的有效数据保存到字节数组中。</span></span><br><span class="line">			readBuffer.get(datas);</span><br><span class="line">			System.out.println(<span class="string">&quot;from &quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; client : &quot;</span> + <span class="keyword">new</span> String(datas, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 注册通道， 标记为写操作。</span></span><br><span class="line">			channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_WRITE);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				key.channel().close();</span><br><span class="line">				key.cancel();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 此通道为init方法中注册到Selector上的ServerSocketChannel</span></span><br><span class="line">			ServerSocketChannel serverChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">			<span class="comment">// 阻塞方法，当客户端发起请求后返回。 此通道和客户端一一对应。</span></span><br><span class="line">			SocketChannel channel = serverChannel.accept();</span><br><span class="line">			channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">// 设置对应客户端的通道标记状态，此通道为读取数据使用的。</span></span><br><span class="line">			channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">package</span> nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 远程地址创建</span></span><br><span class="line">		InetSocketAddress remote = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">		SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 定义缓存。</span></span><br><span class="line">		ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 开启通道</span></span><br><span class="line">			channel = SocketChannel.open();</span><br><span class="line">			<span class="comment">// 连接远程服务器。</span></span><br><span class="line">			channel.connect(remote);</span><br><span class="line">			Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;put message for send to server &gt; &quot;</span>);</span><br><span class="line">				String line = reader.nextLine();</span><br><span class="line">				<span class="keyword">if</span>(line.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 将控制台输入的数据写入到缓存。</span></span><br><span class="line">				buffer.put(line.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">				<span class="comment">// 重置缓存游标</span></span><br><span class="line">				buffer.flip();</span><br><span class="line">				<span class="comment">// 将数据发送给服务器</span></span><br><span class="line">				channel.write(buffer);</span><br><span class="line">				<span class="comment">// 清空缓存数据。</span></span><br><span class="line">				buffer.clear();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 读取服务器返回的数据</span></span><br><span class="line">				<span class="keyword">int</span> readLength = channel.read(buffer);</span><br><span class="line">				<span class="keyword">if</span>(readLength == -<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 重置缓存游标</span></span><br><span class="line">				buffer.flip();</span><br><span class="line">				<span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">				<span class="comment">// 读取数据到字节数组。</span></span><br><span class="line">				buffer.get(datas);</span><br><span class="line">				System.out.println(<span class="string">&quot;from server : &quot;</span> + <span class="keyword">new</span> String(datas, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">				<span class="comment">// 清空缓存。</span></span><br><span class="line">				buffer.clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">null</span> != channel)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					channel.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个客户端请求都会注册到Selector(多路复用器)</p>
<p><img src="https://img2018.cnblogs.com/blog/1208477/201904/1208477-20190426132304479-1113131365.png" alt="img"></p>
<h2 id="NIO的特性-NIO与IO区别"><a href="#NIO的特性-NIO与IO区别" class="headerlink" title="NIO的特性/NIO与IO区别"></a>NIO的特性/NIO与IO区别</h2><p>如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。</p>
<h3 id="1-Non-blocking-IO（非阻塞IO）"><a href="#1-Non-blocking-IO（非阻塞IO）" class="headerlink" title="1)Non-blocking IO（非阻塞IO）"></a>1)Non-blocking IO（非阻塞IO）</h3><p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p>
<p>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了</p>
<h3 id="2-Buffer-缓冲区"><a href="#2-Buffer-缓冲区" class="headerlink" title="2)Buffer(缓冲区)"></a>2)Buffer(缓冲区)</h3><p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p>
<p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p>
<p>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。<strong>任何时候访问NIO中的数据，都是通过缓冲区进行操作。</strong></p>
<p>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p>
<p>Buffer 可以简单的理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有四个索引。如下表所示：</p>
<table>
<thead>
<tr>
<th align="left"><strong>索引</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">capacity</td>
<td align="left">缓冲区数组的总长度</td>
</tr>
<tr>
<td align="left">position</td>
<td align="left">下一个要操作的数据元素的位置</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">缓冲区数组中不可操作的下一个元素的位置，limit&lt;=capacity</td>
</tr>
<tr>
<td align="left">mark</td>
<td align="left">用于记录当前 position 的前一个位置或者默认是 0</td>
</tr>
</tbody></table>
<p>在实际操作数据时它们有如下关系图：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image023.jpg" alt="Figure xxx. Requires a heading"></p>
<p>我们通过 ByteBuffer.allocate(11) 方法创建一个 11 个 byte 的数组缓冲区，初始状态如上图所示，position 的位置为 0，capacity 和 limit 默认都是数组长度。当我们写入 5 个字节时位置变化如下图所示：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image025.jpg" alt="Figure xxx. Requires a heading"></p>
<p>这时我们需要将缓冲区的 5 个字节数据写入 Channel 通信信道，所以我们需要调用 byteBuffer.flip() 方法，数组的状态又发生如下变化：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image027.jpg" alt="Figure xxx. Requires a heading"></p>
<p>这时底层操作系统就可以从缓冲区中正确读取这 5 个字节数据发送出去了。在下一次写数据之前我们在调一下 clear() 方法。缓冲区的索引状态又回到初始位置。这里还要说明一下 mark，当我们调用 mark() 时，它将记录当前 position 的前一个位置，当我们调用 reset 时，position 将恢复 mark 记录下来的值。</p>
<h3 id="3-Channel-通道"><a href="#3-Channel-通道" class="headerlink" title="3)Channel (通道)"></a>3)Channel (通道)</h3><p>NIO 通过Channel（通道） 进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p>
<h3 id="4-Selectors-选择器"><a href="#4-Selectors-选择器" class="headerlink" title="4)Selectors(选择器)"></a>4)Selectors(选择器)</h3><p>NIO有选择器，而IO没有。选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p>
<h2 id="NIO-读数据和写数据方式"><a href="#NIO-读数据和写数据方式" class="headerlink" title="NIO 读数据和写数据方式"></a>NIO 读数据和写数据方式</h2><p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p>
<ul>
<li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li>
<li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
<p>数据读取和写入操作图示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190422121151244.png" alt="img"></p>
<h2 id="BIO与NIO"><a href="#BIO与NIO" class="headerlink" title="BIO与NIO"></a>BIO与NIO</h2><p>同步非阻塞式IO，关键是采用了<strong>事件驱动的思想</strong>来<strong>实现了一个多路转换器</strong>。 </p>
<p>NIO与BIO最大的区别就是只需要<strong>开启一个线程就可以处理来自多个客户端的IO事件</strong>，实现原理就是<strong>多路复用器</strong>，可以监听来自多个客户端的IO事件：<br>A. 若服务端监听到客户端连接请求，便为其建立通信套接字(java中就是通道)，然后返回继续监听，若同时有多个客户端连接请求到来也可以全部收到，依次为它们都建立通信套接字。<br>B. <strong>若服务端监听到来自已经创建了通信套接字的客户端发送来的数据，就会调用对应接口处理接收到的数据，若同时有多个客户端发来数据也可以依次进行处理。</strong><br>C. 监听多个客户端的连接请求和接收数据请求同时还能监听自己是否有数据要发送。</p>
<p>总之就是在一个线程中就可以调用多路复用接口（java中是select）阻塞同时监听来自多个客户端的IO请求，一旦有收到IO请求就调用对应函数处理。 一旦有请求到来(不管是几个同时到还是只有一个到)，都会调用对应IO处理函数处理，所以：</p>
<p>（1）<strong>NIO适合处理连接数目特别多，但是连接比较短（轻操作）的场景</strong>，<strong>Jetty，Mina，ZooKeeper等都是基于java nio实现</strong>。</p>
<p>（2）<strong>BIO方式适用于连接数目比较小且固定的场景，这种方式对服务器资源要求比较高</strong>，并发局限于应用中。</p>
<p>（3）<strong>Selector空轮询，导致CPU占满</strong></p>
<h1 id="四、AIO-Asynchronous-I-O"><a href="#四、AIO-Asynchronous-I-O" class="headerlink" title="四、AIO (Asynchronous I/O)"></a>四、AIO (Asynchronous I/O)</h1><p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p>AIO 是异步IO的缩写，虽然 <strong>NIO 在网络操作中，提供了非阻塞的方法</strong>，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的<strong>业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。</strong></p>
<p><strong>异步</strong>这个词，对于绝大多数开发者来说都很熟悉，很多场景下我们都会使用异步。通常，我们会有一个线程池用于执行异步任务，提交任务的线程将任务提交到线程池就可以立马返回，不必等到任务真正完成。如果想要知道任务的执行结果，通常是通过传递一个<strong>回调函数</strong>的方式，任务结束后去调用这个函数。</p>
<p>同样的原理，Java 中的异步 IO 也是一样的，都是由一个<strong>线程池</strong>来负责执行任务，然后<strong>使用回调或自己去查询结果</strong>。大部分开发者都知道为什么要这么设计了，这里再啰嗦一下。<strong>异步 IO 主要是为了控制线程数量，减少过多的线程带来的内存消耗和 CPU 在线程调度上的开销。</strong></p>
<p>Java 异步 IO 提供了两种使用方式，分别是返回 Future 实例和使用回调函数。</p>
<h2 id="1、返回-Future-实例"><a href="#1、返回-Future-实例" class="headerlink" title="1、返回 Future 实例"></a>1、返回 Future 实例</h2><p>返回 java.util.concurrent.Future 实例的方式我们应该很熟悉，JDK 线程池就是这么使用的。Future 接口的几个方法语义在这里也是通用的，这里先做简单介绍。</p>
<ul>
<li><p>future.isDone();</p>
<p>判断操作是否已经完成，包括了<strong>正常完成、异常抛出、取消</strong></p>
</li>
<li><p>future.cancel(true);</p>
<p>取消操作，方式是中断。参数 true ，即使这个任务正在执行，也会进行中断。</p>
</li>
<li><p>future.isCancelled();</p>
<p>是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</p>
</li>
<li><p>future.get(); </p>
<p>阻塞获取执行结果。</p>
</li>
<li><p>future.get(10, TimeUnit.SECONDS);</p>
<p>加入超时时间</p>
</li>
</ul>
<h2 id="2、提供-CompletionHandler-回调函数"><a href="#2、提供-CompletionHandler-回调函数" class="headerlink" title="2、提供 CompletionHandler 回调函数"></a>2、提供 CompletionHandler 回调函数</h2><p>java.nio.channels.CompletionHandler 接口定义</p>
<h1 id="五、Netty"><a href="#五、Netty" class="headerlink" title="五、Netty"></a>五、Netty</h1><p>Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>
<h2 id="JDK-原生-NIO-程序的问题"><a href="#JDK-原生-NIO-程序的问题" class="headerlink" title="JDK 原生 NIO 程序的问题"></a>JDK 原生 NIO 程序的问题</h2><p>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：</p>
<ul>
<li><p><strong>NIO 的类库和 API 繁杂，使用麻烦。</strong>你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</p>
</li>
<li><p><strong>需要具备其他的额外技能做铺垫。</strong>例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。</p>
</li>
<li><p><strong>可靠性能力补齐，开发工作量和难度都非常大。</strong>例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。</p>
<p>NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。</p>
</li>
<li><p><strong>JDK NIO 的 Bug。</strong>例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。</p>
<p>官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</p>
</li>
</ul>
<h2 id="Netty-的特点"><a href="#Netty-的特点" class="headerlink" title="Netty 的特点"></a>Netty 的特点</h2><p>Netty 对 JDK 自带的 NIO 的 API 进行封装，解决上述问题，主要特点有：</p>
<ul>
<li><strong>设计优雅，</strong>适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池；真正的无连接数据报套接字支持（自 3.1 起）。</li>
<li><strong>使用方便</strong>，详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</li>
<li><strong>高性能，吞吐量更高，</strong>延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li><strong>安全，</strong>完整的 SSL/TLS 和 StartTLS 支持。</li>
<li><strong>社区活跃，不断更新，</strong>社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。</li>
</ul>
<h2 id="Netty-常见使用场景"><a href="#Netty-常见使用场景" class="headerlink" title="Netty 常见使用场景"></a>Netty 常见使用场景</h2><p>Netty 常见的使用场景如下：</p>
<ul>
<li><p><strong>互联网行业。</strong>在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。</p>
<p><strong>典型的应用有：</strong>阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
</li>
<li><p><strong>游戏行业。</strong>无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用。Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈。</p>
<p>非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过 Netty 进行高性能的通信。</p>
</li>
<li><p><strong>大数据领域。</strong>经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信，它的 Netty Service 基于 Netty 框架二次封装实现。</p>
</li>
</ul>
<h2 id="Netty-架构设计"><a href="#Netty-架构设计" class="headerlink" title="Netty 架构设计"></a>Netty 架构设计</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a><strong>功能特性</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpomUbeYfOKnjKKibLEMpGUP3eJ39NeAprvtib8Wfp4hp4CJqfmhF3Cc3fqzgXTJlcFxiaDPOsZNN13A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>Netty 功能特性如下：</p>
<ul>
<li><strong>传输服务，</strong>支持 BIO 和 NIO。</li>
<li><strong>容器集成，</strong>支持 OSGI、JBossMC、Spring、Guice 容器。</li>
<li><strong>协议支持，</strong>HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议。</li>
<li><strong>Core 核心，</strong>可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</li>
</ul>
<h3 id="模块组件"><a href="#模块组件" class="headerlink" title="模块组件"></a><strong>模块组件</strong></h3><p><strong>Bootstrap、ServerBootstrap</strong></p>
<p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
<p><strong>Future、ChannelFuture</strong></p>
<p>正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>
<p><strong>Channel</strong></p>
<p>Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p>
<ul>
<li><p>当前网络连接的通道的状态（例如是否打开？是否已连接？）</p>
</li>
<li><p>网络连接的配置参数 （例如接收缓冲区大小）</p>
</li>
<li><p>提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</p>
<p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</p>
</li>
<li><p>支持关联 I/O 操作与对应的处理程序。</p>
</li>
</ul>
<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。下面是一些常用的 Channel 类型：</p>
<ul>
<li>NioSocketChannel，异步的客户端 TCP Socket 连接。</li>
<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</li>
<li>NioDatagramChannel，异步的 UDP 连接。</li>
<li>NioSctpChannel，异步的客户端 Sctp 连接。</li>
<li>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</li>
</ul>
<p><strong>Selector</strong></p>
<p>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>
<p><strong>NioEventLoop</strong></p>
<p>NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：</p>
<ul>
<li><strong>I/O 任务，</strong>即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。</li>
<li><strong>非 IO 任务，</strong>添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</li>
</ul>
<p>两种任务的执行时间比由变量 ioRatio 控制，默认为 50，则表示允许非 IO 任务执行的时间与 IO 任务的执行时间相等。</p>
<p><strong>NioEventLoopGroup</strong></p>
<p>NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个<strong>线程池</strong>，内部<strong>维护了一组线程</strong>，<strong>每个线程(NioEventLoop)负责处理多个 Channel 上的事件</strong>，而<strong>一个 Channel 只对应于一个线程</strong>。</p>
<p><strong>ChannelHandler</strong></p>
<p>ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<ul>
<li>ChannelInboundHandler 用于处理入站 I/O 事件。</li>
<li>ChannelOutboundHandler 用于处理出站 I/O 操作。</li>
</ul>
<p>或者使用以下适配器类：</p>
<ul>
<li>ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。</li>
<li>ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。</li>
<li>ChannelDuplexHandler 用于处理入站和出站事件。</li>
</ul>
<p><strong>ChannelHandlerContext</strong></p>
<p>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p>
<p><strong>ChannelPipline</strong></p>
<p>保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。</p>
<p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。</p>
<p>下图引用 Netty 的 Javadoc 4.1 中 ChannelPipeline 的说明，描述了 ChannelPipeline 中 ChannelHandler 通常如何处理 I/O 事件。</p>
<p>I/O 事件由 ChannelInboundHandler 或 ChannelOutboundHandler 处理，并通过调用 ChannelHandlerContext 中定义的事件传播方法。</p>
<p>例如 ChannelHandlerContext.fireChannelRead（Object）和 ChannelOutboundInvoker.write（Object）转发到其最近的处理程序。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpomUbeYfOKnjKKibLEMpGUP4zabM8spHLZOP1mkHpkaPr3QNFEMAZ45iaXriaA1fv4b3wugwO2bKTlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。入站 Handler 处理程序通常处理由图底部的 I/O 线程生成的入站数据。</p>
<p>通常通过实际输入操作（例如 SocketChannel.read（ByteBuffer））从远程读取入站数据。</p>
<p>出站事件由上下方向处理，如图右侧所示。出站 Handler 处理程序通常会生成或转换出站传输，例如 write 请求。</p>
<p>I/O 线程通常执行实际的输出操作，例如 SocketChannel.write（ByteBuffer）。</p>
<p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpomUbeYfOKnjKKibLEMpGUPqIy6VSIr6RXia4zPtqVj6IGS11xqsWBA7lkuk1s6jLJ15AHf0ugEnkg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。</p>
<p>入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p>
<h2 id="Netty-工作原理架构"><a href="#Netty-工作原理架构" class="headerlink" title="Netty 工作原理架构"></a>Netty 工作原理架构</h2><p>初始化并启动 Netty 服务端过程如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建mainReactor</span></span><br><span class="line">       NioEventLoopGroup boosGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">       <span class="comment">// 创建工作线程组</span></span><br><span class="line">       NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">       serverBootstrap </span><br><span class="line">                <span class="comment">// 组装NioEventLoopGroup </span></span><br><span class="line">               .group(boosGroup, workerGroup)</span><br><span class="line">                <span class="comment">// 设置channel类型为NIO类型</span></span><br><span class="line">               .channel(NioServerSocketChannel.class)</span><br><span class="line">               <span class="comment">// 设置连接配置参数</span></span><br><span class="line">               .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">               .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">               .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">               <span class="comment">// 配置入站、出站事件handler</span></span><br><span class="line">               .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                       <span class="comment">// 配置入站、出站事件channel</span></span><br><span class="line">                       ch.pipeline().addLast(...);</span><br><span class="line">                       ch.pipeline().addLast(...);</span><br><span class="line">                   &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 绑定端口</span></span><br><span class="line">       <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">       serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;: 端口[&quot;</span> + port + <span class="string">&quot;]绑定成功!&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.err.println(<span class="string">&quot;端口[&quot;</span> + port + <span class="string">&quot;]绑定失败!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本过程如下：</p>
<ul>
<li>初始化创建 2 个 <code>NioEventLoopGroup</code>，其中 <code>boosGroup</code> 用于 <code>Accetpt</code> 连接建立事件并分发请求，<code>workerGroup</code> 用于处理 I/O 读写事件和业务逻辑。</li>
<li>基于 <code>ServerBootstrap</code>(服务端启动引导类)，配置 <code>EventLoopGroup</code>、<code>Channel</code> 类型，连接参数、配置入站、出站事件 <code>handler</code>。</li>
<li>绑定端口，开始工作。</li>
</ul>
<p>结合上面介绍的 Netty Reactor 模型，介绍服务端 Netty 的工作架构图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpomUbeYfOKnjKKibLEMpGUP6M0zyls4VRibRXYwMGml24ibicEru907pp1m5HlETY1XiaN8SMibGnWNTEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>Server 端包含 1 个 Boss NioEventLoopGroup 和 1 个 Worker NioEventLoopGroup。</p>
<p>NioEventLoopGroup 相当于 1 个事件循环组，这个组里包含多个事件循环 NioEventLoop，每个 NioEventLoop 包含 1 个 Selector 和 1 个事件循环线程</p>
<p>每个 Boss NioEventLoop 循环执行的任务包含 3 步：</p>
<ul>
<li><strong>轮询 Accept 事件。</strong></li>
<li><strong>处理 Accept I/O 事件，</strong>与 Client 建立连接，生成 NioSocketChannel，并将 NioSocketChannel 注册到某个 Worker NioEventLoop 的 Selector 上。</li>
<li><strong>处理任务队列</strong>中的任务，runAllTasks。任务队列中的任务包括用户调用 eventloop.execute 或 schedule 执行的任务，或者其他线程提交到该 eventloop 的任务。</li>
</ul>
<p>每个 Worker NioEventLoop 循环执行的任务包含 3 步：</p>
<ul>
<li>轮询 Read、Write 事件。</li>
<li>处理 I/O 事件，即 Read、Write 事件，在 NioSocketChannel 可读、可写事件发生时进行处理。</li>
<li>处理任务队列中的任务，runAllTasks。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.alicharles.com/article/netty/netty-io-basic/">Netty（一）网络IO基础</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aeolian/p/10773786.html">Java中BIO和NIO</a></p>
<p><a target="_blank" rel="noopener" href="http://www.imooc.com/article/265871">Java核心（五）深入理解BIO、NIO、AIO</a></p>
<p><a target="_blank" rel="noopener" href="http://ifeve.com/java-nio-all/">Java NIO 系列教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.javadoop.com/post/nio-and-aio">Java 非阻塞 IO 和异步 IO</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiexievv/article/details/44976215">5种网络IO模型</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YS_RLOd0iVwDcwH6JMyB8g">这可能是目前最透彻的Netty原理架构解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.javadoop.com/post/netty-part-1">Netty 源码解析系列</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/java%20%E4%B9%8BIO/">http://muchengxue.github.io/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/java%20%E4%B9%8BIO/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TCP连接的三次握手和四次挥手</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%92%8CHTTPS/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTTP和HTTPS</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E8%B7%AF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、网路基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EI-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">阻塞I&#x2F;O模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">非阻塞I&#x2F;O模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">I&#x2F;O复用模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8I-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">信号驱动I&#x2F;O模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-O"><span class="toc-number">1.5.</span> <span class="toc-text">异步I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blocking%E5%92%8Cnon-blocking%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">blocking和non-blocking的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronous-IO%E5%92%8Casynchronous-IO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">synchronous IO和asynchronous IO的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.</span> <span class="toc-text">各种IO模型的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java%E7%9A%84I-O%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">2.</span> <span class="toc-text">二、Java的I&#x2F;O的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EI-O"><span class="toc-number">2.0.1.</span> <span class="toc-text">Java同步阻塞I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">2.0.2.</span> <span class="toc-text">Java NIO同步非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-AIO%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">2.0.3.</span> <span class="toc-text">Java AIO异步非阻塞IO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81BIO"><span class="toc-number">3.</span> <span class="toc-text">二、BIO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81NIO-%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">三、NIO 的多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E7%89%B9%E6%80%A7-NIO%E4%B8%8EIO%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">NIO的特性&#x2F;NIO与IO区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Non-blocking-IO%EF%BC%88%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">1)Non-blocking IO（非阻塞IO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.1.2.</span> <span class="toc-text">2)Buffer(缓冲区)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Channel-%E9%80%9A%E9%81%93"><span class="toc-number">4.1.3.</span> <span class="toc-text">3)Channel (通道)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Selectors-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">4.1.4.</span> <span class="toc-text">4)Selectors(选择器)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO-%E8%AF%BB%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%99%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">NIO 读数据和写数据方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO%E4%B8%8ENIO"><span class="toc-number">4.3.</span> <span class="toc-text">BIO与NIO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81AIO-Asynchronous-I-O"><span class="toc-number">5.</span> <span class="toc-text">四、AIO (Asynchronous I&#x2F;O)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%BF%94%E5%9B%9E-Future-%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">1、返回 Future 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%8F%90%E4%BE%9B-CompletionHandler-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">2、提供 CompletionHandler 回调函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Netty"><span class="toc-number">6.</span> <span class="toc-text">五、Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-%E5%8E%9F%E7%94%9F-NIO-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">JDK 原生 NIO 程序的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">Netty 的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.</span> <span class="toc-text">Netty 常见使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.4.</span> <span class="toc-text">Netty 架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.1.</span> <span class="toc-text">功能特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-number">6.4.2.</span> <span class="toc-text">模块组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84"><span class="toc-number">6.5.</span> <span class="toc-text">Netty 工作原理架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Sentinel/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Sentinel/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.161Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Replication/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Replication/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.155Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关键字"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字">关键字</a><time datetime="2021-12-18T14:44:09.151Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>