<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>垃圾回收与内存分配策略 | 暮成雪的博客</title><meta name="keywords" content="GC"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM 内存模型一共包括三个部分：堆 ( Java代码可及的 Java堆 和 JVM自身使用的方法区)、栈 ( 服务Java方法的虚拟机栈 和 服务Native方法的本地方法栈 ) 和 保证程序在多线程环境下能够连续执行的程序计数器。特别地，java堆是进行垃圾回收的主要区域，故其也被称为GC堆；而方法区也有一个不太严谨的表述，就是永久代PermGen或者元空间Metaspace。总的来说，堆 (">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾回收与内存分配策略">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/JVM/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="JVM 内存模型一共包括三个部分：堆 ( Java代码可及的 Java堆 和 JVM自身使用的方法区)、栈 ( 服务Java方法的虚拟机栈 和 服务Native方法的本地方法栈 ) 和 保证程序在多线程环境下能够连续执行的程序计数器。特别地，java堆是进行垃圾回收的主要区域，故其也被称为GC堆；而方法区也有一个不太严谨的表述，就是永久代PermGen或者元空间Metaspace。总的来说，堆 (">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:25.784Z">
<meta property="article:modified_time" content="2022-02-05T05:25:18.998Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="GC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/JVM/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '垃圾回收与内存分配策略',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-05 05:25:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">垃圾回收与内存分配策略</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:25.784Z" title="发表于 2021-12-18 14:42:25">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-05T05:25:18.998Z" title="更新于 2022-02-05 05:25:18">2022-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="垃圾回收与内存分配策略"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/JVM/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/JVM/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>JVM 内存模型一共包括三个部分：堆 ( Java代码可及的 Java堆 和 JVM自身使用的方法区)、栈 ( 服务Java方法的虚拟机栈 和 服务Native方法的本地方法栈 ) 和 保证程序在多线程环境下能够连续执行的程序计数器。特别地，java堆是进行垃圾回收的主要区域，故其也被称为GC堆；而方法区也有一个不太严谨的表述，就是永久代PermGen或者元空间Metaspace。总的来说，堆 (包括Java堆 和 方法区)是 垃圾回收的主要对象，特别是Java堆。<br>Java技术体系中所提倡的 <strong>自动内存管理</strong> 最终可以归结为自动化地解决了两个问题：<strong>给对象分配内存</strong> 以及<strong>回收分配给对象的内存</strong>。另外， 垃圾回收机制是Java语言一个显著的特点，其可以有效的防止内存泄露、保证内存的有效使用，从而使得Java程序员在编写程序的时候不再需要考虑内存管理问题。Java 垃圾回收机制要考虑的问题很复杂，主要有三个核心问题，包括：</p>
<ul>
<li><strong>哪些些内存需要回收？</strong>(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)</li>
<li><strong>什么时候回收？</strong> （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）</li>
<li><strong>如何回收？</strong>(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)</li>
</ul>
<h1 id="一、如何确定一个对象是否可以被回收"><a href="#一、如何确定一个对象是否可以被回收" class="headerlink" title="一、如何确定一个对象是否可以被回收"></a>一、如何确定一个对象是否可以被回收</h1><h2 id="1-引用计数算法：判断对象的引用数量"><a href="#1-引用计数算法：判断对象的引用数量" class="headerlink" title="1 引用计数算法：判断对象的引用数量"></a>1 引用计数算法：判断对象的引用数量</h2><p>引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收。</p>
<p>引用计数算法是垃圾收集器中的<strong>早期策略</strong>。在这种方法中，<strong>堆中的每个对象实例都有一个引用计数</strong>。当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，<strong>当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。任何引用计数为0的对象实例可以被当作垃圾收集</strong>。</p>
<p>引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其<strong>很难解决对象之间相互循环引用的问题</strong>。如下面的程序和示意图所示，对象objA和objB之间的引用计数永远不可能为 0，那么这两个对象就永远不能被回收。</p>
<p><img src="https://img-blog.csdn.net/20170505173602440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 占点内存，以便GC日志观看</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里发生GC， objA 和 objB能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs</span></span><br><span class="line"></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(<span class="number">25.241</span>-b07)</span> <span class="keyword">for</span> windows-amd64 <span class="title">JRE</span> <span class="params">(<span class="number">1.8</span><span class="number">.0_241</span>-b07)</span>, built on Dec 11 2019 10:21:40 by &quot;rejava&quot; with MS VC++ 10.0 <span class="params">(VS2010)</span></span></span><br><span class="line"><span class="function">Memory: 4k page, physical 7943832<span class="title">k</span><span class="params">(1957364k free)</span>, swap 15156368<span class="title">k</span><span class="params">(5069784k free)</span></span></span><br><span class="line"><span class="function">CommandLine flags: -XX:InitialHeapSize</span>=<span class="number">127101312</span> -XX:MaxHeapSize=<span class="number">2033620992</span> -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC </span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-14T17:<span class="number">04</span>:<span class="number">08.836</span>+0800: <span class="number">0.516</span>: [GC (System.gc()) [PSYoungGen: 6628K-&gt;696K(36352K)] 6628K-&gt;704K(119808K), <span class="number">0.0028569</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-14T17:<span class="number">04</span>:<span class="number">08.839</span>+0800: <span class="number">0.519</span>: [<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 696K-&gt;0<span class="title">K</span><span class="params">(36352K)</span>] [ParOldGen: 8K-&gt;589<span class="title">K</span><span class="params">(83456K)</span>] 704K-&gt;589<span class="title">K</span><span class="params">(119808K)</span>, [Metaspace: 3076K-&gt;3076<span class="title">K</span><span class="params">(1056768K)</span>], 0.0087240 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 36352K, used 937K [<span class="number">0x00000000d7980000</span>, <span class="number">0x00000000da200000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 31232K, <span class="number">3</span>% used [<span class="number">0x00000000d7980000</span>,<span class="number">0x00000000d7a6a558</span>,<span class="number">0x00000000d9800000</span>)</span><br><span class="line">  from space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d9800000</span>,<span class="number">0x00000000d9800000</span>,<span class="number">0x00000000d9d00000</span>)</span><br><span class="line">  to   space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d9d00000</span>,<span class="number">0x00000000d9d00000</span>,<span class="number">0x00000000da200000</span>)</span><br><span class="line"> ParOldGen       total 83456K, used 589K [<span class="number">0x0000000086c00000</span>, <span class="number">0x000000008bd80000</span>, <span class="number">0x00000000d7980000</span>)</span><br><span class="line">  object space 83456K, <span class="number">0</span>% used [<span class="number">0x0000000086c00000</span>,<span class="number">0x0000000086c936a0</span>,<span class="number">0x000000008bd80000</span>)</span><br><span class="line"> Metaspace       used 3112K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 336<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>上述代码最后面两句将objA和objB赋值为null，也就是说objA和objB指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。 e<strong>den space 31232K,  from space 5120K,   to   space 5120K,</strong></p>
<h2 id="2-可达性分析算法：判断对象的引用链是否可达"><a href="#2-可达性分析算法：判断对象的引用链是否可达" class="headerlink" title="2 可达性分析算法：判断对象的引用链是否可达"></a>2 可达性分析算法：判断对象的引用链是否可达</h2><p>可达性分析算法是<strong>通过判断对象的引用链是否可达</strong>来决定对象是否可以被回收。</p>
<p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，<strong>通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）</strong>。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。</p>
<p><img src="http://static.zybuluo.com/Rico123/q0t6nxkafapyn6yql7benc32/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="img"></p>
<p>在Java中，可作为 <strong>GC Root</strong> 的对象包括以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ul>
<h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a>3 引用</h2><h3 id="1-引用概述"><a href="#1-引用概述" class="headerlink" title="1). 引用概述"></a>1). 引用概述</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p>
<p>为此，在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。</p>
<h3 id="2-引用的种类及其定义"><a href="#2-引用的种类及其定义" class="headerlink" title="2). 引用的种类及其定义"></a>2). 引用的种类及其定义</h3><p><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似<strong>“Object obj = new Object()”</strong>这类引用。 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。可通过设置为null来让GC收集</p>
<p><strong>软引用</strong>用来描述一些还<strong>有用，但并非必需</strong>的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是<strong>没有足够的内存</strong>，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。<strong>可用来实现高速缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">//强引用</span></span><br><span class="line">SoftRef&lt;String&gt; softRef=<span class="keyword">new</span> SoftRef&lt;String&gt; (str);<span class="comment">//软引用</span></span><br></pre></td></tr></table></figure>

<p><strong>弱引用</strong>也是用来<strong>描述非必需对象</strong>的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够</strong>，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了<strong>WeakReference</strong>类来实现弱引用。</p>
<p><strong>虚引用</strong>是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了<strong>PhantomReference</strong>类来实现虚引用。</p>
<p><img src="%5Cimage-20200314232105794.png" alt="image-20200314232105794"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;NormalObject&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;NormalObject&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reference&lt;NormalObject&gt; ref = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((ref = (Reference&lt;NormalObject&gt;)rq.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In queue: &quot;</span> + ((NormalObjectWeakReference)(ref)).name);</span><br><span class="line">                System.out.println(<span class="string">&quot;reference object:&quot;</span> + ref.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;WeakReference&lt;NormalObject&gt;&gt; weakList = <span class="keyword">new</span> ArrayList&lt;WeakReference&lt;NormalObject&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">            weakList.add(<span class="keyword">new</span> NormalObjectWeakReference(<span class="keyword">new</span> NormalObject(<span class="string">&quot;Weak &quot;</span> + i),rq));</span><br><span class="line">            System.out.println(<span class="string">&quot;Created weak:&quot;</span> + weakList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;first time&quot;</span>);</span><br><span class="line">        checkQueue();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC Start&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;second time&quot;</span>);</span><br><span class="line">        checkQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Created weak:test.test0314.GC.NormalObjectWeakReference@1b6d3586</span></span><br><span class="line"><span class="comment">Created weak:test.test0314.GC.NormalObjectWeakReference@4554617c</span></span><br><span class="line"><span class="comment">Created weak:test.test0314.GC.NormalObjectWeakReference@74a14482</span></span><br><span class="line"><span class="comment">first time</span></span><br><span class="line"><span class="comment">GC Start</span></span><br><span class="line"><span class="comment">Finalizing obj Weak 2</span></span><br><span class="line"><span class="comment">Finalizing obj Weak 1</span></span><br><span class="line"><span class="comment">Finalizing obj Weak 0</span></span><br><span class="line"><span class="comment">second time</span></span><br><span class="line"><span class="comment">In queue: Weak 2</span></span><br><span class="line"><span class="comment">reference object:null</span></span><br><span class="line"><span class="comment">In queue: Weak 1</span></span><br><span class="line"><span class="comment">reference object:null</span></span><br><span class="line"><span class="comment">In queue: Weak 0</span></span><br><span class="line"><span class="comment">reference object:null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3). 方法区的回收"></a>3). 方法区的回收</h3><p>方法区的内存回收目标主要是针对 常量池的回收 和 对类型的卸载。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
</ul>
<ul>
<li>加载该类的ClassLoader已经被回收；</li>
</ul>
<ul>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h2 id="4-生存还是死亡"><a href="#4-生存还是死亡" class="headerlink" title="4 生存还是死亡"></a>4 生存还是死亡</h2><p>在进行过可达性分析后的对象也不一定是非死不可的，要真正宣判一个对象死亡要经历两次标记过程：</p>
<ul>
<li><p>对象经历可达性分析后没有与GC Roots相连接的引用链，则进行一次标记和筛选。（筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法或该方法已被虚拟机执行过则没必要进行finalize方法）</p>
</li>
<li><p>在上述筛选中，对象被判断为有必要执行finalize方法，则将对象放入<strong>F-Queue</strong> 队列中，并在稍后由虚拟机自动建立的，低优先级的<strong>Finalizer线程</strong>去执行对象的finalize()方法。这里是“执行该方法”，<strong>虚拟机并不保证该方法运行结束</strong>。稍后虚拟机GC对F-Queue进行第二次标记，对象唯一能逃脱被回收这种命运的办法是在执行finalize方法时和任意一个引用链上的对象关联即可，这时在进行第二次标记时会将对象重“即将回收的集合”中移除，对象获得新生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.对象可以在GC时自救</span></span><br><span class="line"><span class="comment">2.自救的办法只有一次，因为一个finalize方法最多只能被调用一次</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes,I am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed !&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize优先级很低，所以延迟0.5s以等待它；</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面这段代码再执行一遍，验证对象是不是可以成功</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">finalize method executed !</span></span><br><span class="line"><span class="comment">yes,I am still alive :)</span></span><br><span class="line"><span class="comment">no, i am dead :(</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>并不鼓励使用这种办法来拯救对象，它的运行代价高昂，不确定性大，无法保证顺序；</li>
<li><strong>finalize方法能做的所有工作，try-finally也可以做的更好，更及时</strong>，所以希望忘记这个方法的存在</li>
</ul>
</li>
</ul>
<h1 id="二-垃圾收集算法"><a href="#二-垃圾收集算法" class="headerlink" title="二. 垃圾收集算法"></a>二. 垃圾收集算法</h1><h2 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1 标记-清除算法"></a><strong>1 标记-清除算法</strong></h2><p>标记-清除算法分为<strong>标记和清除</strong>两个阶段。<strong>该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收</strong>，如下图所示。</p>
<p><img src="http://static.zybuluo.com/Rico123/vmdnj50kic23uptbswo9dqnw/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg" alt="img"></p>
<p>标记-清除算法的主要<strong>不足</strong>有两个：</p>
<ul>
<li><p><strong>效率问题</strong>：标记和清除两个过程的效率都不高;</p>
</li>
<li><p><strong>空间问题</strong>：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生<strong>大量不连续的内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br> <img src="http://static.zybuluo.com/Rico123/mkqv5cf4vg8v72wvxtz0abwz/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95" alt="img"></p>
</li>
</ul>
<h2 id="2-标记-复制算法-新生代"><a href="#2-标记-复制算法-新生代" class="headerlink" title="2 标记-复制算法(新生代)"></a>2 标记-复制算法(新生代)</h2><p><u>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</u>这种算法<strong>适用于对象存活率低的场景</strong>，比如<strong>新生代</strong>。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。该算法示意图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-905e8f43500133c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/719/format/webp" alt="img"></p>
<p>事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 <strong>eden 空间、from 空间、to 空间</strong> 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中 (假设是 to)，正在使用的 survivor 空间 (假设是 from) 中的年轻对象也会被复制到 to 空间中 (大对象，或者老年对象会直接进入老年带，如果 to 空间已满，则对象也会直接进入老年代)。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。</p>
<p>实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 (如下图所示)，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 <strong>8:1</strong>，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。</p>
<p><strong>新生代占1/3的堆空间，老年代占2/3的堆空间。</strong></p>
<p><img src="http://static.zybuluo.com/Rico123/pml3jw51zgc8mqffpwt6793t/heap.bmp" alt="img"></p>
<h2 id="3-标记-整理算法-老年代"><a href="#3-标记-整理算法-老年代" class="headerlink" title="3 标记-整理算法(老年代)"></a>3 标记-整理算法(老年代)</h2><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法<strong>适用于对象存活率高的场景（老年代</strong>），其作用原理如下图所示。<br><img src="http://static.zybuluo.com/Rico123/yn5j5ojk6mz9axjutk4hogxq/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%951.jpg" alt="img"></p>
<p><strong>标记整理算法与标记清除算法最显著的区别</strong>是：<strong>标记清除算法不进行对象的移动</strong>，并且仅对不存活的对象进行处理；而<strong>标记整理算法会将所有的存活对象移动</strong>到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示意图如下：</p>
<p><img src="http://static.zybuluo.com/Rico123/b26me40cjhiqkeb2vl6jb807/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记整理算法示意图.png-14.2kB"></p>
<h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4 分代收集算法"></a>4 分代收集算法</h2><p>对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：<strong>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率</strong>。<u>当代商用虚拟机使用的都是分代收集算法</u>：<strong>新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法</strong>。Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：</p>
<p> <img src="http://static.zybuluo.com/Rico123/bqgcx5anvacebj1yxpaufk0x/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%80%BB.jpg" alt="img"></p>
<h3 id="1-新生代（Young-Generation）"><a href="#1-新生代（Young-Generation）" class="headerlink" title="1). 新生代（Young Generation）"></a>1). 新生代（Young Generation）</h3><p>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。<strong>新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区</strong>，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次<strong>FullGC，也就是新生代、老年代都进行回收</strong>。注意，<strong>新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高</strong>，不一定等 Eden区满了才触发。</p>
<h3 id="2-老年代（Old-Generation）"><a href="#2-老年代（Old-Generation）" class="headerlink" title="2). 老年代（Old Generation）"></a>2). 老年代（Old Generation）</h3><p>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，<strong>老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低</strong>。</p>
<h3 id="3-永久代（Permanent-Generation）"><a href="#3-永久代（Permanent-Generation）" class="headerlink" title="3). 永久代（Permanent Generation）"></a>3). 永久代（Permanent Generation）</h3><p>永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</p>
<h3 id="4-Minor-GC-和-Full-GC"><a href="#4-Minor-GC-和-Full-GC" class="headerlink" title="4). Minor GC 和 Full GC"></a>4). Minor GC 和 Full GC</h3><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和 Full GC。</p>
<p><strong>Minor GC</strong>：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</p>
<p><strong>Full GC</strong>：也叫 Major GC，<strong>对整个堆进行回收，包括新生代和老年代</strong>。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p>
<blockquote>
<p>对于Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。而Full GC则相对复杂，因此本节我们主要介绍Full GC的触发条件。</p>
<h4 id="1-调用System-gc"><a href="#1-调用System-gc" class="headerlink" title="1 调用System.gc()"></a>1 调用System.gc()</h4><p>此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI调用System.gc()。</p>
<h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2 老年代空间不足"></a>2 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代<code>、</code>长期存活的对象进入老年代<code>等，当执行Full GC后空间仍然不足，则抛出如下错误： </code>Java.lang.OutOfMemoryError: Java heap space`为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3 空间分配担保失败"></a>3 空间分配担保失败</h4><p>前文介绍过，使用复制算法的Minor GC需要老年代的内存空间作担保，如果出现了<code>HandlePromotionFailure</code>担保失败，则会触发Full GC。</p>
<h4 id="4-JDK-1-7及以前的永久代空间不足"><a href="#4-JDK-1-7及以前的永久代空间不足" class="headerlink" title="4 JDK 1.7及以前的永久代空间不足"></a>4 JDK 1.7及以前的永久代空间不足</h4><p>在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息： <code>java.lang.OutOfMemoryError: PermGen space</code> 为避免PermGen占满造成Full GC现象，可采用的方法为增大PermGen空间或转为使用CMS GC。</p>
<p>在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种Full GC触发的可能性。</p>
<h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5 Concurrent Mode Failure"></a>5 Concurrent Mode Failure</h4><p>执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报<code>Concurrent Mode Failure</code>错误，并触发Full GC。</p>
</blockquote>
<h1 id="三-垃圾收集器"><a href="#三-垃圾收集器" class="headerlink" title="三. 垃圾收集器"></a>三. 垃圾收集器</h1><p>在介绍垃圾收集器之前，需要先清楚<strong>Stop-the-World</strong>。Stop-the-world意味着 <strong>JVM由于要执行GC而停止了应用程序的执行</strong>，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，<strong>GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。</strong></p>
<p>如果说垃圾收集算法是内存回收的方法论，那么<strong>垃圾收集器就是内存回收的具体实现</strong>。就像没有最好的算法一样，垃圾收集器也没有最好，只有最合适。我们能做的就是根据具体的应用场景选择最合适的垃圾收集器。</p>
<p>下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。<strong>不同收集器之间的连线表示它们可以搭配使用。</strong></p>
<p><img src="http://static.zybuluo.com/Rico123/9hswys8w1pqy0ch06vmlbqi2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="img"></p>
<p><strong>Serial收集器（复制算法)</strong>: 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</p>
<p><strong>Serial Old收集器 (标记-整理算法)</strong>: 老年代单线程收集器，Serial收集器的老年代版本；</p>
<p><strong>ParNew收集器 (复制算法):</strong> 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</p>
<p><strong>Parallel Scavenge收集器 (复制算法):</strong> 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</p>
<p><strong>Parallel Old收集器 (标记-整理算法)：</strong> 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</p>
<p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</strong>： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p>
<p>**G1(Garbage First)收集器 (标记-整理算法)**： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p>
<h2 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1 Serial收集器"></a>1 Serial收集器</h2><p><strong>Serial（串行）收集器</strong>是一个最基本的，发展历史悠久的<strong>单线程串行收集器</strong>，它在<strong>新生代采用复制算法</strong>，<strong>老年代采用标记-整理算法</strong>；但它的<strong>“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（“Stop The World”）</strong>。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。Serial/Serial Old收集器（新生代采用Serial收集器，老年代采用Serial Old收集器）的运行过程如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-683d4748e05b0b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/744/format/webp" alt="img"></p>
<p>当它进行GC工作的时候，虽然会造成Stop-The-World，正如每种算法都有存在的原因，该串行收集器也有存在的原因：<strong>因为简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，没有线程交互的开销，专心做GC，自然可以获得最高的单线程效率</strong>。所以Serial收集器对于运行在<strong>client模式</strong>下的应用是一个很好的选择（到目前为止，它依然是虚拟机运行在client模式下的默认新生代收集器）<br>串行收集器的<strong>缺点很明显</strong>，虚拟机的开发者当然也是知道这个缺点的，所以一直都在缩减<strong>Stop The World的时间</strong>。在后续的垃圾收集器设计中停顿时间在不断缩短（但是仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">添加该参数来显式的使用串行垃圾收集器:</span><br><span class="line"><span class="string">&quot;-XX:+UseSerialGC&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2 ParNew收集器"></a>2 ParNew收集器</h2><p><strong>ParNew收集器其实就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数(例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-22d4965494e8b025.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/743/format/webp" alt="img"></p>
<p>ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，<strong>除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作</strong>。CMS收集器是一个被认为具有划时代意义的并发收集器，因此如果有一个垃圾收集器能和它一起搭配使用让其更加完美，那这个收集器必然也是一个不可或缺的部分了。</p>
<p>ParNew 收集器在单CPU的环境中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。在多CPU环境下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。<strong>它默认开启的收集线程数与CPU的数量相同</strong>，在CPU非常多的情况下可使用-XX:ParallerGCThreads参数设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">指定使用CMS后，会默认使用ParNew作为新生代收集:</span><br><span class="line"><span class="string">&quot;-XX:+UseConcMarkSweepGC&quot;</span></span><br><span class="line">强制指定使用ParNew:   </span><br><span class="line"><span class="string">&quot;-XX:+UseParNewGC&quot;</span></span><br><span class="line">指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同：</span><br><span class="line"><span class="string">&quot;-XX:ParallelGCThreads&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3 Parallel Scavenge收集器"></a>3 Parallel Scavenge收集器</h2><p><strong>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</strong>。它的特点是它的关注点与其他收集器不同，<strong>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间</strong>，<strong>而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）</strong>，也即CPU用于运行用户代码的时间与CPU总消耗时间的比值，即<strong>吞吐量=运行用户代码时间/（运行用户代码时间 + 垃圾收集时间）</strong>。</p>
<p>停顿时间越短就越适合需要与<strong>用户交互</strong>的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率利用CPU时间，尽快完成程序的运算任务，主要适合在<strong>后台运算</strong>而不需要太多交互的任务。</p>
<p>除以上参数外，Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为**GC自适应的调整策略(GC Ergonomics)**。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
<p> Parallel Scavenge收集器提供了<strong>两个参数用于精确控制吞吐量</strong>，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="string">&quot;-XX:MaxGCPauseMillis&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>控制最大垃圾收集停顿时间，大于0的毫秒数；</li>
<li>MaxGCPauseMillis设置得稍小，停顿时间可能会缩短（通过把新生代设置的更小实现），但也可能会使得吞吐量下降；因为可能导致垃圾收集发生得更频繁；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="string">&quot;-XX:GCTimeRatio&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置垃圾收集时间占总时间的比率，0 &lt; n &lt; 100的整数；<br>GCTimeRatio相当于设置吞吐量大小；<br>垃圾收集执行时间占应用程序执行时间的比例的计算方法是： 1 / (1 + n) 。<br>例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间的5% = 1/(1+19)；默认值是1% = 1/(1+99)，即n=99；</p>
</blockquote>
<h2 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4 Serial Old收集器"></a>4 Serial Old收集器</h2><p>Serial Old收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</p>
<ul>
<li>在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<h2 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5 Parallel Old收集器"></a>5 Parallel Old收集器</h2><p><strong>Parallel Old收集器时Parallel Scavenge收集器的老年代版本</strong>，使用<strong>多线程和“标记-整理”算法</strong>。这个收集器在JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力。<br>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作过程如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-ad661b0c06987704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/742/format/webp" alt="img"></p>
<h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6 CMS收集器"></a>6 CMS收集器</h2><p><strong>CMS（Concurrent Mark Sweep）</strong>收集器是一种以<strong>获取最短回收停顿时间为目标</strong>的收集器。目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。<br> CMS收集器时基于<strong>“标记-清除”算法</strong>实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记(CMS initial mark)<strong>：`仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“</strong>Stop The World</strong>”。</li>
<li>**并发标记(CMS concurrent mark)**：`GC Roots Tracing的过程</li>
<li>**重新标记(CMS remark)**：`为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li>
<li><strong>并发清除(CMS concurrent sweep)<strong>： 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，</strong>CMS收集器的内存回收过程是与用户线程一起并发执行的</strong>。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-13e02fe3f1e4090c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/793/format/webp" alt="img"></p>
<p><strong>优点</strong></p>
<ul>
<li>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：<strong>并发收集、低停顿</strong>，`因此CMS收集器也被称为<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector）。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li> <strong>对CPU资源非常敏感</strong>  其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。<strong>CMS默认启动的回收线程数是（CPU数量+3）/4</strong>，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li>
<li> <strong>无法处理浮动垃圾</strong>（Floating Garbage） 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好<strong>留待下一次GC时再清理掉</strong>。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
<li><strong>标记-清除算法导致的空间碎片</strong>  CMS是一款基于“<strong>标记-清除</strong>”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li>
</ul>
<h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7 G1收集器"></a>7 G1收集器</h2><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li> <strong>并行与并发：</strong> G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li> <strong>分代收集：</strong> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的手机效果。</li>
<li> <strong>空间整合：</strong> 与CMS的“标记-清理”算法不同，G1从<strong>整体</strong>来看是基于<strong>“标记-整理”</strong>算法实现的收集器，从<strong>局部</strong>（两个Region之间）上来看是基于<strong>“复制”算法</strong>实现的，但无论如何，这两种算法都意味着G1运作期间<strong>不会产生内存空间碎片</strong>，收集后能提供<strong>规整的可用内存</strong>。这种特性有利于程序长时间运行，分配<strong>大对象</strong>时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li> <strong>可预测的停顿：</strong> 这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能<strong>建立可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。<u>G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合</u>。</p>
<p><img src="%5Cimage-20200314211421535.png" alt="image-20200314211421535"></p>
<h3 id="建立可预测的时间模型"><a href="#建立可预测的时间模型" class="headerlink" title="建立可预测的时间模型"></a>建立可预测的时间模型</h3><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（<strong>回收所获得的空间大小以及回收所需时间的经验值</strong>），在后台维护一个优先列表，每次根据允许的收集时间，<strong>优先回收价值最大的Region</strong>（这也就是<strong>Garbage-First</strong>名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h3 id="避免全堆扫描——Remembered-Set"><a href="#避免全堆扫描——Remembered-Set" class="headerlink" title="避免全堆扫描——Remembered Set"></a>避免全堆扫描——Remembered Set</h3><p>G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。</p>
<p>为了避免全堆扫描的发生，虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li> <strong>初始标记（Initial Marking）</strong>` 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。</li>
<li> <strong>并发标记（Concurrent Marking）</strong>` 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li>
<li><strong>最终标记（Final Marking）</strong> 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li>
<li> <strong>筛选回收（Live Data Counting and Evacuation）</strong>` 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-172f25b53cae3a61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/793/format/webp" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>Both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<h1 id="四、内存分配策略"><a href="#四、内存分配策略" class="headerlink" title="四、内存分配策略"></a>四、内存分配策略</h1><p>Java的自动内存管理最终可以归结为自动化地解决了两个问题：</p>
<ul>
<li><strong>给对象分配内存</strong></li>
<li><strong>回收分配给对象的内存</strong></li>
</ul>
<p>对象的内存分配通常是在堆上分配（除此以外还有可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。至于内存回收策略，在上文已经描述得很详尽了。</p>
<p>介绍内存分配的策略。</p>
<h2 id="4-1-对象优先在Eden区分配"><a href="#4-1-对象优先在Eden区分配" class="headerlink" title="4.1 对象优先在Eden区分配"></a>4.1 对象优先在Eden区分配</h2><p>大多数情况下，对象在新生代的Eden区中分配。<strong>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</strong></p>
<h2 id="4-2-大对象直接进入老年代"><a href="#4-2-大对象直接进入老年代" class="headerlink" title="4.2 大对象直接进入老年代"></a>4.2 大对象直接进入老年代</h2><p>所谓的大对象是指，<strong>需要大量连续内存空间的Java对象</strong>，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的“短命大对象”，写程序时应避免），经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来安置它们。</p>
<p>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法回收内存）。</p>
<h2 id="4-2-长期存活的对象将进入老年代"><a href="#4-2-长期存活的对象将进入老年代" class="headerlink" title="4.2 长期存活的对象将进入老年代"></a>4.2 长期存活的对象将进入老年代</h2><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度<strong>（默认为15岁）</strong>，就将会被晋升到老年代中。<strong>对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置</strong>。</p>
<h2 id="4-3-动态对象年龄判定"><a href="#4-3-动态对象年龄判定" class="headerlink" title="4.3 动态对象年龄判定"></a>4.3 动态对象年龄判定</h2><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h2 id="4-4-空间分配担保"><a href="#4-4-空间分配担保" class="headerlink" title="4.4 空间分配担保"></a>4.4 空间分配担保</h2><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是<strong>有风险</strong>的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
<p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，<strong>老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，</strong>一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的<strong>平均大小值作为经验值</strong>，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>取平均值进行比较其实仍然是一种<strong>动态概率</strong>的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>
<h1 id="五、Java-GC日志查看与分析"><a href="#五、Java-GC日志查看与分析" class="headerlink" title="五、Java GC日志查看与分析"></a>五、Java GC日志查看与分析</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d7bf1827da1">Java GC日志查看与分析</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d7bf1827da1">Java GC日志查看与分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/71216049">图解Java 垃圾回收机制</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dcbb42ab9f4c">Java垃圾收集器</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/JVM/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">http://muchengxue.github.io/2021/12/18/Java/JVM/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GC/">GC</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6%E4%B9%8BThreadPoolExecutor/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关键字</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM类加载机制</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">一、如何确定一个对象是否可以被回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E6%95%B0%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1 引用计数算法：判断对象的引用数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E9%93%BE%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BE%BE"><span class="toc-number">1.2.</span> <span class="toc-text">2 可达性分析算法：判断对象的引用链是否可达</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">1). 引用概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%9A%84%E7%A7%8D%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">2). 引用的种类及其定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">3). 方法区的回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1"><span class="toc-number">1.4.</span> <span class="toc-text">4 生存还是死亡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二. 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">1 标记-清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95-%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2 标记-复制算法(新生代)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95-%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">2.3.</span> <span class="toc-text">3 标记-整理算法(老年代)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">4 分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%88Young-Generation%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">1). 新生代（Young Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">2). 老年代（Old Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88Permanent-Generation%EF%BC%89"><span class="toc-number">2.4.3.</span> <span class="toc-text">3). 永久代（Permanent Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Minor-GC-%E5%92%8C-Full-GC"><span class="toc-number">2.4.4.</span> <span class="toc-text">4). Minor GC 和 Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B0%83%E7%94%A8System-gc"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">1 调用System.gc()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">2 老年代空间不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E5%A4%B1%E8%B4%A5"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">3 空间分配担保失败</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-JDK-1-7%E5%8F%8A%E4%BB%A5%E5%89%8D%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">4 JDK 1.7及以前的永久代空间不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Concurrent-Mode-Failure"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">5 Concurrent Mode Failure</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">三. 垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1 Serial收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2 ParNew收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3 Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">4 Serial Old收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">5 Parallel Old收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">6 CMS收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.</span> <span class="toc-text">7 G1收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.1.</span> <span class="toc-text">建立可预测的时间模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%85%A8%E5%A0%86%E6%89%AB%E6%8F%8F%E2%80%94%E2%80%94Remembered-Set"><span class="toc-number">3.7.2.</span> <span class="toc-text">避免全堆扫描——Remembered Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">4.</span> <span class="toc-text">四、内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 对象优先在Eden区分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 大对象直接进入老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">4.3.</span> <span class="toc-text">4.2 长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="toc-number">4.4.</span> <span class="toc-text">4.3 动态对象年龄判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">4.5.</span> <span class="toc-text">4.4 空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Java-GC%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">五、Java GC日志查看与分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS的设计思路"/></a><div class="content"><a class="title" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路">AQS的设计思路</a><time datetime="2022-02-03T13:10:28.437Z" title="发表于 2022-02-03 13:10:28">2022-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="float的范围和精度"/></a><div class="content"><a class="title" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度">float的范围和精度</a><time datetime="2022-01-21T14:18:25.869Z" title="发表于 2022-01-21 14:18:25">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="随想1"/></a><div class="content"><a class="title" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1">随想1</a><time datetime="2021-12-18T16:15:22.363Z" title="发表于 2021-12-18 16:15:22">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 吊打面试官"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官">Redis 吊打面试官</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis中的事务"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务">Redis中的事务</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>