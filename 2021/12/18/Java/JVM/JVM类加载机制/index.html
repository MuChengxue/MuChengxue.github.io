<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM类加载机制 | 暮成雪的博客</title><meta name="keywords" content="关键字"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、类加载机制概述我们知道，一个.java文件在编译后会形成相应的一个或多个Class文件（若一个类中含有内部类，则编译后会产生多个Class文件），但这些Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。事实上，虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的 类加载机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM类加载机制">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="一、类加载机制概述我们知道，一个.java文件在编译后会形成相应的一个或多个Class文件（若一个类中含有内部类，则编译后会产生多个Class文件），但这些Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。事实上，虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的 类加载机制。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:25.748Z">
<meta property="article:modified_time" content="2020-03-12T16:48:28.000Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="关键字">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM类加载机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-03-12 16:48:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM类加载机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:25.748Z" title="发表于 2021-12-18 14:42:25">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-03-12T16:48:28.000Z" title="更新于 2020-03-12 16:48:28">2020-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM类加载机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://images2015.cnblogs.com/blog/731716/201606/731716-20160630221300812-120869582.png" alt="img"></h3><h1 id="一、类加载机制概述"><a href="#一、类加载机制概述" class="headerlink" title="一、类加载机制概述"></a>一、类加载机制概述</h1><p>我们知道，一个.java文件在编译后会形成相应的一个或多个Class文件（若一个类中含有内部类，则编译后会产生多个Class文件），但这些Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。事实上，<strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的 类加载机制</strong>。　　</p>
<p>与那些在编译时需要进行连接工作的语言不同，在<strong>Java语言里面，类型的加载和连接都是在程序运行期间完成</strong>，这样会在类加载时稍微增加一些性能开销，但是却能为Java应用程序提供高度的灵活性，<strong>Java中天生可以动态扩展的语言特性多态就是依赖运行期动态加载和动态链接这个特点实现的</strong>。例如，如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现。这种组装应用程序的方式广泛应用于Java程序之中。</p>
<p>那么，对于Java的类加载会产生如下问题:</p>
<ul>
<li>虚拟机什么时候才会加载Class文件并初始化类呢？<strong>（类加载和初始化时机）</strong></li>
</ul>
<ul>
<li>虚拟机如何加载一个Class文件呢？（Java<strong>类加载的方式</strong>：类加载器、双亲委派机制）</li>
</ul>
<ul>
<li>虚拟机加载一个Class文件要经历那些具体的步骤呢？（<strong>类加载过程/步骤</strong>）</li>
</ul>
<h1 id="二、类加载的时机"><a href="#二、类加载的时机" class="headerlink" title="二、类加载的时机"></a>二、类加载的时机</h1><p>Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)<strong>七个阶段。其中</strong>准备、验证、解析3个部分统称为连接（Linking）</strong>，如图所示：</p>
<p><img src="http://static.zybuluo.com/Rico123/ojhhtids41ivtuowfj74mkb2/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" alt="img">　　</p>
<p><strong>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定</strong>的，类的加载过程必须按照这种顺序按部就班地开始，而<strong>解析阶段则不一定</strong>：<u>它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）</u>。以下陈述的内容都已HotSpot为基准。特别需要注意的是，类的加载过程<strong>必须按照这种顺序按部就班地“开始”</strong>，<strong>而不是按部就班的“进行”或“完成</strong>”，因为这些阶段通常都是相互交叉地混合式进行的，也就是说通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p>
<h2 id="1、类加载时机"><a href="#1、类加载时机" class="headerlink" title="1、类加载时机"></a>1、类加载时机</h2><p>什么情况下虚拟机需要开始加载一个类呢？虚拟机规范中<strong>并没有对此进行强制约束</strong>，这点可以交给虚拟机的具体实现来自由把握。</p>
<h2 id="2、类初始化时机"><a href="#2、类初始化时机" class="headerlink" title="2、类初始化时机"></a>2、类初始化时机</h2><p>那么，什么情况下虚拟机需要开始初始化一个类呢？这在虚拟机规范中是有严格规定的，虚拟机规范指明 有且只有 五种情况必须立即对类进行初始化（而这一过程自然发生在加载、验证、准备之后）：</p>
<p><strong>1) 遇到new、getstatic、putstatic或invokestatic这四条字节码指令</strong>（注意，newarray指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，new String[]只会直接触发String[]类的初始化，也就是触发对类[Ljava.lang.String的初始化，而直接不会触发String类的初始化）时，<strong>如果类没有进行过初始化</strong>，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：</p>
<blockquote>
<ul>
<li>使用new关键字实例化对象的时候；</li>
<li>读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；</li>
<li>调用一个类的静态方法的时候。</li>
</ul>
</blockquote>
<p><strong>2) 使用java.lang.reflect包的方法对类进行反射调用的时候</strong>，如果类没有进行过初始化，则需要先触发其初始化。</p>
<p><strong>3) 当初始化一个类的时候</strong>，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p><strong>4) 当虚拟机启动时</strong>，用户需要指定一个要执行的主类（<strong>包含main()方法的那个类</strong>），虚拟机会先初始化这个主类。</p>
<p><strong>5) 当使用jdk1.7动态语言支持</strong>时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p>
<p>注意，对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个<u>很强烈的限定语</u>：<strong>“有且只有”</strong>，这五种场景中的行为称为<strong>对一个类进行 主动引用</strong>。除此之外，所有引用类的方式，都不会触发初始化，称为 <strong>被动引用</strong>。</p>
<p><strong>需要特别指出的是，类的实例化和类的初始化是两个完全不同的概念：</strong></p>
<ul>
<li>类的实例化是指创建一个类的实例(对象)的过程；</li>
<li>类的初始化是指为类各个成员赋初始值的过程，是类生命周期中的一个阶段。</li>
</ul>
<h2 id="3、被动引用经典场景"><a href="#3、被动引用经典场景" class="headerlink" title="3、被动引用经典场景"></a>3、被动引用经典场景</h2><p><strong>1)、通过子类引用父类的静态字段，不会导致子类初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SSClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SClass</span> <span class="keyword">extends</span> <span class="title">SSClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init SClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init SubClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        SSClass</span></span><br><span class="line"><span class="comment">        SClass init!</span></span><br><span class="line"><span class="comment">        123     </span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>对于静态字段，只有直接定义这个字段的类才会被初始化</strong>，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。在本例中，由于value字段是在类SClass中定义的，因此该类会被初始化；此外，在初始化类SClass时，虚拟机会发现其父类SSClass还未被初始化，因此虚拟机将先初始化父类SSClass，然后初始化子类SClass，而SubClass始终不会被初始化。至于是否要触发子类的加载和验证，在虚拟机中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数观察到此操作会导致子类的加载。</p>
<p><strong>2)、通过数组定义来引用类，不会触发此类的初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SClass[] sca = <span class="keyword">new</span> SClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述案例运行之后并没有任何输出，说明<strong>虚拟机并没有初始化类SClass</strong>。但是，这段代码触发了另外一个名为**[Lcn.edu.tju.rico.SClass的类的初始化<strong>。从类名称我们可以看出，这个类代表了元素类型为SClass的一维数组，它是由</strong>虚拟机自动生成的，直接继承于Object的子类，创建动作由字节码指令newarray触发**。<br><strong>3)、常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String CONSTANT = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(ConstClass.CONSTANT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        hello world</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>上述代码运行之后，只输出 “hello world”，这是因为虽然在Java源码中引用了ConstClass类中的常量CONSTANT，但是编译阶段将此常量的值“hello world”存储到了NotInitialization常量池中，对常量ConstClass.CONSTANT的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译为Class文件之后就不存在关系了。</p>
<h1 id="三、类加载过程"><a href="#三、类加载过程" class="headerlink" title="三、类加载过程"></a>三、类加载过程</h1><p><img src="http://static.zybuluo.com/Rico123/ojhhtids41ivtuowfj74mkb2/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" alt="img"></p>
<h2 id="1、加载（Loading）"><a href="#1、加载（Loading）" class="headerlink" title="1、加载（Loading）"></a>1、加载（Loading）</h2><p>在加载阶段（可以参考java.lang.ClassLoader的<strong>loadClass</strong>()方法），虚拟机需要完成以下三件事情：</p>
<blockquote>
<p>(1). <strong>通过一个类的全限定名来获取定义此类的二进制字节流</strong>（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；由类加载器完成的，具体涉及JVM预定义的类加载器、双亲委派模型等内容，不再赘述</p>
<p>(2). 将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong>；</p>
<p>(3). 在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的<strong>java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</strong></p>
</blockquote>
<p><strong>加载阶段和连接阶段（Linking）</strong>的部分内容（如一部分字节码文件格式验证动作）是<strong>交叉进行</strong>的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h2 id="2、验证（Verification）"><a href="#2、验证（Verification）" class="headerlink" title="2、验证（Verification）"></a>2、验证（Verification）</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成4个阶段的检验动作：</p>
<blockquote>
<p>文件格式验证：验证字节流是否符合Class文件格式的规范(例如，是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型)</p>
<p>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求(例如：这个类是否有父类，除了java.lang.Object之外)；</p>
<p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的;</p>
<p>符号引用验证：确保解析动作能正确执行。</p>
</blockquote>
<p><strong>验证阶段是非常重要的，但不是必须的</strong>，它对程序运行期没有影响。如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="3、准备-Preparation"><a href="#3、准备-Preparation" class="headerlink" title="3、准备(Preparation)"></a>3、准备(Preparation)</h2><p>准备阶段是正式为<strong>类变量(static 成员变量)分配内存并设置类变量初始值（零值）</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。<strong>这时候进行内存分配的仅包括类变量，而不包括实例变量</strong>，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那么，<strong>变量value在准备阶段过后的值为0而不是123</strong>。因为这时候尚未开始执行任何java方法，而<strong>把value赋值为123的putstatic指令是程序被编译后，存放于类构造器方法<clinit>()之中，所以把value赋值为123的动作将在初始化阶段才会执行</strong>。至于“特殊情况”是指：当类字段的字段属性是<strong>ConstantValue</strong>时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0。　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/3311132-ecdb78877aa22438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/521/format/webp" alt="img"></p>
<h2 id="4、解析-Resolution"><a href="#4、解析-Resolution" class="headerlink" title="4、解析(Resolution)"></a>4、解析(Resolution)</h2><p>解析阶段是把常量池内的符号引用替换成直接引用的过程，符号引用就是Class文件中的CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量。下面我们看符号引用和直接引用的定义。<br> **<code>符号引用（Symbolic References）</code>**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要可以唯一定位到目标即可。符号引用于内存布局无关，所以所引用的对象不一定需要已经加载到内存中。各种虚拟机实现的内存布局可以不同，但是接受的符号引用必须是一致的，因为符号引用的字面量形式已经明确定义在Class文件格式中。<br> **<code>直接引用（Direct References）</code>**：直接引用时直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机上翻译出来的直接引用一般不会相同。如果有了直接引用，那么它一定已经存在于内存中了。<br> 以下Java虚拟机指令会将符号引用指向运行时常量池，执行任意一条指令都需要对它的符号引用进行解析：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-7bb16b76dfa6d588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1054/format/webp" alt="img"><br> 对同一个符号进行多次解析请求是很常见的，除了invokedynamic指令以外，虚拟机基本都会对第一次解析的结果进行缓存，后面再遇到时，直接引用，从而避免解析动作重复。<br> 对于invokedynamic指令，上面规则不成立。当遇到前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令同样生效。这是由invokedynamic指令的语义决定的，它本来就是用于动态语言支持的，也就是必须等到程序实际运行这条指令的时候，解析动作才会执行。其它的命令都是“静态”的，可以再刚刚完成记载阶段，还没有开始执行代码时就解析。</p>
<p>下面来看几种基本的解析：</p>
<h3 id="类与接口的解析："><a href="#类与接口的解析：" class="headerlink" title="类与接口的解析："></a>类与接口的解析：</h3><p>假设Java虚拟机在类D的方法体中引用了类N或者接口C，那么会执行下面步骤：</p>
<ul>
<li>如果C不是数组类型，D的定义类加载器被用来创建类N或者接口C。加载过程中出现任何异常，可以被认为是类和接口解析失败。</li>
<li>如果C是数组类型，并且它的元素类型是引用类型。那么表示元素类型的类或接口的符号引用会通过递归调用来解析。</li>
<li>检查C的访问权限，如果D对C没有访问权限，则会抛出java.lang.IllegalAccessError异常。</li>
</ul>
<h3 id="字段解析："><a href="#字段解析：" class="headerlink" title="字段解析："></a><strong>字段解析</strong>：</h3><p> 要解析一个未被解析过的字段符号引用，首先会对字段表内class_index项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，这边记不清的可以继续回顾<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/68520593b999">Java class文件结构</a>,也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段解析失败。如果解析完成，那将<strong>这个字段所属的类或者接口</strong>用C表示，虚拟机规范要求按照如下步骤对Ｃ进行后续字段的搜索。</p>
<p>1 . 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则直接返回这个字段的直接引用，查找结束。<br>2 . 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>3 . 再不然，如果C不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在类中包含<br>了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>4 . 如果都没有，查找失败退出，抛出<code>java.lang.NoSuchFieldError</code>异常。如果返回了引用，还需要检查访问权限，如果没有访问权限，则会抛出<code>java.lang.IllegalAccessError</code>异常。</p>
<p>在实际的实现中，要求可能更严格，如果同一字段名在C的父类和接口中同时出现，编译器可能拒绝编译。</p>
<h3 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a><strong>类方法解析</strong></h3><p>类方法解析也是先对类方法表中的class_index项中索引的方法所属的类或接口的符号引用进行解析。我们依然用C来代表解析出来的类，接下来虚拟机将按照下面步骤对C进行后续的类方法搜索。 </p>
<p>1 . 首先检查方法引用的C是否为类或接口，如果是接口，那么方法引用就会抛出<code>IncompatibleClassChangeError</code>异常<br>2 . 方法引用过程中会检查C和它的父类中是否包含此方法，如果C中确实有一个方法与方法引用的指定名称相同，并且声明是签名多态方法（Signature Polymorphic Method）,那么方法的查找过程就被认为是成功的，所有方法描述符所提到的类也需要解析。对于C来说，没有必要使用方法引用指定的描述符来声明方法。<br>3 . 否则，如果C声明的方法与方法引用拥有同样的名称与描述符，那么方法查找也是成功。<br>4 . 如果C有父类的话，那么按照第2步的方法递归查找C的直接父类。<br>5 . 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在相匹配的方法，说明类C时一个抽象类，查找结束，并且抛出<code>java.lang.AbstractMethodError</code>异常。</p>
<p>6 . 否则，宣告方法失败，并且抛出<code>java.lang.NoSuchMethodError</code>。<br>最后的最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，那么会抛出 <code>java.lang.IllegalAccessError</code>异常。</p>
<h3 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a><strong>接口方法解析</strong></h3><p> 接口方法也需要解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。<br> 1 . 与类方法解析不同，如果在接口方法表中发现class_index对应的索引C是类而不是接口，直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。<br> 2 . 否则，在接口C中查找是否有简单名称和描述符都与目标匹配的方法，如果有则直接返回这个方法的直接引用，查找结束。<br> 3 . 否则，在接口C的父接口中递归查找，直到<code>java.lang.Object</code>类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br> 4 . 否则，宣告方法失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</p>
<p>由于接口的方法默认都是public的，所以不存在访问权限问题，也就基本不会抛出<code>java.lang.IllegalAccessError</code>异常。</p>
<h2 id="5、初始化-Initialization"><a href="#5、初始化-Initialization" class="headerlink" title="5、初始化(Initialization)"></a>5、初始化(Initialization)</h2><p>类初始化阶段是类加载过程的最后一步。在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。</p>
<p><strong>在准备阶段，变量已经赋过一次系统要求的初始值(零值)；而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者更直接地说：初始化阶段是执行类构造器<clinit>()方法的过程。</strong></p>
<ul>
<li><clinit>()方法是由编译器自动收集<strong>类中的所有类变量的赋值动作和静态语句块static{}中的语句合并</strong>产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        System.out.println(i);<span class="comment">//Error：Cannot reference a field before it is defined（非法向前应用）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么注释报错的那行代码，改成下面情形，程序就可以编译通过并可以正常运行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(i);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类构造器<clinit>()与实例构造器<init>()不同，它不需要程序员进行显式调用，虚拟机会保证在子类类构造器<clinit>()执行之前，父类的类构造<clinit>()执行完毕。因此java虚拟机中第一个被执行的<clinit>()方法的类肯定是Object类</p>
</li>
<li><p>由于父类的构造器<clinit>()先执行，也就意味着父类中定义的静态语句块/静态变量的初始化要优先于子类的静态语句块/静态变量的初始化执行。</p>
</li>
<li><p>特别地，类构造器<clinit>()对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生产类构造器<clinit>()。</p>
</li>
<li><p>虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器<clinit>()，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。特别需要注意的是，在这种情形下，<strong>其他线程虽然会被阻塞，但如果执行<clinit>()方法的那条线程退出后，其他线程在唤醒之后不会再次进入/执行<clinit>()方法，因为 在同一个类加载器下，一个类型只会被初始化一次</strong>。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DealLoopTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DealLoopTest...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread()</span><br><span class="line">                        + <span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;      <span class="comment">// 模拟耗时很长的操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;   <span class="comment">// 匿名内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        DealLoopTest...</span></span><br><span class="line"><span class="comment">        Thread[Thread-1,5,main] start</span></span><br><span class="line"><span class="comment">        Thread[Thread-0,5,main] start</span></span><br><span class="line"><span class="comment">        Thread[Thread-1,5,main]init DeadLoopClass</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br><span class="line"><span class="comment">//如上述代码所示，在初始化DeadLoopClass类时，线程Thread-1得到执行并在执行这个类的类构造器&lt;clinit&gt;() 时，由于该方法包含一个死循环，因此久久不能退出。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、Java对象创建时机"><a href="#四、Java对象创建时机" class="headerlink" title="四、Java对象创建时机"></a>四、Java对象创建时机</h1><p><strong>我们知道，一个对象在可以被使用之前必须要被正确地实例化</strong>。在Java代码中，有很多行为可以引起对象的创建，最为直观的一种就是使用<strong>new</strong>关键字来调用一个类的构造函数显式地创建对象，这种方式在Java规范中被称为 : <strong>由执行类实例创建表达式而引起的对象创建</strong>。除此之外，我们还可以使用反射机制(Class类的newInstance方法、使用Constructor类的newInstance方法)、使用Clone方法、使用反序列化等方式创建对象。</p>
<h2 id="1-使用new关键字创建对象"><a href="#1-使用new关键字创建对象" class="headerlink" title="1). 使用new关键字创建对象"></a>1). 使用new关键字创建对象</h2><p>这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们可以调用任意的构造函数（无参的和有参的）去创建对象。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　Student student = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>

<h2 id="2-使用Class类的newInstance方法-反射机制"><a href="#2-使用Class类的newInstance方法-反射机制" class="headerlink" title="2). 使用Class类的newInstance方法(反射机制)"></a>2). 使用Class类的newInstance方法(反射机制)</h2><p>我们也可以通过Java的反射机制使用Class类的newInstance方法来创建对象，事实上，这个newInstance方法调用无参的构造器创建对象，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　Student student2 = (Student)Class.forName(<span class="string">&quot;Student类全限定名&quot;</span>).newInstance();　</span><br><span class="line">或者：</span><br><span class="line">　　Student stu = Student.class.newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="3-使用Constructor类的newInstance方法-反射机制"><a href="#3-使用Constructor类的newInstance方法-反射机制" class="headerlink" title="3). 使用Constructor类的newInstance方法(反射机制)"></a>3). 使用Constructor类的newInstance方法(反射机制)</h2><p>java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象，该方法和Class类中的newInstance方法很像，但是相比之下，Constructor类的newInstance方法更加强大些，我们可以通过这个newInstance方法调用有参数的和私有的构造函数，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用newInstance方法的这两种方式创建对象使用的就是Java的反射机制，事实上Class的newInstance方法内部调用的也是Constructor的newInstance方法。</p>
<h2 id="4-使用Clone方法创建对象"><a href="#4-使用Clone方法创建对象" class="headerlink" title="4). 使用Clone方法创建对象"></a>4). 使用Clone方法创建对象</h2><p> 无论何时我们调用一个对象的clone方法，JVM都会帮我们创建一个新的、一样的对象，特别需要说明的是，用<strong>clone方法创建对象的过程中并不会调用任何构造函数</strong>。关于如何使用clone方法以及浅克隆/深克隆机制，笔者已经在博文《 Java String 综述(下篇)》做了详细的说明。简单而言，要想使用clone方法，我们就必须先实现Cloneable接口并实现其定义的clone方法，这也是原型模式的应用。比如：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line">        Student stu4 = (Student) stu3.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用-反-序列化机制创建对象"><a href="#5-使用-反-序列化机制创建对象" class="headerlink" title="5). 使用(反)序列化机制创建对象"></a>5). 使用(反)序列化机制创建对象</h2><p>当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写对象</span></span><br><span class="line">        ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;student.bin&quot;</span>));</span><br><span class="line">        output.writeObject(stu3);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读对象</span></span><br><span class="line">        ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                <span class="string">&quot;student.bin&quot;</span>));</span><br><span class="line">        Student stu5 = (Student) input.readObject();</span><br><span class="line">        System.out.println(stu5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-完整实例"><a href="#6-完整实例" class="headerlink" title="6). 完整实例"></a>6). 完整实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用new关键字创建对象：&quot;</span>);</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="number">123</span>);</span><br><span class="line">        System.out.println(stu1);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Class类的newInstance方法创建对象：&quot;</span>);</span><br><span class="line">        Student stu2 = Student.class.newInstance();    <span class="comment">//对应类必须具有无参构造方法，且只有这一种创建方式</span></span><br><span class="line">        System.out.println(stu2);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Constructor类的newInstance方法创建对象：&quot;</span>);</span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);   <span class="comment">// 调用有参构造方法</span></span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);   </span><br><span class="line">        System.out.println(stu3);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Clone方法创建对象：&quot;</span>);</span><br><span class="line">        Student stu4 = (Student) stu3.clone();</span><br><span class="line">        System.out.println(stu4);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用(反)序列化机制创建对象：&quot;</span>);</span><br><span class="line">        <span class="comment">// 写对象</span></span><br><span class="line">        ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;student.bin&quot;</span>));</span><br><span class="line">        output.writeObject(stu4);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取对象</span></span><br><span class="line">        ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                <span class="string">&quot;student.bin&quot;</span>));</span><br><span class="line">        Student stu5 = (Student) input.readObject();</span><br><span class="line">        System.out.println(stu5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        使用new关键字创建对象：</span></span><br><span class="line"><span class="comment">        Student [id=123]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ---------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用Class类的newInstance方法创建对象：</span></span><br><span class="line"><span class="comment">        Student [id=0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ---------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用Constructor类的newInstance方法创建对象：</span></span><br><span class="line"><span class="comment">        Student [id=123]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ---------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用Clone方法创建对象：</span></span><br><span class="line"><span class="comment">        Student [id=123]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ---------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用(反)序列化机制创建对象：</span></span><br><span class="line"><span class="comment">        Student [id=123]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>从Java虚拟机层面看，除了使用new关键字创建对象的方式外，其他方式全部都是通过转变为invokevirtual指令直接创建对象的。</p>
<h1 id="五、java对象创建过程"><a href="#五、java对象创建过程" class="headerlink" title="五、java对象创建过程"></a>五、java对象创建过程</h1><h2 id="1-执行类加载过程"><a href="#1-执行类加载过程" class="headerlink" title="1. 执行类加载过程"></a>1. 执行类加载过程</h2><p>虚拟机遇到一条new指令时，首先检查该对象对应的类是否已被加载、解析和初始化过，如果没有，则先执行相应的类加载过程。</p>
<h2 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h2><p>类加载检查通过后，虚拟机就会为新生对象分配内存（对象所需的内存大小在类加载完成后便可完全确定），为对象分配内存的任务相当于从Java堆中划分出一块确定大小的内存，根据Java堆中内存是否是规整的（是否规整由采用的垃圾收集器是否带有压缩整理的功能决定），有两种内存分配方式：</p>
<ul>
<li><strong>1）指针碰撞方式</strong>：所有用过的内存放在一边，空闲的放在另一边，中间有一个指针作为分界点，分配内存就是将指针移动一段与对象内存大小相等的距离。</li>
<li><strong>2）空闲列表方式</strong>：由于已使用的内存和空闲内存是交错分配的，所以需要知道内存可分配，为此，虚拟机维护一个空闲列表，用来记录哪些内存块是可用的，在分配的时候，直接从列表中找到一个足够大的空间划分给对象，然后更新列表记录。</li>
</ul>
<p>还需要考虑并发情况下内存分配时线程安全问题，可能正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。JVM采用给每个线程在堆中首先分配一块线程私有的分配缓冲TLAB，哪个线程需要分配内存，就在哪个线程的TLAB上分配。</p>
<h2 id="3-内存空间初始化"><a href="#3-内存空间初始化" class="headerlink" title="3. 内存空间初始化"></a>3. 内存空间初始化</h2><p>内存分配后，JVM将分配到的内存空间都初始化为零值（不包括对象头），所以我们在定义Java类的实例字段中可以不赋初值就直接使用，程序能访问到这些数据类型对应的零值。</p>
<h2 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4. 设置对象头"></a>4. 设置对象头</h2><p>设置对象运行时所需要的必要信息，如对象是哪个类的实例，对象的哈希码、GC分代年龄等。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9tdzY5MC8wMDZTUXhicGx5MWc0bm1jdTRpOGVqMzA5ZDA0ejc0by5qcGc" alt="在这里插入图片描述"></p>
<p><strong>对象在内存中的布局</strong>分为三部分：</p>
<ul>
<li><strong>对象头</strong>：包括两部分信息，第一部分存储对象自身运行时数据，如哈希码、GC分代年龄、线程持有的锁等，称为“Mark Word”。在32位和64位虚拟机下的长度分别为32bit和64bit。另一部分是类型指针，用来指向所属类，虚拟机通过这个指针来确定这个对象是哪个类的实例；如果是对象是一个数组的话，还有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9tdzY5MC8wMDZTUXhicGx5MWc0bm1rdmsyOWxqMzBpdzAydnQ5aS5qcGc" alt="在这里插入图片描述"></p>
<ul>
<li><strong>实例数据</strong>：是对象真正存储的有效信息，也是我们在程序中所定义的各种类型的字段内容。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。</li>
<li><strong>对齐填充</strong>：因为HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是对象的大小必须是8字节的整数倍，对象头的大小已经是8字节的整数倍，因此，当实例数据没有对齐时，会通过对齐填充来使整个对象大小为8字节的整数倍。</li>
</ul>
<h2 id="5-实例对象初始化"><a href="#5-实例对象初始化" class="headerlink" title="5. 实例对象初始化"></a>5. 实例对象初始化</h2><p>上面的工作完成后，从虚拟机的角度看，一个对象已经产生了，但从Java程序的角度，对象的创建才刚刚开始，我们在对象中定义的成员变量都还没初始化，还是零值。对于实例对象执行new指令后还会接着执行<code>&lt;init&gt;</code>方法，初始化其中的实例变量以及构造块等。</p>
<p><strong>这里注意<init>和<clinit>方法的区别</strong>：</p>
<p>这两个方法都是Java虚拟机生成的，Java在编译之后会在字节码文件中生成<init>和<clinit>方法。都是用来放置初始化相关的代码的。</p>
<ul>
<li><p><strong><init>方法：</strong>称之为<strong>实例构造器</strong>，Java编译后会将初始化块、变量初始化、调用父类的构造函数和自身的构造函数等操作都统一放到该方法中去执行。操作顺序为：</p>
<p><strong>1. 父类变量初始化 2. 父类初始化块 3. 父类构造函数 4. 子类变量初始化 5. 子类初始化块 6. 子类构造函数</strong></p>
</li>
<li><p><clinit>方法：称之为<strong>类构造器</strong>，将静态初始化块、静态变量初始化等都统一收敛到该方法中，收敛顺序为：</p>
<p><strong>1. 父类静态变量初始化 2. 父类静态初始化块 3. 子类静态变量初始化 4. 子类静态初始化块</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Log log = LogFactory.getLog(); <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">1</span>;   <span class="comment">// &lt;init&gt;</span></span><br><span class="line"></span><br><span class="line">   X()&#123;</span><br><span class="line">      <span class="comment">// &lt;init&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><clinit>方法是在类加载的时候执行的，而<init>是在对象实例化时执行的(即执行new指令的时候)，所以<clinit>会比<init>先执行</strong>。所以最终<strong>整个初始化的顺序</strong>为:</p>
<blockquote>
<p><strong>父类静态变量初始化</strong><br><strong>父类静态初始化块</strong><br><strong>子类静态变量初始化</strong><br><strong>子类静态初始化块</strong><br><strong>父类变量初始化</strong><br><strong>父类初始化块</strong><br><strong>父类构造函数</strong><br><strong>子类变量初始化</strong><br><strong>子类初始化块</strong><br><strong>子类构造函数</strong></p>
</blockquote>
<h3 id="1、实例变量初始化与实例代码块初始化"><a href="#1、实例变量初始化与实例代码块初始化" class="headerlink" title="1、实例变量初始化与实例代码块初始化"></a>1、实例变量初始化与实例代码块初始化</h3><p>在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。如果我们以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。<strong>实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后</strong>(还记得吗？Java要求<strong>构造函数的第一条语句必须是超类构造函数的调用语句</strong>)，构造函数本身的代码之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceVariableInitializer</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = i + <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceVariableInitializer</span><span class="params">(<span class="keyword">int</span> <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">this</span>.i = <span class="keyword">var</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;               <span class="comment">// 实例代码块</span></span><br><span class="line">        j += <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InstanceVariableInitializer(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">            1</span></span><br><span class="line"><span class="comment">            5</span></span><br><span class="line"><span class="comment">            8</span></span><br><span class="line"><span class="comment">            5</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>上面的例子正好印证了上面的结论。特别需要注意的是，Java是按照编程顺序来执行实例变量初始化器和实例初始化器中的代码的，并且不允许顺序靠前的实例代码块初始化在其后面定义的实例变量，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceInitializer</span> </span>&#123;  </span><br><span class="line">    &#123;  </span><br><span class="line">        j = i;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceInitializer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = i;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面的这些代码都是无法通过编译的，编译器会抱怨说我们使用了一个未经定义的变量。之所以要这么做是为了保证一个变量在被使用之前已经被正确地初始化。但是我们仍然有办法绕过这种检查，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceInitializer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = getI();  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceInitializer</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        i = <span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        InstanceInitializer ii = <span class="keyword">new</span> InstanceInitializer();  </span><br><span class="line">        System.out.println(ii.j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>如果我们执行上面这段代码，那么会发现打印的<strong>结果是0</strong>。因此我们可以确信，变量j被赋予了i的<strong>默认值0，这一动作发生在实例变量i初始化之前和构造函数调用之前</strong>。</p>
<h3 id="2、构造函数初始化"><a href="#2、构造函数初始化" class="headerlink" title="2、构造函数初始化"></a>2、构造函数初始化</h3><p>我们可以从上文知道，实例变量初始化与实例代码块初始化总是发生在构造函数初始化之前，那么我们下面着重看看构造函数初始化过程。众所周知，每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。在编译生成的字节码中，这些构造函数会被命名成<init>()方法，参数列表与Java语言书写的构造函数的参数列表相同。</p>
<p>我们知道，Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。事实上，这一点是在构造函数中保证的：Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorExample</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>对于上面代码中定义的类，我们观察编译之后的字节码，我们会发现编译器为我们生成一个构造函数，如下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span>.<span class="title">test0312</span>.<span class="title">ConstructorExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> test.test0312.ConstructorExample();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的第二行就是调用Object类的默认构造函数的指令。也就是说，如果我们显式调用超类的构造函数，那么该调用必须放在构造函数所有代码的最前面，也就是必须是构造函数的第一条指令。正因为如此，Java才可以使得一个对象在初始化之前其所有的超类都被初始化完成，并保证创建一个完整的对象出来。</p>
<p>特别地，如果我们在一个构造函数中调用另外一个构造函数，对于这种情况，Java只允许在ConstructorExample(int i)内调用超类的构造函数，也就是说，下面两种情形的代码编译是无法通过的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorExample</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;  </span><br><span class="line"></span><br><span class="line">    ConstructorExample() &#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>);  <span class="comment">// Error:Constructor call must be the first statement in a constructor</span></span><br><span class="line">        ....  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ConstructorExample(<span class="keyword">int</span> i) &#123;  </span><br><span class="line">        ....  </span><br><span class="line">        <span class="keyword">this</span>.i = i;  </span><br><span class="line">        ....  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorExample</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;  </span><br><span class="line"></span><br><span class="line">    ConstructorExample() &#123;  </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">super</span>();  <span class="comment">//Error: Constructor call must be the first statement in a constructor</span></span><br><span class="line">        ....  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ConstructorExample(<span class="keyword">int</span> i) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.i = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>总而言之，实例化一个类的对象的过程是一个典型的递归过程，如下图所示。进一步地说，在实例化一个类的对象时，具体过程是这样的：</p>
<blockquote>
<p>在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。此时，首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20170518135452979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h3 id="3、-综合实例"><a href="#3、-综合实例" class="headerlink" title="3、****综合实例"></a>3、****<em><strong><strong><strong><strong><strong>综合实例</strong></strong></strong></strong></strong></em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;       <span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;    <span class="comment">// 实例构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;   <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;     <span class="comment">// 静态变量</span></span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        a=110,b=0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>在初始化阶段，当JVM对类StaticTest进行初始化时，首先会执行下面的语句：</p>
<p><code>static StaticTest st = new StaticTest();</code><br>也就是实例化StaticTest对象，但这个时候类都没有初始化完毕啊，能直接进行实例化吗？事实上，这涉及到一个根本问题就是：<strong>实例初始化不一定要在类初始化结束之后才开始初始化</strong>。</p>
<p>类的生命周期是：<strong>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</strong>，并且只有在准备阶段和初始化阶段才会涉及类变量的初始化和赋值，因此我们只针对这两个阶段进行分析：</p>
<ul>
<li>首先，在类的准备阶段需要做的是为类变量（static变量）分配内存并设置默认值(零值)，因此在该阶段结束后，类变量st将变为null、b变为0。特别需要注意的是，如果类变量是final的，那么编译器在编译时就会为value生成ConstantValue属性，并在准备阶段虚拟机就会根据ConstantValue的设置将变量设置为指定的值。也就是说，如果上述程度对变量b采用如下定义方式时：</li>
</ul>
<p><code>static final int b=112</code></p>
<p>那么，在准备阶段b的值就是112，而不再是0了。</p>
<ul>
<li>此外，在类的初始化阶段需要做的是执行类构造器<clinit>()，需要指出的是，**类构造器本质上是编译器收集所有静态语句块和类变量的赋值语句按语句在源码中的顺序合并生成类构造器<clinit>()**。因此，对上述程序而言，JVM将先执行第一条静态变量的赋值语句：</li>
</ul>
<p><code>st = new StaticTest ()</code><br>此时，“在类都没有初始化完毕之前，能直接进行实例化相应的对象吗？”。事实上，从Java角度看，我们知道一个类初始化的基本常识，那就是：<strong>在同一个类加载器下，一个类型只会被初始化一次</strong>。所以，<strong>一旦开始初始化一个类型，无论是否完成，后续都不会再重新触发该类型的初始化阶段了</strong>(只考虑在同一个类加载器下的情形)。因此，在实例化上述程序中的st变量时，实际上是<strong>把实例初始化嵌入到了静态初始化流程</strong>中，并且在上面的程序中，嵌入到了<strong>静态初始化的起始位置</strong>。这就导致了实例初始化完全发生在静态初始化之前，当然，这也是导致a为110b为0的原因。因此，上述程序的StaticTest类构造器<clinit>()的实现等价于：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    &lt;clinit&gt;()&#123;</span><br><span class="line">        a = <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);        <span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);     <span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);  <span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();<span class="comment">//类变量st被初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);        <span class="comment">//静态代码块</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;     <span class="comment">// 静态类变量b被初始化为112</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，上述程序会有上面的输出结果。下面，我们对上述程序稍作改动，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;</span><br><span class="line">    <span class="keyword">static</span> StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序最后的一行，增加以下代码行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br></pre></td></tr></table></figure>

<p>那么，此时程序的输出又是什么呢？如果你对上述的内容理解很好的话，不难得出结论(**只有执行完上述代码行后，StaticTest类才被初始化完成)**，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">a=110,b=0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">a=110,b=112</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    &lt;clinit&gt;()&#123;</span><br><span class="line">        a = <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);        <span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);     <span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);  <span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();<span class="comment">//类变量st被初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);        <span class="comment">//静态代码块</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;     <span class="comment">// 静态类变量b被初始化为112</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> StaticTest st1 = <span class="keyword">new</span> StaticTest();<span class="comment">//这里和上边是分开的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，下面这道<strong>经典题目</strong>也很有意思，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Foo() &#123;</span><br><span class="line">        System.out.println(i);             </span><br><span class="line">        <span class="keyword">int</span> x = getValue();</span><br><span class="line">        System.out.println(x);            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Bar() &#123;</span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        j = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        Bar bar = <span class="keyword">new</span> Bar();</span><br><span class="line">        System.out.println(bar.getValue());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上文所述的类实例化过程，我们可以将Foo类的构造函数和Bar类的构造函数等价地分别变为如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Foo类构造函数的等价变换：</span></span><br><span class="line">Foo() &#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="keyword">int</span> x = getValue();</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bar类构造函数的等价变换</span></span><br><span class="line">Bar() &#123;</span><br><span class="line">    Foo();</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    j = <span class="number">3</span>;</span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样程序就好看多了，我们一眼就可以观察出程序的输出结果。在通过使用Bar类的构造方法new一个Bar类的实例时，首先会调用Foo类构造函数，因此(1)处输出是2，这从Foo类构造函数的等价变换中可以直接看出。(2)处输出是0，为什么呢？因为在执行Foo的构造函数的过程中，<strong>由于Bar重载了Foo中的getValue方法，所以根据Java的多态特性可以知道，其调用的getValue方法是被Bar重载的那个getValue方法。</strong>但由于这时Bar的构造函数还没有被执行，因此此时j的值还是默认值0，因此(2)处输出是0。最后，在执行(3)处的代码时，由于bar对象已经创建完成，所以此时再访问j的值时，就得到了其初始化后的值2，这一点可以从Bar类构造函数的等价变换中直接看出。</p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/74f0501493b3">《JVM类加载机制》</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f704ad4196e">Java类加载器：类加载原理解析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/72466105">JVM类生命周期概述：加载时机与加载过程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/72466416">深入理解Java对象的创建过程：类的初始化与实例化</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">http://muchengxue.github.io/2021/12/18/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/JVM/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">垃圾回收与内存分配策略</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/JVM/java%E8%AF%AD%E6%B3%95%E7%B3%96/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java语法糖</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/18/template/" title="关键字"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">关键字</div></div></a></div><div><a href="/2021/12/18/Java/JVM/Java%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/" title="关键字"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">关键字</div></div></a></div><div><a href="/2021/12/18/Java/JVM/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" title="class文件结构"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">class文件结构</div></div></a></div><div><a href="/2021/12/18/Java/JVM/classLoader%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="双亲委派模型有啥好处？"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">双亲委派模型有啥好处？</div></div></a></div><div><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JMM%E4%B9%8Bfinal%E5%85%B3%E9%94%AE%E5%AD%97_%E5%8F%8A%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/" title="final、volatile关键字"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">final、volatile关键字</div></div></a></div><div><a href="/2021/12/18/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JMM%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/" title="final、volatile关键字"><img class="cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">final、volatile关键字</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">一、类加载机制概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number"></span> <span class="toc-text">二、类加载的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-number"></span> <span class="toc-text">1、类加载时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="toc-number"></span> <span class="toc-text">2、类初始化时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%A2%AB%E5%8A%A8%E5%BC%95%E7%94%A8%E7%BB%8F%E5%85%B8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">3、被动引用经典场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">三、类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">1、加载（Loading）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%AA%8C%E8%AF%81%EF%BC%88Verification%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">2、验证（Verification）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%87%86%E5%A4%87-Preparation"><span class="toc-number"></span> <span class="toc-text">3、准备(Preparation)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%A7%A3%E6%9E%90-Resolution"><span class="toc-number"></span> <span class="toc-text">4、解析(Resolution)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">类与接口的解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">字段解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">类方法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">接口方法解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-Initialization"><span class="toc-number"></span> <span class="toc-text">5、初始化(Initialization)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number"></span> <span class="toc-text">四、Java对象创建时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number"></span> <span class="toc-text">1). 使用new关键字创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8Class%E7%B1%BB%E7%9A%84newInstance%E6%96%B9%E6%B3%95-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">2). 使用Class类的newInstance方法(反射机制)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8Constructor%E7%B1%BB%E7%9A%84newInstance%E6%96%B9%E6%B3%95-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">3). 使用Constructor类的newInstance方法(反射机制)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8Clone%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number"></span> <span class="toc-text">4). 使用Clone方法创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8-%E5%8F%8D-%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number"></span> <span class="toc-text">5). 使用(反)序列化机制创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text">6). 完整实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">五、java对象创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">1. 执行类加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number"></span> <span class="toc-text">2. 为对象分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">3. 内存空间初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number"></span> <span class="toc-text">4. 设置对象头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">5. 实例对象初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">1、实例变量初始化与实例代码块初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">2、构造函数初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">3、****综合实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2"><span class="toc-number"></span> <span class="toc-text">参考博客</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS的设计思路"/></a><div class="content"><a class="title" href="/2022/02/03/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E4%B9%8BAQS%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" title="AQS的设计思路">AQS的设计思路</a><time datetime="2022-02-03T13:10:28.437Z" title="发表于 2022-02-03 13:10:28">2022-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="float的范围和精度"/></a><div class="content"><a class="title" href="/2022/01/21/Java/java%E5%9F%BA%E7%A1%80/%E4%BB%8E1.0f%E8%AF%B4%E8%B5%B7/" title="float的范围和精度">float的范围和精度</a><time datetime="2022-01-21T14:18:25.869Z" title="发表于 2022-01-21 14:18:25">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="随想1"/></a><div class="content"><a class="title" href="/2021/12/19/%E9%9A%8F%E6%83%B3/2021-12-19/" title="随想1">随想1</a><time datetime="2021-12-18T16:15:22.363Z" title="发表于 2021-12-18 16:15:22">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 吊打面试官"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="Redis 吊打面试官">Redis 吊打面试官</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis中的事务"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="Redis中的事务">Redis中的事务</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>