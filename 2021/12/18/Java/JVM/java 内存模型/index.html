<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java内存模型 | 暮成雪的博客</title><meta name="keywords" content="java内存模型"><meta name="author" content="MuChengxue"><meta name="copyright" content="MuChengxue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java平台最大的优势之一是在Java Virtual Machine中实现自动内存管理。每个使用C &#x2F; C ++等语言编程的人都知道在代码中管理内存分配和释放的问题。Java程序在执行前首先会被编译成字节码文件，然后再由Java虚拟机执行这些字节码文件从而使得Java程序得以执行。事实上，在程序执行过程中，内存的使用和管理一直是值得关注的问题。Java虚拟机在执行Java程序的过程中会把它所管">
<meta property="og:type" content="article">
<meta property="og:title" content="java内存模型">
<meta property="og:url" content="http://muchengxue.github.io/2021/12/18/Java/JVM/java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="暮成雪的博客">
<meta property="og:description" content="Java平台最大的优势之一是在Java Virtual Machine中实现自动内存管理。每个使用C &#x2F; C ++等语言编程的人都知道在代码中管理内存分配和释放的问题。Java程序在执行前首先会被编译成字节码文件，然后再由Java虚拟机执行这些字节码文件从而使得Java程序得以执行。事实上，在程序执行过程中，内存的使用和管理一直是值得关注的问题。Java虚拟机在执行Java程序的过程中会把它所管">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg">
<meta property="article:published_time" content="2021-12-18T14:42:25.734Z">
<meta property="article:modified_time" content="2020-04-06T16:48:32.024Z">
<meta property="article:author" content="MuChengxue">
<meta property="article:tag" content="java内存模型">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg"><link rel="shortcut icon" href="/img/myFavicon.jpg"><link rel="canonical" href="http://muchengxue.github.io/2021/12/18/Java/JVM/java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: MuChengxue","link":"链接: ","source":"来源: 暮成雪的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java内存模型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-04-06 16:48:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myFavicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-video"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-video"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮成雪的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-video"></i><span> Book</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-video"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java内存模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-18T14:42:25.734Z" title="发表于 2021-12-18 14:42:25">2021-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-04-06T16:48:32.024Z" title="更新于 2020-04-06 16:48:32">2020-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java内存模型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/18/Java/JVM/java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/18/Java/JVM/java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://images2015.cnblogs.com/blog/731716/201606/731716-20160630221300812-120869582.png"></p>
<p>Java平台最大的优势之一是在Java Virtual Machine中实现自动内存管理。每个使用C / C ++等语言编程的人都知道在代码中管理内存分配和释放的问题。Java程序在执行前首先会被编译成字节码文件，然后再由Java虚拟机执行这些字节码文件从而使得Java程序得以执行。事实上，在程序执行过程中，<strong>内存的使用和管理</strong>一直是值得关注的问题。Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间，并且它们可以分为两种类型：线程共享的方法区和堆，线程私有的虚拟机栈、本地方法栈和程序计数器。在此基础上，探讨了在虚拟机中对象的创建和对象的访问定位等问题，并分析了Java虚拟机规范中异常产生的情况。</p>
<h1 id="一-Java运行时数据区域"><a href="#一-Java运行时数据区域" class="headerlink" title="一.Java运行时数据区域"></a>一.Java运行时数据区域</h1><p><u>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据域，这些数据域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁</u>。根据《Java虚拟机规范7》的规定，Java虚拟机所管理的内存将包括以下几个运行时数据区域，如图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1900685-6b21e6cf18dcea68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/585/format/webp" alt="img"></p>
<h2 id="1、线程私有的数据区"><a href="#1、线程私有的数据区" class="headerlink" title="1、线程私有的数据区"></a><strong>1、线程私有的数据区</strong></h2><p><strong>线程私有的数据区 包括 程序计数器、 虚拟机栈 和 本地方法栈 三个区域。</strong></p>
<h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p><strong>程序计数器(Program Counter Register)<strong>是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅概念模型，各种虚拟机可能会通过一些更高效的方式去实现），</strong>字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码执行，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</strong>。</p>
<p>线程是CPU调度的基本单位，在多线程情况下，当线程数超过CPU数量或CPU内核数量时，线程之间就要根据 <strong>时间片轮询抢夺CPU时间资源</strong>。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，<u>在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令</u>。因此，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器去记录其正在执行的字节码指令地址</strong>，各条线程之间计数器互相不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>**如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空(Undefined)**。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemo</p>
<h3 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2  Java虚拟机栈"></a>1.2  Java虚拟机栈</h3><p><strong>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同</strong>。虚拟机描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<strong>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</strong>。栈帧结构如下：`</p>
<p><img src="https://img-blog.csdn.net/20170505082120037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<img src="https://upload-images.jianshu.io/upload_images/1900685-e888c80f4bddd01a.png?imageMogr2/auto-orient/strip|imageView2/2/w/778/format/webp" alt="img"  />

<p><strong>局部变量表</strong>存放了编译期可知的<strong>各种基本数据类型</strong>(boolean,byte,char,short,int,float,long,double)、<strong>对象引用</strong>(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的<strong>引用指针</strong>，也可能是指向一个代表对象的句柄或其他于此对象相关的位置)和<strong>returnAddress类型</strong>(指向了一条字节码指令的地址)。<strong>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型占用1个</strong>。局部变量表所需的内存空间在编译期间完成分配，<strong>当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong><br> 在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的<strong>深度</strong>（<strong>递归</strong>多少层次，或嵌套调用多少层其他方法，**-Xss 参数可以设置虚拟机栈大小<strong>），将抛出</strong>StackOverFlowError<strong>异常；如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，如果扩展是无法申请到足够的</strong>内存**(比如没有足够的内存为一个新创建的线程分配栈空间时)，就会抛出<strong>OutOfMemoryError</strong>异常。</p>
<p><img src="C:\Users\Administrator\Desktop\面试题总结\JVM\image-20200314114509174.png" alt="image-20200314114509174"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -verbose</span><br><span class="line">Classfile /E:/idea/IdeaWorkspace/Test2020/src/test/test0313/ByteCodeSample.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">3</span>-<span class="number">14</span>; size <span class="number">284</span> bytes</span><br><span class="line">  MD5 checksum 47d60ec95cc0a0ec2a3e3a6b7fab19f0</span><br><span class="line">  Compiled from <span class="string">&quot;ByteCodeSample.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span>.<span class="title">test0313</span>.<span class="title">ByteCodeSample</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">3.</span>#<span class="number">12</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">13</span>            <span class="comment">// test/test0313/ByteCodeSample</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">14</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">5</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">6</span> = Utf8               Code</span><br><span class="line">   #<span class="number">7</span> = Utf8               LineNumberTable</span><br><span class="line">   #<span class="number">8</span> = Utf8               add</span><br><span class="line">   #<span class="number">9</span> = Utf8               (II)I</span><br><span class="line">  #<span class="number">10</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">11</span> = Utf8               ByteCodeSample.java</span><br><span class="line">  #<span class="number">12</span> = NameAndType        #<span class="number">4</span>:#<span class="number">5</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               test/test0313/ByteCodeSample</span><br><span class="line">  #<span class="number">14</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> test.test0313.ByteCodeSample();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">2</span><span class="comment">//操作数栈深度2，局部变量表打下3，参数2个</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_2</span><br><span class="line">         <span class="number">2</span>: iload_0</span><br><span class="line">         <span class="number">3</span>: iload_1</span><br><span class="line">         <span class="number">4</span>: iadd</span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_2</span><br><span class="line">         <span class="number">7</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;ByteCodeSample.java&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是<strong>虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务</strong>。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="2、线程共享的数据区域"><a href="#2、线程共享的数据区域" class="headerlink" title="2、线程共享的数据区域"></a>2、线程共享的数据区域</h2><p>线程共享的数据区 具体包括 <strong>Java堆 和 方法区</strong> 。</p>
<h3 id="2-1-Java堆"><a href="#2-1-Java堆" class="headerlink" title="2.1 Java堆"></a>2.1 Java堆</h3><p>对大多数应用来说，<strong>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块</strong>。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例（和数组）都在这里分配内存****。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译期的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，</strong>所有的对象都分配在堆上也渐渐变得不是那么“绝对”了**。</p>
<p>Java堆是<strong>垃圾收集器管理</strong>的主要区域，因此很多时候也被称作“<strong>GC堆</strong>”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用<strong>分代收集算法</strong>，所以<strong>Java堆中还可以细分为：新生代和老年代</strong>，再细致一点的有<strong>Eden空间、From Survivor空间、To Survivor空间</strong>等。从内存分配的角度来看，线程共享的Java堆中可能划分出<strong>多个线程私有的分配缓冲区（Thread Local Allocation Buffer</strong>）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快地分配内存。</p>
<p>根据Java虚拟机规范，<strong>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可</strong>，就像我们的磁盘空间一样。在实现时，既可以实现固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（<strong>通过-Xmx和-Xms控制</strong>）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<strong>OutOfMemoryError</strong>异常。</p>
<p><img src="http://static.zybuluo.com/Rico123/pml3jw51zgc8mqffpwt6793t/heap.bmp" alt="img"></p>
<h4 id="java对象都是在堆上分配空间的吗？"><a href="#java对象都是在堆上分配空间的吗？" class="headerlink" title="java对象都是在堆上分配空间的吗？"></a>java对象都是在堆上分配空间的吗？</h4><p><strong>”因为JIT技术的成熟使得”对象在堆上分配内存”就不是那么绝对的了。“</strong></p>
<h4 id="JIT-技术"><a href="#JIT-技术" class="headerlink" title="JIT 技术"></a>JIT 技术</h4><p>我们大家都知道，通过 javac 将可以将Java程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。这就是传统的JVM的解释器（Interpreter）的功能。很显然，<strong>Java编译器经过解释执行，其执行速度必然会比直接执行可执行的二进制字节码慢很多。为了解决这种效率问题，引入了 JIT（Just In Time ，即时编译） 技术。</strong></p>
<p>有了JIT技术之后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是**“热点代码”（Hot Spot Code)**。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p>
<h4 id="热点检测"><a href="#热点检测" class="headerlink" title="热点检测"></a>热点检测</h4><p>上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），HotSpot虚拟机中采用的主要是基于计数器的热点探测</p>
<blockquote>
<p>基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。</p>
</blockquote>
<h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>JIT在做了热点检测识别出热点代码后，除了会对其字节码进行缓存，还会对代码做各种优化。这些优化中，比较重要的几个有：<strong>逃逸分析、 锁消除、 锁膨胀、 方法内联、 空值检查消除、 类型检测消除、 公共子表达式消除</strong>等。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p><strong>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sb是一个方法内部变量，上述代码中并没有将他直接返回，这样这个StringBuffer有不会被其他方法所改变，这样它的作用域就只是在方法内部。我们就可以说这个变量并没有逃逸到方法外部。</p>
<p>有了逃逸分析，我们可以判断出一个方法中的变量是否有可能被其他线程所访问或者改变，那么基于这个特性，JIT就可以做一些优化：</p>
<ul>
<li>同步省略</li>
<li>标量替换</li>
<li>栈上分配</li>
</ul>
<h4 id="标量替换、栈上分配"><a href="#标量替换、栈上分配" class="headerlink" title="标量替换、栈上分配"></a>标量替换、栈上分配</h4><p>我们说，JIT经过逃逸分析之后，如果发现某个对象并没有逃逸到方法体之外的话，就可能对其进行优化，而这一优化最大的结果就是可能改变Java对象都是在堆上分配内存的这一原则。</p>
<p>对象要分配在堆上其实有很多原因，但是有一点比较关键的和本文有关的，那就是因为堆内存在访问上是线程共享的，这样一个线程创建出来的对象，其他线程也能访问到。</p>
<p><em>那么，试想下，如果我们在某一个方法体内部创建了一个对象，并且对象并没有逃逸到方法外的话，那还有必要一定要把对象分配到堆上吗？</em></p>
<p>其实就没有必要了，因为这个对象并不会被其他线程所访问到，生命周期也只是在一个方法内部，也就不用大费周折的在堆上分配内存，也减少了内存回收的必要。</p>
<p>那么，有了逃逸分析之后，发现一个对象并没有逃逸到放法外的话，通过什么办法可以进行优化，减少对象在堆上分配可能呢？</p>
<p>这就是栈上分配。在HotSopt中，栈上分配并没有正在的进行实现，而是通过标量替换来实现的。</p>
<p>所以我们重点介绍下，什么是标量替换，如何通过标量替换实现栈上分配。</p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p><strong>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Point point = <span class="keyword">new</span> Point（<span class="number">1</span>,<span class="number">2</span>）;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+x+<span class="string">&quot;; point.y=&quot;</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</p>
<p><strong>通过标量替换，原本的一个对象，被替换成了多个成员变量。而原本需要在堆上分配的内存，也就不再需要了，完全可以在本地方法栈中完成对成员变量的内存分配。</strong></p>
<h4 id="实验证明"><a href="#实验证明" class="headerlink" title="实验证明"></a>实验证明</h4><p><strong>Talk Is Cheap, Show Me The Code</strong></p>
<p><strong>No Data, No BB；</strong></p>
<p>接下来我们就来通过一个实验，来看一下逃逸分析是否可以生效，生效后是否真的会发生栈上分配，而栈上分配又有什么好处呢？</p>
<p>我们来看以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a1 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看执行时间</span></span><br><span class="line">    <span class="keyword">long</span> a2 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;cost &quot;</span> + (a2 - a1) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实代码内容很简单，就是使用for循环，在代码中创建100万个User对象。</p>
<p>我们在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化。</p>
<p>我们指定以下JVM参数并运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError </span><br></pre></td></tr></table></figure>

<p><strong>其中-XX:-DoEscapeAnalysis表示关闭逃逸分析。</strong></p>
<p>在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap命令，来查看下当前堆内存中有多少个User对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➜  ~ jmap -histo <span class="number">2809</span></span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  <span class="class"><span class="keyword">class</span> <span class="title">name</span></span></span><br><span class="line"><span class="class">----------------------------------------------</span></span><br><span class="line"><span class="class">   1:           524       87282184  [<span class="title">I</span></span></span><br><span class="line"><span class="class">   2:       1000000       16000000  <span class="title">StackAllocTest</span>$<span class="title">User</span></span></span><br><span class="line"><span class="class">   3:          6806        2093136  [<span class="title">B</span></span></span><br><span class="line"><span class="class">   4:          8006        1320872  [<span class="title">C</span></span></span><br><span class="line"><span class="class">   5:          4188         100512  <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class">   6:           581          66304  <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span></span></span><br></pre></td></tr></table></figure>

<p>从上面的jmap执行结果中我们可以看到，堆中共创建了100万个StackAllocTest$User实例。</p>
<p>在关闭逃避分析的情况下（-XX:-DoEscapeAnalysis），虽然在alloc方法中创建的User对象并没有逃逸到方法外部，但是还是被分配在堆内存中。也就说，如果没有JIT编译器优化，没有逃逸分析技术，正常情况下就应该是这样的。即所有对象都分配到堆内存中。</p>
<p>接下来，我们开启逃逸分析，再来执行下以上代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError </span><br></pre></td></tr></table></figure>

<p>在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap命令，来查看下当前堆内存中有多少个User对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➜  ~ jmap -histo <span class="number">2859</span></span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  <span class="class"><span class="keyword">class</span> <span class="title">name</span></span></span><br><span class="line"><span class="class">----------------------------------------------</span></span><br><span class="line"><span class="class">   1:           524      101944280  [<span class="title">I</span></span></span><br><span class="line"><span class="class">   2:          6806        2093136  [<span class="title">B</span></span></span><br><span class="line"><span class="class">   3:         83619        1337904  <span class="title">StackAllocTest</span>$<span class="title">User</span></span></span><br><span class="line"><span class="class">   4:          8006        1320872  [<span class="title">C</span></span></span><br><span class="line"><span class="class">   5:          4188         100512  <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class">   6:           581          66304  <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span></span></span><br></pre></td></tr></table></figure>

<p>从以上打印结果中可以发现，开启了逃逸分析之后（-XX:+DoEscapeAnalysis），在堆内存中只有8万多个StackAllocTest$User对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了8万。</p>
<p>除了以上通过jmap验证对象个数的方法以外，读者还可以尝试将堆内存调小，然后执行以上代码，根据GC的次数来分析，也能发现，开启了逃逸分析之后，在运行期间，GC次数会明显减少。正是因为很多堆上分配被优化成了栈上分配，所以GC次数有了明显的减少。</p>
<h4 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h4><p>前面的例子中，开启逃逸分析之后，对象数目从100万变成了8万，但是并不是0，说明JIT优化并不会完完全全的所有情况都进行优化。</p>
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<h3 id="2-2-方法区"><a href="#2-2-方法区" class="headerlink" title="2.2 方法区"></a>2.2 方法区</h3><p>方法区(Method Area)与Java堆一样，是各个线程共享的并且不需要连续的内存区域，它用于存储<strong>已被虚拟机加载的类结构信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是它却有个别名叫做Non-Heap(非堆)，目的是与Java堆区分开来。方法区通常和永久区**(Perm)**关联在一起，但永久代与方法区不是一个概念，只是有的虚拟机用永久代来实现方法区，这样就可以用永久代GC来管理方法区，省去专门内存管理的工作。<br> 根据Java虚拟机规范，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h4><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table),<strong>用于存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。<strong>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等；而符号引用则属于编译原理方面的概念，包括以下三类常量：类和接口的全限定名、字段的名称和描述符 和 方法的名称和描述符。</strong><br> Java虚拟机对Class文件每一部分(包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的虚拟机提供商可以按照自己的需求来实现这个内存区域。一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。<br><strong>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的<strong>intern</strong>()方法（本节后文会有例子详解）。<br>运行时常量池是方法区的一部分，当常量池无法再申请到内存时会抛出<strong>OutOfMemoryError</strong>异常。</p>
<h4 id="Java堆-与-方法区的区别"><a href="#Java堆-与-方法区的区别" class="headerlink" title="Java堆 与 方法区的区别"></a><strong>Java堆 与 方法区的区别</strong></h4><p><strong>Java堆是 Java代码可及的内存，是留给开发人员使用的；而非堆（Non-Heap）是JVM留给自己用的</strong>，所以方法区、JVM内部处理或优化所需的内存 (如JIT编译后的代码缓存)、每个类结构 (如运行时常量池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。</p>
<h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a><strong>方法区的回收</strong></h4><p><strong>方法区的内存回收目标主要是针对 常量池的回收 和 对类型的卸载</strong>。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
</ul>
<ul>
<li>加载该类的ClassLoader已经被回收；</li>
</ul>
<ul>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用<strong>反射、动态代理、CGLib</strong>等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。<br>在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<ul>
<li>本机直接内存的分配不会受到Java 堆大小的限制，受到本机总内存大小限制</li>
<li>配置虚拟机参数时，不要忽略直接内存 防止出现OutOfMemoryError异常</li>
</ul>
<h4 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h4><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。<strong>前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，</strong>并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于<strong>动态生成类的情况比较容易出现永久代的内存溢出</strong>。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过<strong>动态生成类</strong>来模拟 “PermGen space”的内存溢出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermGenOomMock</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;ClassLoader&gt; classLoaderList = <span class="keyword">new</span> ArrayList&lt;ClassLoader&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            url = <span class="keyword">new</span> File(<span class="string">&quot;/tmp&quot;</span>).toURI().toURL();</span><br><span class="line">            URL[] urls = &#123;url&#125;;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                ClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">                classLoaderList.add(loader);</span><br><span class="line">                loader.loadClass(<span class="string">&quot;com.paddx.test.memory.Test&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/820406/201603/820406-20160327005846979-1124627174.png" alt="img"></p>
<p>例中使用的 <strong>JDK 版本是 1.7</strong>，指定的 PermGen 区的大小为 8M。通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟悉的 “java.lang.OutOfMemoryError: PermGen space “ 异常了。这里之所以采用 JDK 1.7，是因为在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 <strong>Metaspace（元空间）</strong> 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。</p>
<h4 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a><strong>Metaspace（元空间）</strong></h4><p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，<strong>存储在永久代的部分数据就已经转移到了Java Heap</strong>或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOomMock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String  base = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            String str = base + base;</span><br><span class="line">            base = str;</span><br><span class="line">            list.add(str.intern());<span class="comment">//intern方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK 1.7 和 JDK 1.8 分别运行：</p>
<p><img src="https://images2015.cnblogs.com/blog/820406/201603/820406-20160327005929386-409283462.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/820406/201603/820406-20160327010033823-1341228280.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/820406/201603/820406-20160327010143776-1612977566.png" alt="img"></p>
<p>从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。现在我们看看元空间到底是一个什么东西？</p>
<p><strong>元空间的本质和永久代类似，都是对JVM规范中方法区的实现</strong>。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存。</strong>因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>　　<strong>-XX:MetaspaceSize</strong>，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>　　<strong>-XX:MaxMetaspaceSize</strong>，最大空间，默认是没有限制的。</p>
<p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>　　<strong>-XX:MinMetaspaceFreeRatio</strong>，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br>　　<strong>-XX:MaxMetaspaceFreeRatio</strong>，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>现在我们在 JDK 8下重新运行一下代码段 4，不过这次不再指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/820406/201603/820406-20160327010233933-699106123.png" alt="img"></p>
<p>从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。</p>
<h4 id="方法区变迁"><a href="#方法区变迁" class="headerlink" title="方法区变迁"></a>方法区变迁</h4><p><strong>方法区在不同虚拟机中有不同的实现，HotSpot在1.7版本以前和1.7版本，1.7后都有变化。</strong></p>
<p><strong>jdk7版本以前的实现</strong></p>
<p><img src="https://img-blog.csdn.net/20170910081818166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQV96aGVuemhlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><strong>jdk7版本的改动是把字符串常量池移到了堆中。jdk1.8中则把永久代给完全删除了，取而代之的是MetaSpace</strong></p>
<p><img src="https://img-blog.csdn.net/20170910081840570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQV96aGVuemhlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><strong>运行时常量池和静态变量都存储到了堆中</strong>，MetaSpace存储类的元数据，MetaSpace直接申请在本地内存中（Native memory）,这样类的元数据分配只受本地内存大小的限制,OOM问题就不存在了。</p>
<h4 id="java8内存模型"><a href="#java8内存模型" class="headerlink" title="java8内存模型"></a>java8内存模型</h4><p><img src="D:\学习资料\面试题总结\JVM\image-20200314145245476.png" alt="image-20200314145245476"></p>
<p><strong>总结</strong></p>
<p>通过上面分析，大致了解了  JDK 8 中永久代向元空间的转换。为什么要做这个转换？总结以下几点原因：</p>
<p>　　1、字符串存在永久代中，容易出现性能问题和内存溢出。</p>
<p>　　2、类及方法的信息等（<strong>已被虚拟机加载的类结构信息、常量、静态变量、即时编译器编译后的代码等数据</strong>）比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p>
<p>　　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
<p>　　4、Oracle 可能会将HotSpot 与 JRockit 合二为一。</p>
<h4 id="不同jdk下的String-intern"><a href="#不同jdk下的String-intern" class="headerlink" title="不同jdk下的String.intern()"></a>不同jdk下的String.intern()</h4><p><strong>JDK6：</strong>当调用intern()方式时，如果字符串常量池中存在当前字符串，就会直接返回池中当前字符串对应的引用；如果常量池中没有此字符串，会将此字符串添加到字符串常量池中后，再返回池中当前字符串对应的引用。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">    * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">    * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">    * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">    * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">    * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">    * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">    *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>JDK6+<strong>：当调用intern()方式时，如果字符串常量池中存在当前字符串，就会直接返回池中当前字符串对应的引用；否则，如果该字符串对象存在于java堆中，则将</strong>堆中对此对象的引用添加到字符串常量池中</strong>，并返回该引用；如果堆中也没有，会将此字符串添加到字符串常量池中后，再返回池中当前字符串对应的引用</p>
<p>看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new的“1”会放入常量池中的</span></span><br><span class="line">    s.intern();<span class="comment">//试图放一个副本到常量池，由于已经在new的时候放过了，存在</span></span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;<span class="comment">//直接引用常量池中的</span></span><br><span class="line">    System.out.println(s == s2);<span class="comment">//一个在常量池一个在java堆肯定false</span></span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//1已经存在，此时只会在java堆new一个s3</span></span><br><span class="line">    s3.intern();<span class="comment">//常量池中没有11：jdk6会在常量池new一个11并返回，jdk7会把java堆中的s3引用放入常量池并返回</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在JDK1.6中的运行结果是**false false**，而在1.7中结果是**false true**。</span></span><br></pre></td></tr></table></figure>

<p>将intern()语句下移一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在JDK1.6中的运行结果是**false false**，在1.7中结果也是**false false**。</span></span><br></pre></td></tr></table></figure>

<p>下面来解释一下<strong>JDK1.6</strong>环境下的结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/1177828/201709/1177828-20170929183900606-1688428199.png" alt="img"></p>
<p><strong>图中绿色线条代表string对象的内容指向，黑色线条代表地址指向。</strong></p>
<p>JDK1.6中的intern()方法只是返回常量池中的引用，上面说过，常量池中的引用所指向的对象和new出来的对象（<strong>对象实例在java堆</strong>）并不是一个，所以他们的地址自然不相同。</p>
<p>接着来说一下<strong>JDK1.7</strong>：</p>
<p><img src="https://images2017.cnblogs.com/blog/1177828/201709/1177828-20170929183909169-2103124161.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1177828/201709/1177828-20170929183728481-2021113406.png" alt="img"></p>
<h2 id="3、JVM–参数调优"><a href="#3、JVM–参数调优" class="headerlink" title="3、JVM–参数调优"></a>3、JVM–参数调优</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anyehome/p/9071619.html">JVM–参数调优</a></p>
<h1 id="二-Java对象的创建与访问"><a href="#二-Java对象的创建与访问" class="headerlink" title="二.Java对象的创建与访问"></a>二.Java对象的创建与访问</h1><p>Java是一门面向对象编程的语言，在Java程序运行过程中无时无刻都有对象被创建和使用。</p>
<h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1 对象的创建"></a>1 对象的创建</h2><p>（1）虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个服务号引用代表的类<strong>是否已被加载、解析和初始化过</strong>。如果没有，那么必须先执行相应的<strong>类加载过程</strong>。</p>
<p>（2）在类加载检查通过后，接下来虚拟机将<strong>为新生对象分配内存</strong>。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于<strong>把一块确定大小的内存从Java堆中划分出来</strong>。内存分配算法如下：</p>
<ul>
<li><strong>指针碰撞</strong>：假设Java堆中内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。</li>
<li><strong>空闲列表</strong>：如果Java堆中的内存并不规整，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存时可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新过列表上的记录，这种分配方式称为“空闲列表”(Free List)。</li>
</ul>
<p>选择哪种分配方式由Java堆是否规整决定。因此，<strong>在使用Serial，ParNew等带Compact过程的收集器时，系统采用分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表</strong>。</p>
<p>除了如何划分可用空间之外，还需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间)时的线程安全问题，因为存在可能出现正在给对象A分配内存，<strong>指针</strong>还未修改，对象B又同时使用原来的指针分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理：采用CAS+失败重试的方式保证更新操作的原子性；</li>
<li>把内存分配的动作按照线程划分的不同的空间中：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在自己的TLAB上分配，如果TLAB用完并分配新的TLAB时，再加同步锁定。</li>
</ul>
<p>（3）内存分配完成后，虚拟机需要将分配到的内存空间都<strong>初始化为零值</strong>。如果使用TLAB，也可以提前到TLAB分配时进行。 这一步操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>（4）接下来，虚拟机要对对象进行<strong>必要的设置</strong>， 例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分带年龄等信息。这些信息存放在对象的**对象头(Object Header)**之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的的设置方式。</p>
<p>（5）在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行**<init>方法<strong>把对象按照程序员的意愿进行</strong>初始化**，从而产生一个真正可用的对象。`</p>
<h2 id="2-TLAB技术"><a href="#2-TLAB技术" class="headerlink" title="2 TLAB技术"></a>2 TLAB技术</h2><p>对象的内存分配过程中，主要是对象的引用指向这个内存区域，然后进行初始化操作。但是，因为堆是全局共享的，因此在同一时间，可能有多个线程在堆上申请空间，那么，<strong>在并发场景中，如果两个线程先后把对象引用指向了同一个内存区域，怎么办。</strong></p>
<p><img src="http://www.hollischuang.com/wp-content/uploads/2020/03/tlab3.png" alt="img"></p>
<p><strong>HotSpot虚拟机的方案：</strong>每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”<strong>私有”内存中分配</strong>，当这部分区域用完之后，再分配新的”私有”内存。这种方案被称之为<strong>TLAB分配，即Thread Local Allocation Buffer</strong>。这部分Buffer是从堆中划分出来的，但是是<strong>本地线程独享</strong>的。</p>
<p>TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是<strong>线程专属</strong>的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，<strong>只给当前线程使用</strong>，这样每个线程都<strong>单独拥有</strong>一个空间，如果需要分配内存，就在自己的空间上分配，这样就<strong>不存在竞争</strong>的情况，可以大大提升分配效率。</p>
<p>注意到上面的描述中”线程专属”、”只给当前线程使用”、”每个线程单独拥有”的描述了吗？所以说，<strong>因为有了TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。</strong></p>
<p>这里<strong>值得注意</strong>的是，我们说TLAB是线程独享的，但是只是在“<strong>分配”这个动作上是线程独占</strong>的，至于在<strong>读取、垃圾回收等动作上都是线程共享的</strong>。而且在使用上也没有什么区别。</p>
<p><img src="http://www.hollischuang.com/wp-content/uploads/2020/03/tlab.png" alt="img"></p>
<p>在TLAB分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等。</p>
<p><img src="http://www.hollischuang.com/wp-content/uploads/2020/03/tlab1.png" alt="img"></p>
<p>还有一点需要注意的是，我们说TLAB是在eden区分配的，因为eden区域本身就不太大，而且TLAB空间的内存也非常小，默认情况下仅占有整个Eden空间的1%。所以，必然存在一些大对象是无法在TLAB直接分配。</p>
<p>遇到TLAB中无法分配的大对象，对象还是可能在eden区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么我们经常说：<strong>小的对象比大的对象分配起来更加高效。</strong></p>
<h3 id="TLAB带来的问题"><a href="#TLAB带来的问题" class="headerlink" title="TLAB带来的问题"></a>TLAB带来的问题</h3><p>虽然在一定程度上，TLAB大大的提升了对象的分配速度，但是TLAB并不是就没有任何问题的。</p>
<p>前面我们说过，因为TLAB内存区域并不是很大，所以，有可能会经常出现不够的情况。在《实战Java虚拟机》中有这样一个例子：</p>
<p>比如一个线程的TLAB空间有100KB，其中已经使用了80KB，当需要再分配一个30KB的对象时，就无法直接在TLAB中分配，遇到这种情况时，有两种处理方案：</p>
<p>1、如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则直接在堆内存中对该对象进行内存分配。</p>
<p>2、如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则废弃当前TLAB，重新申请TLAB空间再次进行内存分配。</p>
<p>以上两个方案各有利弊，如果采用方案1，那么就可能存在着一种极端情况，就是TLAB只剩下1KB，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。</p>
<p>如果采用方案2，也有可能存在频繁废弃TLAB，频繁申请TLAB的情况，而我们知道，虽然在TLAB上分配内存是线程独享的，但是TLAB内存自己从堆中划分出来的过程确实可能存在冲突的，所以，TLAB的分配过程其实也是需要并发控制的。而频繁的TLAB分配就失去了使用TLAB的意义。</p>
<p><strong>为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间”。</strong></p>
<p>当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配。</p>
<p>前面的例子中，TLAB总空间100KB，使用了80KB，剩余20KB，如果设置的refill_waste的值为25KB，那么如果新对象的内存大于25KB，则直接堆内存分配，如果小于25KB，则会废弃掉之前的那个TLAB，重新分配一个TLAB空间，给新对象分配内存。</p>
<h3 id="TLAB使用的相关参数"><a href="#TLAB使用的相关参数" class="headerlink" title="TLAB使用的相关参数"></a>TLAB使用的相关参数</h3><p>TLAB功能是可以选择开启或者关闭的，可以通过设置-XX:+/-UseTLAB参数来指定是否开启TLAB分配。</p>
<p><strong>TLAB默认是eden区的1%，</strong>可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>默认情况下，TLAB的空间会在运行时不断调整，使系统达到最佳的运行状态。如果需要禁用自动调整TLAB的大小，可以使用-XX:-ResizeTLAB来禁用，并且使用-XX：TLABSize来手工指定TLAB的大小。</p>
<p>TLAB的refill_waste也是可以调整的，默认值为64，即表示使用约为1/64空间大小作为refill_waste，使用参数：-XX：TLABRefillWasteFraction来调整。</p>
<p>如果想要观察TLAB的使用情况，可以使用参数-XX+PringTLAB 进行跟踪。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。</strong></p>
<p>在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p><strong>所以，“堆是线程共享的内存区域”这句话并不完全正确，因为TLAB是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分分配上，是线程独享的。</strong></p>
<p>TLAB的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试TLAB分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再eden分配还是在老年代分配。</p>
<p><img src="http://www.hollischuang.com/wp-content/uploads/2020/03/tlab2.png" alt="img"></p>
<h2 id="3-对象的内存布局"><a href="#3-对象的内存布局" class="headerlink" title="3 对象的内存布局"></a>3 对象的内存布局</h2><p>一个对象本身的内在结构需要一种描述方式，这个描述信息是以字节码的方法存储在方法区中的。<br>Class 本身就是一个对象，都以 KB 为单位，如果 new Integer() 为了表示一个数据就占用KB级别的内存就有点不值了，下面讲解 JVM 是如何做的。<br>为了表示对象的属性、方法等信息，不得不需要结构描述。Hotspot VM 使用对象头部的一个指针指向 Class 区域的方式来找到对象的 Class 描述，以及内部的方法、属性入口。如下图所示：</p>
<p><img src="D:\学习资料\面试题总结\JVM\对象内存结构.png"></p>
<p>在 HotSpot 虚拟机中，对象在内存中存储布局分为 4 块区域：<strong>对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</strong>，下面详细讲解各部分内容。</p>
<h3 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h3><p>HotSpot 虚拟机的对象头包括两部分（非数组对象）信息，如下图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/731716/201703/731716-20170302104003563-2094361065.png" alt="img"></p>
<ul>
<li>第一部分用于存储对象自身的<strong>运行时数据</strong>，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄，这部分信息称为“Mark Word”；Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。</li>
<li>第二部分是<strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；</li>
<li>如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。</li>
</ul>
<p>这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。</p>
<p>例如，在 32 位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么 Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，如下表所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/731716/201703/731716-20170302152004001-388228627.png" alt="img"></p>
<p>在 32 位系统下，存放 Class 指针的空间大小是 4 字节，Mark Word 空间大小也是4字节，因此头部就是 8 字节，如果是数组就需要再加 4 字节表示数组的长度，如下表所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/731716/201703/731716-20170302152048845-1639352445.png" alt="img"></p>
<p>在 64 位系统及 64 位 JVM 下，开启指针压缩，那么头部存放 Class 指针的空间大小还是4字节，而 Mark Word 区域会变大，变成 8 字节，也就是头部最少为 12 字节，如下表所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/731716/201703/731716-20170302152202938-44866486.png" alt="img"></p>
<blockquote>
<p>压缩指针：开启指针压缩使用算法开销带来内存节约，Java 对象都是以 8 字节对齐的，也就是以 8 字节为内存访问的基本单元，那么在地理处理上，就有 3 个位是空闲的，这 3 个位可以用来虚拟，利用 32 位的地址指针原本最多只能寻址 4GB，但是加上 3 个位的 8 种内部运算，就可以变化出 32GB 的寻址。</p>
</blockquote>
<h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
<p>这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。</p>
<h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>对齐填充不是必然存在的，没有特别的含义，它仅起到占位符的作用。</p>
<p>由于 HotSpot VM 的自动内存管理系统要求<strong>对象起始地址必须是 8 字节的整数倍</strong>，也就是说对象的大小必须是 8 字节的整数倍。对象头部分是 8 字节的倍数，所以当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="估算对象大小"><a href="#估算对象大小" class="headerlink" title="估算对象大小"></a>估算对象大小</h3><p>32 位系统下，当使用 new Object() 时，JVM 将会分配 8（Mark Word+类型指针） 字节的空间，128 个 Object 对象将占用 1KB 的空间。<br>如果是 new Integer()，那么对象里还有一个 int 值，其占用 4 字节，这个对象也就是 8+4=12 字节，对齐后，该对象就是 16 字节。</p>
<p>以上只是一些简单的对象，那么对象的内部属性是怎么排布的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中对象头部占用 ‘Mark Word’4 + ‘类型指针’4 = 8 字节；byte 8 位长，占用 1 字节；int 32 位长，占用 4 字节；String 只有引用，占用 4 字节；<br>那么对象 A 一共占用了 8+1+4+4=17 字节，按照 8 字节对齐原则，对象大小也就是 24 字节。</p>
<p>这个计算看起来是没有问题的，对象的大小也确实是 24 字节，但是对齐（padding）的位置并不对：</p>
<p>在 HotSpot VM 中，对象排布时，间隙是在 4 字节基础上的（在 32 位和 64 位压缩模式下），上述例子中，int 后面的 byte，空隙只剩下 3 字节，接下来的 String 对象引用需要 4 字节来存放，因此 byte 和对象引用之间就会有 3 字节对齐，对象引用排布后，最后会有 4 字节对齐，因此结果上依然是 7 字节对齐。此时对象的结构示意图，如下图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/731716/201703/731716-20170302151508860-655456010.png" alt="img"></p>
<h1 id="三-对象在虚拟机中的访问定位"><a href="#三-对象在虚拟机中的访问定位" class="headerlink" title="三.对象在虚拟机中的访问定位"></a>三.对象在虚拟机中的访问定位</h1><p>创建对象是为了使用对象，我们的<strong>Java程序通过栈上的reference数据来操作堆上的具体对象</strong>。在虚拟机规范中，reference类型中只规定了一个指向对象的引用，并没有定义这个<strong>引用使用什么方式去定位、访问堆中的对象的具体位置</strong>。目前的主流的访问方式有<strong>使用句柄访问和直接指针访问</strong>两种。</p>
<ul>
<li>句柄方式：如果使用句柄访问的话，Java堆中将会划分一块内存来作为句柄池，<strong>栈中的reference中存储的就是对象的句柄地址</strong>，而<strong>句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>，如图所示：</li>
</ul>
<p><img src="https://img-blog.csdn.net/20170505200615074?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<ul>
<li>直接指针方式：如果使用直接指针访问，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而<strong>reference中存储的直接就是对象地址</strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20170505200629589?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>总的来说，这两种对象访问定位方式各有千秋。<u>使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，reference本身不需要修改；而使用直接指针访问的最大好处就是速度快，节省了一次指针定位的时间开销</u>。</p>
<h1 id="四、JVM内存结构-VS-Java内存模型-VS-Java对象模型"><a href="#四、JVM内存结构-VS-Java内存模型-VS-Java对象模型" class="headerlink" title="四、JVM内存结构 VS Java内存模型 VS Java对象模型"></a>四、JVM内存结构 VS Java内存模型 VS Java对象模型</h1><h2 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1 JVM内存结构"></a>1 JVM内存结构</h2><p><img src="http://www.hollischuang.com/wp-content/uploads/2018/06/QQ20180624-150918.png" alt="img"></p>
<p>各个区域的功能不是本文重点，就不在这里详细介绍了。这里简单提几个需要特别注意的点：</p>
<p>1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p>
<p>2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p>
<p>3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p>
<p>4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p>
<p>5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p>
<p>6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p>
<h2 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2 Java内存模型"></a>2 Java内存模型</h2><p>Java内存模型是根据英文<strong>Java Memory Model（JMM）</strong>翻译过来的。其实<strong>JMM</strong>并不像JVM内存结构一样是真实存在的。他只是一个<strong>抽象的概念</strong>。<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">JSR-133: Java Memory Model and Thread Specification</a>中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p>
<p>那么，简单总结下，<strong>Java的多线程之间是通过共享内存进行通信的</strong>，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>
<p><img src="http://www.hollischuang.com/wp-content/uploads/2018/06/11.png" alt="img"></p>
<h2 id="3-Java对象模型"><a href="#3-Java对象模型" class="headerlink" title="3 Java对象模型"></a>3 Java对象模型</h2><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>
<p>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p>
<p>关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答：</p>
<blockquote>
<p>对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。</p>
</blockquote>
<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    Model modelA = <span class="keyword">new</span> Model(<span class="number">2</span>);</span><br><span class="line">    Model modelB = <span class="keyword">new</span> Model(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.hollischuang.com/wp-content/uploads/2018/06/20170615230126453.jpeg" alt="img"></p>
<p>从上图中可以看到，在方法区的instantKlass中有一个<code>int a=1</code>的数据存储。在堆内存中的两个对象的oop中，分别维护着<code>int b=3</code>,<code>int b=2</code>的实例数据。和oopDesc一样，instantKlass也维护着一些<code>fields</code>，用来保存类中定义的类数据，比如<code>int a=1</code>。</p>
<p><img src="D:\学习资料\面试题总结\JVM\对象内存结构.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/57047be04389">Java运行时内存区域</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/71189093">JVM 内存模型概述</a></p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/4510">Java堆内存是线程共享的！面试官：你确定吗？</a></p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/2509">JVM内存结构 VS Java内存模型 VS Java对象模型</a></p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/1910">深入理解多线程（二）—— Java的对象模型</a></p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/4521">求你了，别再说Java对象都是在堆内存上分配空间的了！</a>intern</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MuChengxue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://muchengxue.github.io/2021/12/18/Java/JVM/java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">http://muchengxue.github.io/2021/12/18/Java/JVM/java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://muchengxue.github.io" target="_blank">暮成雪的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">java内存模型</a></div><div class="post_share"><div class="social-share" data-image="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/18/Java/JVM/Java%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"><img class="prev-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关键字</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Java/JVM/Compile%20once%EF%BC%8Crun%20anywhere%EF%BC%81/"><img class="next-cover" src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Compile once，run anywhere！</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myFavicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MuChengxue</div><div class="author-info__description">记录学习，记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/muchengxue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muchengxue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jinyang_ke@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录学习，记录生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">一.Java运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1、线程私有的数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2  Java虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2、线程共享的数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Java%E5%A0%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 Java堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%98%AF%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">java对象都是在堆上分配空间的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JIT-%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">JIT 技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E6%A3%80%E6%B5%8B"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">热点检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">编译优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2%E3%80%81%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">标量替换、栈上分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">标量替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%81%E6%98%8E"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">实验证明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B9%B6%E4%B8%8D%E6%88%90%E7%86%9F"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">逃逸分析并不成熟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%A0%86-%E4%B8%8E-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Java堆 与 方法区的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">方法区的回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PermGen%EF%BC%88%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%89"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">PermGen（永久代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metaspace%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">Metaspace（元空间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%8F%98%E8%BF%81"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">方法区变迁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java8%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.8.</span> <span class="toc-text">java8内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8Cjdk%E4%B8%8B%E7%9A%84String-intern"><span class="toc-number">1.2.2.9.</span> <span class="toc-text">不同jdk下的String.intern()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81JVM%E2%80%93%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">1.3.</span> <span class="toc-text">3、JVM–参数调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="toc-number">2.</span> <span class="toc-text">二.Java对象的创建与访问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">1 对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-TLAB%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.</span> <span class="toc-text">2 TLAB技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLAB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">TLAB带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLAB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">TLAB使用的相关参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.</span> <span class="toc-text">3 对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88Header%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">对象头（Header）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%88Instance-Data%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">实例数据（Instance Data）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%EF%BC%88Padding%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">对齐填充（Padding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E7%AE%97%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">估算对象大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.</span> <span class="toc-text">三.对象在虚拟机中的访问定位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-VS-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-VS-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">四、JVM内存结构 VS Java内存模型 VS Java对象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">1 JVM内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2 Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3 Java对象模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.169Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/%E4%BA%8B%E5%8A%A1/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.165Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Sentinel/" title="无题"><img src="https://raw.githubusercontent.com/MuChengxue/picBed/master/747964.jpg?token=AGGYH3PWZT2BGLNDDZORD4LBXS5CC" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Sentinel/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.161Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Replication/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Replication/" title="无题">无题</a><time datetime="2021-12-18T14:44:09.155Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字"><img src="http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关键字"/></a><div class="content"><a class="title" href="/2021/12/18/Java/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="关键字">关键字</a><time datetime="2021-12-18T14:44:09.151Z" title="发表于 2021-12-18 14:44:09">2021-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http://tva4.sinaimg.cn/large/005JNP0Hly1gaw01xqwk2j31hc0u0gus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By MuChengxue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
      appKey: 'Q5AgpWIhyjBqzKm5oObDrcz2',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://E5eH22JQ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'E5eH22JQlDgiI7dGLIywVRVy-9Nh9j0Va',
        "X-LC-Key": 'Q5AgpWIhyjBqzKm5oObDrcz2',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 2/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="627070825" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="^_^,^_^,^_^" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>